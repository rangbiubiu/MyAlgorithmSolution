# 目录

[TOC]



## :fire:283. 移动零

### 题意

给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

**请注意** ，必须在不复制数组的情况下原地对数组进行操作。

**示例 1:**

```
输入: nums = [0,1,0,3,12]
输出: [1,3,12,0,0]
```

**示例 2:**

```
输入: nums = [0]
输出: [0]
```

**提示**:

- `1 <= nums.length <= 104`
- `-231 <= nums[i] <= 231 - 1` 

**进阶：**你能尽量减少完成的操作次数吗？

### 思路

==:star: **核心思路： 双指针  左移 + 直接赋值为0  **:star:==

**:key:  key：**

- 找到所有非零元素，每找到一个就将其移到左边，设移完后最后一个非零元素的下标是 i ，将 i 之后的元素全赋值为0.

```c++
void moveZeroes(vector<int>& nums) {
    int lastNonZero = 0;
    for (const int& elem : nums) {
        if (elem != 0) {
            nums[lastNonZero++] = elem;
        }
    }
    for (int i = lastNonZero; i < nums.size(); ++i) {
        nums[i] = 0;
    }
}
```

#### 复杂度分析

- 时间复杂度：O(n)  

- 空间复杂度：O(1)

## [345. 反转字符串中的元音字母](https://leetcode.cn/problems/reverse-vowels-of-a-string/)

### **题意**

给你一个字符串 `s` ，仅反转字符串中的所有元音字母，并返回结果字符串。

元音字母包括 `'a'`、`'e'`、`'i'`、`'o'`、`'u'`，且可能以大小写两种形式出现不止一次。

**示例 1：**

```
输入：s = "hello"
输出："holle"
```

**示例 2：**

```
输入：s = "leetcode"
输出："leotcede"
```

**示例 3：（自己加的、帮助理解题意）**

```Cpp
输入：s = "race a car"
输出："raca e car"
//把 aeaa 这几个元音字母拿出来，翻转完变成aaea 再填回去
```

**提示：**

- `1 <= s.length <= 3 * 105`
- `s` 由 **可打印的 ASCII** 字符组成

### 思路

==:star: **核心思路：双指针   **:star:==

主要知道怎么反转的，另外判断字母是否是元音字母，单独开一个函数判断即可。

### 代码

```c++
bool find(char c) {
    return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u'
    || c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U';
}
string reverseVowels(string s) {
    int n = s.size();
    int left = 0, right = n - 1;
    while (left < right) {
        while (left < right && !find(s[left])) ++left;
        while (left < right && !find(s[right])) --right;
        //退出循环时要么left或right的指向超出边界了，要么它们指向元音字符
        if (left < right) swap(s[left], s[right]);
        left++;
        right--;
    }
    return s;
}
```

## [680. 验证回文串 II](https://leetcode.cn/problems/valid-palindrome-ii/)

### **题意**

给你一个字符串 `s`，**最多** 可以从中删除一个字符。

请你判断 `s` 是否能成为回文字符串：如果能，返回 `true` ；否则，返回 `false` 。

**示例 1：**

```
输入：s = "aba"
输出：true
```

**示例 2：**

```
输入：s = "abca"
输出：true
解释：你可以删除字符 'c' 。
```

**示例 3：**

```
输入：s = "abc"
输出：false
```

**提示：**

- `1 <= s.length <= 105`
- `s` 由小写英文字母组成

### 参考题解

1. [负雪明烛](https://leetcode.cn/problems/valid-palindrome-ii/solutions/252740/cong-liang-ce-xiang-zhong-jian-zhao-dao-bu-deng-de)

### 思路

==:star: **核心思路： 双指针  **:star:==

**:small_red_triangle_down: steps: **

双指针逆向从两端往中间遍历，若

1.  `s[left] == s[right]`，则++left;--right;
2.  否则，直接return，return true还是false就根据删掉一个字符后，中间还没遍历过的字符串是否回文。

### 代码

```c++
bool isPalindrome(string s, int left, int right) {
    for (;left < right; ++left, --right) {
        if (s[left] != s[right]) return false;
    }
    return true;
}
bool validPalindrome(string s) {
    int left = 0, right = s.size() - 1;
    while (left < right) {
        if (s[left] == s[right]) {
            ++left;
            --right;
        }
        //当left和right指向的元素不等时，需要删除left或right指向的元素判断删除一个字符后的字符串是不是回文串
        //由于[0,left)和(right,n-1)这两段子串我们已经判断了是回文串，因此就不用再判断整个字符串是不是回文串，而只需要判断中间除去删除字符外的部分是不是回文，即只需要判断(left,right]或[left,right)是否回文即可知道return true还是false
        else return isPalindrome(s, left + 1, right) || isPalindrome(s, left, right - 1);
        //只要有一次走进了else，则无论怎样都会return而不会再继续往后执行了
        //因为走了else就说明用掉了那一次删除字符的机会
    }
    return true;
}
```

## [167. 两数之和 II - 输入有序数组](https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/)

### **题意**

给你一个下标从 **1** 开始的整数数组 `numbers` ，该数组已按 **非递减顺序排列** ，请你从数组中找出满足相加之和等于目标数 `target` 的两个数。如果设这两个数分别是 `numbers[index1]` 和 `numbers[index2]` ，则 `1 <= index1 < index2 <= numbers.length` 。

以长度为 2 的整数数组 `[index1, index2]` 的形式返回这两个整数的下标 `index1` 和 `index2`。

你可以假设每个输入 **只对应唯一的答案** ，而且你 **不可以** 重复使用相同的元素。

你所设计的解决方案必须只使用常量级的额外空间。

**示例 1：**

```
输入：numbers = [2,7,11,15], target = 9
输出：[1,2]
解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。返回 [1, 2] 。
```

**示例 2：**

```
输入：numbers = [2,3,4], target = 6
输出：[1,3]
解释：2 与 4 之和等于目标数 6 。因此 index1 = 1, index2 = 3 。返回 [1, 3] 。
```

**示例 3：**

```
输入：numbers = [-1,0], target = -1
输出：[1,2]
解释：-1 与 0 之和等于目标数 -1 。因此 index1 = 1, index2 = 2 。返回 [1, 2] 。
```

**提示：**

- `2 <= numbers.length <= 3 * 104`
- `-1000 <= numbers[i] <= 1000`
- `numbers` 按 **非递减顺序** 排列
- `-1000 <= target <= 1000`
- **仅存在一个有效答案**

### 思路

==:star: **核心思路： 双指针  **:star:==

**:key:  key：**

- 把题目描述搞清楚即可。从"下标1开始的数组"就是返回的index都要+1而已；"不可以重复使用相同的元素"就是不能使用重复的值。

### 代码

```c++
vector<int> twoSum(vector<int>& numbers, int target) {
    int left = 0, right = numbers.size() - 1;
    while (left < right) {
        int sum = numbers[left] + numbers[right];
        if (sum == target) return {left+1,right+1};
        else if (sum < target) ++left;
        else --right;
    }
    return {-1,-1};
}
```

### 复杂度分析

- 时间复杂度：O(n)  

- 空间复杂度：O(1)

## :fire:[15. 三数之和](https://leetcode.cn/problems/3sum/)

**题意：**

在一个数组中判断是否存在满足nums[i]+nums[j]+nums[k]==0（i,j,k互不相等）的三元组[nums[i], nums[j], nums[k]]，并返回所有和为 `0` 且不重复的三元组。

**示例 1：**

```
输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
解释：
nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。
nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。
nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。
不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。
注意，输出的顺序和三元组的顺序并不重要。
```

**示例 2：**

```
输入：nums = [0,1,1]
输出：[]
解释：唯一可能的三元组和不为 0 。
```

**示例 3：**

```
输入：nums = [0,0,0]
输出：[[0,0,0]]
解释：唯一可能的三元组和为 0 。
```

**提示：**

- `3 <= nums.length <= 3000`
- `-105 <= nums[i] <= 105`

### 参考题解

1. 卡哥

### 思路

==:star: **核心思路： 排序 + 双指针 + 去重  **:star:==

**:question:  problems:** 

1. 如何最高效的找到满足条件的三元组？
2. 三个指针如何移动？
3. 三元组怎么去重？

 :ballot_box_with_check:**answer:** 

1. 排序 + 双指针。因为要找和为0的三个值，必须固定其中一个去找另外两个，另外两个怎么找？
    - 排序后，我们用双指针分别指向搜索区间的左右端点，通过比较sum和0的大小控制指针的移动，一边找解一边缩小查找范围

2. 每一轮固定 i 不动，初始让left指向i+1，right指向数组最后一个位置.  每轮中若和>0则right要左移, <0则left要右移

3. 对于i，我们在遍历start时就可以对其去重，跳过相同值。但是注意！写成 `nums[i]==nums[i + 1]`和写成`nums[i]==nums[i-1]`是不一样的！如果写成前者，那么我们就把 三元组中出现重复元素的情况直接pass掉了。**我们要做的是 不能有重复的三元组，但三元组内的元素是可以重复的！**

    对于left和right, 找到一个解之后，将left右边与left相同的值一路跳过，将right左边与right相同的值一路跳过.

    这样就实现了解的去重。

![image-20240114131721477](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202401141317925.png)

### 代码

```c++
vector<vector<int>> threeSum(vector<int>& nums) {
    vector<vector<int>> res;
    sort(nums.begin(), nums.end());
    for (int i = 0; i < nums.size(); ++i) {
        if (nums[i] > 0) break;
        if (i > 0 && nums[i] == nums[i - 1]) continue;
        // 在[i+1,nums.size()-1]中找left和right,满足nums[i]+nums[left]+nums[right]=0
        int left = i + 1, right = nums.size() - 1;
        while (left < right) {
            int sum = nums[i] + nums[left] + nums[right];
            if (sum == 0) { //存结果，去重【去重是关键！】
                res.push_back({nums[i],nums[left],nums[right]});
                // 不能写成res.emplace_back({i, left, right});
                while (left < right && nums[left] == nums[left + 1]) ++left;
                while (left < right && nums[right] == nums[right - 1]) --right;
                ++left; right--;
            }
            else if (sum > 0) right--;
            else left++;
        }
    }
    return res;
}
```

### **复杂度分析**

- 时间复杂度：每一轮中遍历[left,right]区间的复杂度为O(N^2^)，排序的时间复杂度为 O(Nlog⁡N)，因此总的时间复杂度为O(N^2^)。

- 空间复杂度：O(logN)。我们忽略存储答案的空间，额外的排序的空间复杂度为 O(log⁡N)。

## **[16. 最接近的三数之和](https://leetcode.cn/problems/3sum-closest/)**

### **题意**

给你一个长度为 `n` 的整数数组 `nums` 和 一个目标值 `target`。请你从 `nums` 中选出三个整数，使它们的和与 `target` 最接近。

返回这三个数的和。

假定每组输入只存在恰好一个解。

**示例 1：**

```
输入：nums = [-1,2,1,-4], target = 1
输出：2
解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。
```

**示例 2：**

```
输入：nums = [0,0,0], target = 1
输出：0
```

**提示：**

- `3 <= nums.length <= 1000`
- `-1000 <= nums[i] <= 1000`
- `-104 <= target <= 104`

### 思路

==:star: **核心思路： +   +   **:star:== 同15题 

**:small_red_triangle_down: steps: **

1.  for循环每次固定start，初始化左右双指针
2.  `while(left < right)`不断缩小查找区间
    1.  计算当前三数之和`sum`及其与target的差`curdiff`
    2.  如果差值==0，那就是最小差值，直接return
    3.  如果>0(sum > target)，说明要让sum变小，则需要让right--
    4.  如果<0(sum < target)，说明要让sum变大，则需要让left++
    5.  如果当前差值<minDiff，更新minDiff 和 res

3.  返回res

### 代码

```c++
int threeSumClosest(vector<int>& nums, int target) {
    sort(nums.begin(), nums.end());
    int minDiff = INT_MAX, res = 0;
    for(int start = 0; start < nums.size(); ++start) {
        int left = start + 1, right = nums.size() - 1;
        while (left < right) {
            int sum = nums[start] + nums[left] + nums[right];
            int curDiff = sum - target;
            
            if(curDiff == 0) return target;
            else if (curDiff > 0) --right;
            else ++left;

            if (abs(curDiff) < minDiff) {
                minDiff = abs(curDiff);
                res = sum;
            }
        }
    }
    return res;
}
```

## [18. 四数之和](https://leetcode.cn/problems/4sum/)

与[15. 三数之和](https://leetcode.cn/problems/3sum/)大致思路差不多，区别在于：

1. 比较的值不是0而是target，target有可能为负，因此若nums[i]<0,则i继续往后遍历，sum是先减小后增大。
2. 因此当target<nums[i]<0时，则往后做和运算和可能增大也可能减小。因此思考什么时候当nums[i]已经大于target时再往后和只可能增大？--当nums[i] >= 0时
3. 注意这里与三数之和不一样，因为target可以是负数，若target<nums[i]<0，则往后做和运算和可能增大也可能减小。因此思考什么时候当nums[i]已经大于target时再往后和只可能增大？--当nums[i] >= 0时

另外注意，对指向四元组的第二个元素的指针 j 的去重同 i 一样，都是要和前一个比较去重。

```c++
vector<vector<int>> fourSum(vector<int>& nums, int target) {
    sort(nums.begin(), nums.end());
    vector<vector<int>> res;
    for (int i = 0; i < nums.size(); ++i) {
        if (nums[i] > target && nums[i] >= 0) return res;//i的剪枝
        if (i > 0 && nums[i] == nums[i - 1]) continue;//i的去重
        for (int j = i + 1; j < nums.size(); ++j) {
            int twoSum = nums[i] +nums[j];
            if (twoSum > target && twoSum >= 0) break;//j的剪枝
            if (j > i + 1 && nums[j] == nums[j - 1]) continue;//j的去重，原理同i的去重一样
            int left = j + 1, right = nums.size() - 1;
            while (left < right) {
                long sum = (long) nums[i] + nums[j] + nums[left] + nums[right];
                if (sum == target) {
                    res.push_back({nums[i], nums[j], nums[left], nums[right]});
                    //left和right的去重
                    while (left < right && nums[left] == nums[left + 1]) ++left;
                    while (left < right && nums[right] == nums[right - 1]) --right;
                    ++left;
                    --right;
                }
                else if (sum < target) left++;
                else right--;
            }
        }
    }
    return res;
}
```

复杂度分析

- 时间复杂度：O(n^3^)  

- 空间复杂度：O(logn)

![image-20240114133407030](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202401141334307.png)

## :fire:[11. 盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/)

### 题意

给定一个长度为 `n` 的整数数组 `height` 。有 `n` 条垂线，第 `i` 条线的两个端点是 `(i, 0)` 和 `(i, height[i])` 。

找出其中的两条线，使得它们与 `x` 轴共同构成的容器可以容纳最多的水。

返回容器可以储存的最大水量.

**示例 1：**

![image-20240114152336678](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202401141523777.png)

```
输入：[1,8,6,2,5,4,8,3,7]
输出：49 
解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。
```

**示例 2：**

```
输入：height = [1,1]
输出：1
```

**提示：**

- `n == height.length`
- `2 <= n <= 105`
- `0 <= height[i] <= 104`

### 参考题解

1. [nettee](https://leetcode.cn/problems/container-with-most-water/solutions/94102/on-shuang-zhi-zhen-jie-fa-li-jie-zheng-que-xing-tu) 我擦直呼大佬牛逼🐂！！！

### 思路

==:star: **核心思路：双指针  **:star:==

题意就是要求两根线构成的最大面积。

**:question:   problems:** 

1. 双指针是怎么移动的？
2. 双指针解法到底是怎么优化时间复杂度的？

:heavy_check_mark:  **answer:** 

![image-20240114195407965](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202401141954529.png)

### 代码

```c++
int maxArea(vector<int>& height) {
    /*
        盛水量取决于较短的一边和两根柱子的距离
        用左右双指针分别从左右两端开始，
        如果移动较长的柱子，则由于盛水量取决于较短的一边，且距离缩短，因此盛水量不可能增加
        因此只能移动较短的柱子，边移动边更新当前盛水量。
        当移动到比长柱子还长的柱子时，长短柱子身份切换
    */
    int res = 0;
    int left = 0;
    int right = height.size() - 1;
    while (left < right) {
        int s = (right - left) * min(height[left], height[right]);
        // 注意不是right-left+1！因为height[0]就是第一根柱子，height[0]与height[1]宽度不是1-0+1而是1.
        res = max(res, s);
        // 谁长谁不动，短的往中间移动
        if (height[left] < height[right]) {
            left++;
        } else {
            right--;
        }
    }
    return res;
}
```

### 复杂度分析

- 时间复杂度：O(n)  

- 空间复杂度：O(1)

## :fire:[42. 接雨水](https://leetcode.cn/problems/trapping-rain-water/)

### **题意**

给定 `n` 个非负整数表示每个宽度为 `1` 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

**示例 1：**

![img](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202401151619184.png)

```
输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]
输出：6
解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 
```

**示例 2：**

```
输入：height = [4,2,0,3,2,5]
输出：9 
```

**提示：**

- `n == height.length`
- `1 <= n <= 2 * 104`
- `0 <= height[i] <= 105`

### 参考题解

1. [0x3f](https://www.bilibili.com/video/BV1Qg411q7ia/?spm_id_from=333.788&vd_source=ff6d470acf2c91a9a48f2ac99a87fa5a)
2. [官解视频](https://leetcode.cn/problems/trapping-rain-water/solutions/692342/jie-yu-shui-by-leetcode-solution-tuvc)

### 思路

==:star: **核心思路：dp / 双指针 / 单调栈   **:star:==

**:key:  dp思路：**

- `一个柱子能盛的水 = min(左右两边最高柱子的高度) - 自己的高度`
- 先统计每根柱子的前缀和后缀最大值
- 关于这个前缀后缀最大值要不要包含自身的问题。——要!!! 因为
    - 当左右两边的柱子有比自己高的,
        - 不包含自身和包含自身, 计算出来的柱子能接的水都一样
    - 当左右两边的柱子都不比自己高时,
        - 如果不包含自身, 计算出来的柱子能接的水就为负了
        - 如果包含自身, 计算出来的柱子能接的水为0


**:key:  双指针思路：**

- 尽管中间还有柱子没遍历到,但总之,（设当前遍历到的left和right所指的柱子分别为 L 和 R ）
    - 如果右边的柱子[right,n)有比左边所有柱子[0,left]更高的，即`suf_max > pre_max`，那 L 接的水就能知道，其与右边的长柱子无关，而取决于短的pre_max ：`L 接的水= pre_max - 自己的高度`。（如果左边有比 L 更高的，接的水>0；否则接的水=0），接着让left++。
    - 如果左边的柱子[0,left]有比右边所有柱子[right,n)更高的，即`pre_max > suf_max`，那 R 接的水就能知道，其与左边的长柱子无关，而取决于短的suf_max：`R 接的水 = suf_max - 自己的高度`。（如果右边有比 R 更高的，接的水>0；否则接的水=0），接着让right--。

![image-20240115161721207](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202401151617793.png)

### 代码

#### dp

```c++
int trap(vector<int>& height) {
    int res = 0;
    // 每根柱子能接多少水 = min(左边最高柱子,右边最高柱子) - 自己的高度
    int n = height.size();
    // 先统计每根柱子的前缀和后缀最大值(自己也要算进去)
    vector<int> prefix_max(n);
    vector<int> suffix_max(n);
    prefix_max[0] = height[0];
    suffix_max[n - 1] = height[n - 1];
    int left = 1;
    int right = n - 2;
    while (left < n && right >= 0) {
        prefix_max[left++] = max(prefix_max[left - 1], height[left]);
        suffix_max[right--] = max(suffix_max[right + 1], height[right]);
    }
    // 然后逐个用公式求解
    for (int i = 0; i < n; ++i) {
        res += min(suffix_max[i], prefix_max[i]) - height[i];
    }
    return res;
}
```

**复杂度分析**

- 时间复杂度：O(n)  

- 空间复杂度：O(n)

#### 双指针

```c++
int trap(vector<int>& height) {
    int res = 0; 
    int n = height.size();
    // 记录目前为止遍历过的[0,left]和[right,n)的最大值
    int prefix_max = 0;
    int suffix_max = 0;
    int left = 0;
    int right = n - 1;
    while (left < right) {
        prefix_max = max(prefix_max, height[left]);
        suffix_max = max(suffix_max, height[right]);
        // 如果右边柱子中存在比左边柱子
        if (prefix_max > suffix_max) { //可算right所指柱子能接的水(取决于更短的suffix_max)
            res += suffix_max - height[right--];
        } else {    //可算left所指柱子能接的水(取决于更短的prefix_max)
            res += prefix_max - height[left++];
        }
    }
    return res;
}
```

**复杂度分析**

- 时间复杂度：O(n)  

- 空间复杂度：O(1)

#### 单调栈（待补充）

可参考：[CSLearnNotes (riba2534.cn)](https://notes.riba2534.cn/#/数据结构和算法/LeetCode/接雨水)

## [27.移除元素](https://leetcode.cn/problems/remove-element/)

### **题意**

给你一个数组 `nums` 和一个值 `val`，你需要 **[原地](https://baike.baidu.com/item/原地算法)** 移除所有数值等于 `val` 的元素，并返回移除后数组的新长度。

不要使用额外的数组空间，你必须仅使用 `O(1)` 额外空间并 **[原地 ](https://baike.baidu.com/item/原地算法)修改输入数组**。

元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

**示例 1：**

```
输入：nums = [3,2,2,3], val = 3
输出：2, nums = [2,2]
解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。
```

**示例 2：**

```
输入：nums = [0,1,2,2,3,0,4,2], val = 2
输出：5, nums = [0,1,3,0,4]
解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。
```

**提示：**

- `0 <= nums.length <= 100`
- `0 <= nums[i] <= 50`
- `0 <= val <= 100`

### 代码

双指针逆向，交换/跳过。

有两个细节需要注意：

1. 特判
2. 返回值要考虑清楚

```c++
int removeElement(vector<int>& nums, int val) {
    // 注意看题目提示中说num.size()可以为0！！因此必须特判
    if (nums.size() == 0) return 0;
    
    int left = 0, right = nums.size() - 1;
    while (left < right) {
        if (nums[left] == val) swap(nums[left],nums[right--]);
        else left++;//不等则跳过
    } 
    return nums[left] == val ? left : left + 1;
}
```

## [82. 删除排序链表中的重复元素 II](https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/)

写在链表那章节

## [611. 有效三角形的个数](https://leetcode.cn/problems/valid-triangle-number/)

### **题意**

给定一个包含非负整数的数组 `nums` ，返回其中可以组成三角形三条边的三元组个数。

**示例 1:**

```
输入: nums = [2,2,3,4]
输出: 3
解释:有效的组合是: 
2,3,4 (使用第一个 2)
2,3,4 (使用第二个 2)
2,2,3
```

**示例 2:**

```
输入: nums = [4,2,3,4]
输出: 4
```

**提示:**

- `1 <= nums.length <= 1000`
- `0 <= nums[i] <= 1000`

### 参考题解

1. [Jerring](https://leetcode.cn/problems/valid-triangle-number/solutions/12940/ming-que-tiao-jian-jin-xing-qiu-jie-by-jerring)

### 思路

==:star: **核心思路： 双指针 **:star:==

**:key:  key：**

- `a+b>c`中，a, b, c 分别对应代码中的指针 left, right, i 所表示的值。
    - i是从后往前逆向遍历，对应边长:arrow_down:
    - left和right是相向双指针，left是正向遍历，对应边长:arrow_up:；right是逆向遍历，对应边长:arrow_down:

- 固定住 i 之后，若`nums[left] + numd[right] > nums[i]`，那么left从当前位置一直到right-1，都能和指针 right , i 表示的边组成三角形，共可以组成 right-left 个；否则说明left表示的边不够长，要++left变长。

### 代码

```c++
int triangleNumber(vector<int>& nums) {
    int n = nums.size(), res = 0;
    sort(nums.begin(), nums.end());
    for (int i = n - 1; i >= 2; --i) { //固定最长的一条边
        int left = 0, right = i - 1;
        while (left < right) {
            if (nums[left] + nums[right] > nums[i]) {
            // 如果nums[left] + numd[right] > nums[i]，那么left从当前位置一直到right-1，都能和right,i组成三角形，有right-left个
                res += right - left;
                --right;
            }
            else ++left;//如果不够组成三角形，那么left右移让一条边变长
        }
    }
    return res;
}
```

### 复杂度分析

- 时间复杂度：O(n^2^)  。循环每次固定i，然后用左右双指针遍历一遍数组，就是O(n^2^)。
- 空间复杂度：O(1)

## [187. 重复的DNA序列](https://leetcode.cn/problems/repeated-dna-sequences/)

### **题意**

**DNA序列** 由一系列核苷酸组成，缩写为 `'A'`, `'C'`, `'G'` 和 `'T'`.。

- 例如，`"ACGAATTCCG"` 是一个 **DNA序列** 。

在研究 **DNA** 时，识别 DNA 中的重复序列非常有用。

给定一个表示 **DNA序列** 的字符串 `s` ，返回所有在 DNA 分子中出现不止一次的 **长度为 `10`** 的序列(子字符串)。你可以按 **任意顺序** 返回答案。

**示例 1：**

```
输入：s = "AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT"
输出：["AAAAACCCCC","CCCCCAAAAA"]
```

**示例 2：**

```
输入：s = "AAAAAAAAAAAAA"
输出：["AAAAAAAAAA"]
```

**提示：**

- `0 <= s.length <= 105`
- `s[i]``==``'A'`、`'C'`、`'G'` or `'T'`

### 参考题解

1. [官解](https://leetcode.cn/problems/repeated-dna-sequences/solutions/1035568/zhong-fu-de-dnaxu-lie-by-leetcode-soluti-z8zn)

### 法一

==:star: **核心思路： 暴力哈希一把梭   **:star:==

**:question:   problems:** 

1. 为什么最后不用判断tmp是否在map中，而可以直接 if (++map[tmp] == 2)？

:heavy_check_mark:  **answer:** 

1. 因为如果 tmp 不存在于map中，map[tmp]会被默认初始化为 0，然后再 ++ 。

    也就是说，if (++map[tmp] == 2) 这行代码的逻辑是：

    - 如果 tmp 不在 map 中，map[tmp] 会变成 1，然后和 2 比较，条件不满足；
    - 如果 tmp 已经在 map 中，map[tmp] 的值会增加为 2，然后和 2 比较，条件满足，执行 res.push_back(tmp)。

    这样的做法简化了代码，因为 **==unordered_map 在访问不存在的键时，会默认初始化为 0，不需要显式判断 tmp 是否在 map 中。这是 C++ 中 unordered_map 的一种特性，允许直接访问不存在的键而不报错，并在访问时进行默认初始化。==**

#### 代码

```c++
vector<string> findRepeatedDnaSequences(string s) {
    int n = s.size();
    vector<string> res;
    if (n < 10) return res;
    unordered_map<string, int> map;
    for (int i = 0; i <= n - L; ++i) {
        string tmp = s.substr(i, L);
        if (++map[tmp] == 2) res.push_back(tmp);
    }
    return res;
}
```

#### 复杂度分析

- 时间复杂度：O(NL)  . N是字符串的长度，L是子串的长度10。

- 空间复杂度：O(NL)

### 法二

==:star: **核心思路： 哈希表 + 滑动窗口 + 位运算  **:star:==

#  

# 滑动窗口专题

## [643. 子数组最大平均数 I](https://leetcode.cn/problems/maximum-average-subarray-i/)

### **题意**

给你一个由 `n` 个元素组成的整数数组 `nums` 和一个整数 `k` 。

请你找出平均数最大且 **长度为 `k`** 的连续子数组，并输出该最大平均数。

任何误差小于 10^-5^ 的答案都将被视为正确答案。

**示例 1：**

```
输入：nums = [1,12,-5,-6,50,3], k = 4
输出：12.75
解释：最大平均数 (12-5-6+50)/4 = 51/4 = 12.75
```

**示例 2：**

```
输入：nums = [5], k = 1
输出：5.00000
```

**提示：**

- `n == nums.length`
- `1 <= k <= n <= 105`
- `-104 <= nums[i] <= 104`

### 思路

==:star: **核心思路： 滑动窗口   **:star:==

:small_red_triangle_down: steps: 

1.  初始时窗口左端点固定不动，右端点右移直到窗口大小为k，之后窗口大小固定为k右移，同时不断更新窗口总和，若窗口总和>maxSum则更新maxSum.
2.  计算窗口取最大总和时的平均数，转换为double并返回

:smiley: **收获： ** 

- `static_cast<double>`:从一个基本类型转换到double

**:x: careless | ignore :**

- 若最后`return maxSum / k;`则是先将计算结果取整再转为double，会丢失精度！

### 代码

```c++
double findMaxAverage(vector<int>& nums, int k) {
    int n = nums.size(), sum = 0;
    //只有第一个滑窗的元素个数是慢慢增多到k的，之后的滑动窗口大小都是固定为k直接右移
    for (int i = 0; i < k; ++i) sum += nums[i];
    int maxSum = sum;
    for (int i = k; i < n; ++i) { 
        //第二个滑窗索引范围是[1,k]=[i-k+1,i], 滑窗要右移将[i-k]从滑窗移出，同时将[i]移入
        sum = sum - nums[i - k] + nums[i];
        maxSum = max(sum, maxSum);
    }
    return static_cast<double>(maxSum) / k;
}
```

### 复杂度分析

- 时间复杂度：O(n)  
- 空间复杂度：O(1)

## [674. 最长连续递增序列](https://leetcode.cn/problems/longest-continuous-increasing-subsequence/)

### 题意

给定一个未经排序的整数数组，找到最长且 **连续递增的子序列**，并返回该序列的长度。

**连续递增的子序列** 可以由两个下标 `l` 和 `r`（`l < r`）确定，如果对于每个 `l <= i < r`，都有 `nums[i] < nums[i + 1]` ，那么子序列 `[nums[l], nums[l + 1], ..., nums[r - 1], nums[r]]` 就是连续递增子序列。

**示例 1：**

```
输入：nums = [1,3,5,4,7]
输出：3
解释：最长连续递增序列是 [1,3,5], 长度为3。
尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。 
```

**示例 2：**

```
输入：nums = [2,2,2,2,2]
输出：1
解释：最长连续递增序列是 [2], 长度为1。
```

**提示：**

- `1 <= nums.length <= 104`
- `-109 <= nums[i] <= 109`

### 思路

==:star: **核心思路： 滑动窗口   **:star:==

**:x: careless | ignore :**

- 就是注意如果写成第一种最后要细心点不能直接返回res，而是还要考虑整个数组都单调递增的情况，此时只会不断++cnt，一次都不会更新res

### 代码

```c++
int findLengthOfLCIS(vector<int>& nums) {
    int n = nums.size();
    if (n <= 1) return n;
    int cnt = 1, res = 1;

    // 一种写法、
    
    // for (int i = 1; i < n; ++i) {
    //     if (nums[i - 1] < nums[i]) cnt++;
    //     else {
    //         res = max(res, cnt);
    //         cnt = 1;
    //     }
    // }
    // return max(res, cnt);//对于数组持续递增的情况，此时并不会更新res，要返回的就是cnt


    // 另一种写法、
    for (int i = 1; i < n; ++i) {
        if (nums[i - 1] < nums[i]) {
            cnt++;
            res = max(res, cnt);
        }
        else cnt = 1;
    }
    return res;
}
```

### 复杂度分析

- 时间复杂度：O(n)  

- 空间复杂度：O(1)

## [209. 长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/)

### **题意**

给定一个含有 `n` 个正整数的数组和一个正整数 `target` **。**

找出该数组中满足其总和大于等于 `target` 的长度最小的 **连续子数组**  ，返回其长度**。**如果不存在符合条件的子数组，返回 `0` .

**示例 1：**

```
输入：target = 7, nums = [2,3,1,2,4,3]
输出：2
解释：子数组 [4,3] 是该条件下的长度最小的子数组。
```

**示例 2：**

```
输入：target = 4, nums = [1,4,4]
输出：1
```

**示例 3：**

```
输入：target = 11, nums = [1,1,1,1,1,1,1,1]
输出：0
```

**提示：**

- `1 <= target <= 109`
- `1 <= nums.length <= 105`
- `1 <= nums[i] <= 105`

**进阶：**

- 如果你已经实现 `O(n)` 时间复杂度的解法, 请尝试设计一个 `O(n log(n))` 时间复杂度的解法。

### 参考题解

1. [我的法一题解](https://blog.csdn.net/rangbiubiu/article/details/132142137?spm=1001.2014.3001.5502)
1. 官解法二写的:shit:一样

> **==涉及连续子数组的问题，我们通常有两种思路：一是滑动窗口、二是前缀和==**

### 法一

==:star: **核心思路： 滑动窗口  **:star:==

**:small_red_triangle_down: steps: **

1.  初始化双指针
1.  右指针不断右移直到窗口总和+=target，此时找到一个解
1.  left++收缩窗口以找到长度更短的更优解
1.  若不存在满足条件的连续子数组，返回0；否则返回minlen

#### 代码

```c++
int minSubArrayLen(int target, vector<int>& nums) {
    int n = nums.size(), minlen = INT_MAX, sum = 0;
    for (int left = 0, right = 0; right < n; ++right) {
        if (nums[right] >= target) return 1;
        sum += nums[right];
        while (sum >= target) { //找到一个解后left++收缩窗口以找到更优解 
        // 为什么不是right--缩小窗口？因为就是right一路++到当前位置窗口才能>=target的，因此只有前面的部分是无法满足条件的，但只有后面的部分可能满足条件
            minlen = min(minlen, right - left + 1);
            sum -= nums[left++];
        }
    }
    return minlen == INT_MAX ? 0 : minlen;
}
```

#### 复杂度分析

- 时间复杂度：O(n)  

- 空间复杂度：O(1)

### 法二

==:star: **核心思路： 前缀和 + 二分查找   **:star:==

**:key:  key：**

- 如果暴力求解，我们会多次重复计算。用前缀和就可以解决这个问题。

**:small_red_triangle_down: steps: **

1.  统计每个元素nums[i]的前缀和
    - 前缀和要不要包含自己？
        - 设[j, i]是满足条件的子数组，则该子数组的和 >= [0,i]的元素之和 - [0,j-1]的元素之和
        - 可以设为不包含自己（那么prefixSum大小要+1）

1.  遍历前缀和，找满足 总和 = `prefixSum[end+1]-prefixSum[start] >= target`的子数组[start, end]
    - 由于前缀和数组是单调递增（有序）的，因此可以用二分查找加速查找
    - 固定start，在[start, size)的范围中二分找 `>= target + prefixSum[start]` 的 prefixSum[end+1]
    - 如果找到一个满足条件的索引，则计算当前子数组的长度。如果该长度<minlen，更新minlen

1.  若不存在满足条件的连续子数组，返回0；否则返回res

#### 代码

```c++
class Solution {
public:
    int binarySearchFirst(vector<int>& prefixSum, int left, int target) {
        // 找到第一个满足prefixSum[end+1] >= prefixSum[start]+target 的 end+1
        int right = prefixSum.size() - 1;
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (prefixSum[mid] >= target) {
                right = mid;
            } else {
                left = mid + 1;
            } 
        }
        return prefixSum[left] >= target ? left : -1;
    }
    int minSubArrayLen(int target, vector<int>& nums) {
        int n = nums.size(), minlen = INT_MAX;
        // 1.统计前缀和
        vector<int> prefixSum(n + 1);
        prefixSum[0] = 0;
        for (int i = 1; i <= n; ++i) {
            prefixSum[i] = prefixSum[i - 1] + nums[i - 1];
        }
        // 2.遍历前缀和找满足条件的子数组
        for (int start = 0; start <= n; ++start) {
            // 在[start, size-1]的范围中二分找 >= target + prefixSum[start] 的 prefixSum[end+1]
            int aim = prefixSum[start] + target; // 找 >= aim 的最小下标
            int enddp1 = binarySearchFirst(prefixSum, start, aim);//enddp1=end+1
            if (enddp1 != -1) {
                minlen = min(minlen, enddp1 - start);
            }
        }
        return minlen == INT_MAX ? 0 : minlen;
    }
};
```

#### 复杂度分析

- 时间复杂度：O(nlogn)  

- 空间复杂度：O(n)

## :fire:[560. 和为 K 的子数组](https://leetcode.cn/problems/subarray-sum-equals-k/)

### 题意

给你一个整数数组 `nums` 和一个整数 `k` ，请你统计并返回 *该数组中和为 `k` 的子数组的个数* 。

子数组是数组中元素的连续非空序列。

**示例 1：**

```
输入：nums = [1,1,1], k = 2
输出：2
```

**示例 2：**

```
输入：nums = [1,2,3], k = 3
输出：2
```

**提示：**

- `1 <= nums.length <= 2 * 104`
- `-1000 <= nums[i] <= 1000`
- `-107 <= k <= 107`

### 参考题解

1. 

### 思路

==:star: **核心思路： 前缀和 + 哈希  **:star:==

和上一题 【209.长度最小的子数组】不同的是，

1. 209是求前缀和大于等于k的，而560是求前缀和等于k的，因此209是在查找时最快只能用二分查找，而560就可以用哈希表来查找。
2. 209中nums[i]都是>=1的正数，而560中则可以是负数，因此如果求得nums的前缀和数组，那么它也不一定是单调递增的，因此实际上只能用哈希而不能用二分。
3. 209是求满足条件的长度最小的 **连续子数组** 的长度，而560是求满足条件的 **连续子数组** 的个数，因此在这题固定子数组的一端遍历前缀和时，我们不需要记录另一端的索引位置，只要知道有多少个这样满足条件的子数组。因此map中的value定义为: 存在几个相同的前缀和key。

**:key:  key：**

- 注意 i 之前可能有多个相同的历史前缀和，因此map中的value应为这个前缀和出现的次数，而不是表示这是哪个下标的前缀和。那怎么保证这个前缀和是在 i 之前的前缀和呢？那就要在查找完了之后再把当前前缀和的出现次数++;
- 由于我们只关心是否存在且存在几个 = 当前前缀和 - k 的历史前缀和，而不关心该历史前缀和是哪个下标的前缀和，且我们保证了umap中都是历史前缀和，因此不需要用数组存放历史前缀和，只需要用一个变量表示上一个前缀和以及用一个哈希表存放历史前缀和即可。这样还能省去下标对应的麻烦。

**:question:   problems:** 

1. 为什么先要在umap中插入(0, 1)?

:heavy_check_mark:  **answer:** 

1. 因为如果nums[0]=k, 那么单就nums[0]就是一个满足条件的子数组，cnt应加一。

    但是，在一般逻辑中，我们要想让满足条件的子数组的个数增加，就要去umap中找满足条件的下标[0,i)的前缀和，如果找不到 = `prefixSum - k == 0`的前缀和，那么cnt 就不会+1。

    因此必须要有umap[0] = 1这一步，如果没有那就少算了

### 代码

```c++
class Solution {
public:
    int subarraySum(vector<int>& nums, int k) {
        int res = 0;
        unordered_map<int, int> umap;//value表示存在几个相同的key前缀和
        // 边遍历边存前缀和到umap中
        int prefixSum = 0; //表示当前前缀和，在后面的for中边遍历边更新

        umap[0] = 1; 
        
        for (int& val : nums) {
            // 更新当前前缀和
            prefixSum += val;
            // 在umap中找是否存在`= prefixSum - k`的前缀和
            if (umap.count(prefixSum - k)) {
                res += umap[prefixSum - k]; 
            }
            umap[prefixSum]++;
        }
        return res;
    }
};
```

### 复杂度分析

- 时间复杂度：O(n)  

- 空间复杂度：O(n). 哈希map最多可能占用O(n)的空间

## [:fire: 3. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/):star::star: 

### **题意**

给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长子串** 的长度。

**示例 1:**

```
输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

**示例 2:**

```
输入: s = "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
```

**示例 3:**

```
输入: s = "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
```

**提示：**

- `0 <= s.length <= 5 * 104`
- `s` 由英文字母、数字、符号和空格组成

### 法一

==:star: **核心思路： 暴力    **:star:==

**:key:  key：**

- 遍历s，对于每一个字符s[i]，找以s[i]开头的最长无重复字符子串

​		![SmartSelect_20240119_165608_Samsung Notes](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202401191716874.jpg)

#### 代码

```c++
int lengthOfLongestSubstring(string s) {
    int n = s.size(), maxlen = 0;
    unordered_set<char> set;//记录窗口中出现的字符
    int left = 0, right = 0;
    while (right < n) {
        if (set.find(s[right]) == set.end()) { //滑窗中未出现过该值
            set.insert(s[right]); //将该值加入set中
            right++; //向右扩大窗口
        }
        else { //窗口中出现过该值，则以s[l]开头的最长无重复字符子串就是[l,r-1]
            maxlen = max(maxlen, right - left);//统计该子串长度并根据大小更新maxlen
            left++;//要开始找以s[l+1]开头的最长无重复字符子串了
            right = left;//缩小窗口至size为1
            set.clear();//清空set
        }         
    }
    return max(maxlen, right - left);//因为可能s中所有字符都不重复，此时会一直走if扩大窗口到末尾而不会走else，自然也不会更新maxlen
}
```

也可以将else和return中的更新maxlen逻辑合为一个，写在while语句中，即每一次while循环都更新一次maxlen，如下：

```c++
int lengthOfLongestSubstring(string s) {
    int n = s.size(), maxlen = 0;
    unordered_set<char> set;//记录窗口中出现的字符
    int left = 0, right = 0;
    while (right < n) {
        if (set.find(s[right]) == set.end()) { //滑窗中未出现过该值
            set.insert(s[right]); //将该值加入set中
            right++; //向右扩大窗口
        }
        else { //窗口中出现过该值，则以s[l]开头的最长无重复字符子串就是[l,r-1]
            left++;//要开始找以s[l+1]开头的最长无重复字符子串了
            right = left;//缩小窗口至size为1
            set.clear();//清空set
        }         
        maxlen = max(maxlen, right - left);
    }
    return maxlen;
}
```

#### 复杂度分析

- 时间复杂度：O(n^2^)  

- 空间复杂度：O(1)

### 法二

==:star: **核心思路： 滑动窗口   **:star:==

**:question:   problems:** 

1. 遇重时的处理逻辑是? 为什么是这样？

:heavy_check_mark:  **answer:** 

1. 设窗口中与s[right]相同的重复字符是s[m]，则需要将left不断右移直到把s[m]及其前面的所有元素移出窗口，同时将s[left]从set中删除；

    因为以[left, m]中字符开头的最长无重复字符的子串，都是最多到right - 1就结束了，也就是说，它们的长度都不会超过right-1 - left + 1 = right - left。因此我们可以直接跳过[left,m]，不用计算以它们为开头的······，窗口左端直接从m+1继续找最长的无重复字符的子串。

**:x: careless | ignore :**

- 注意遇重时的处理逻辑不能用while一步到位！因为如果这个内层的while条件不满足（比如s全是重复字符的情况），那就不会执行内存while的逻辑将字符从set中删去，导致一直都在遇重一直走else，则left一直++而right始终不动，始终<n，陷入死循环。

    而直接 set.erase[s[left++]]; 就不需要管那么多，先set中删了再说，这样就算全是重复字符，窗口内的重复字符已经从set中删掉了为空了，下一次就会走if更新right。

![SmartSelect_20240119_170320_Samsung Notes](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202401191719645.jpg)

![image-20240119175610029](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202401191756320.png)

#### 代码

```c++
int lengthOfLongestSubstring(string s) {
    int maxlen = 0;//不能初始化为1,因为0 <= s.length
    int left = 0, right = 0;
    unordered_set<char> set;
    // 每将一个字符ch移入窗口,就set.insert(s[right++])
    // 每将一个字符ch移入窗口,就set.erase(s[left++])
    // 当s[right]是窗口中出现过的字符时,让窗口左端s[left]一直右移直到将窗口内与s[right]相同的字符移出为止
    while (right < s.size()) {
        if (set.find(s[right]) == set.end()) set.insert(s[right++]);
        else 
            while (set.find(s[right]) != set.end()) set.erase(s[left++]); 
        maxlen = max(right - left, maxlen);//(right-1)-left+1 = right-left, 也可以用set.size()代替right - left
    }
    return maxlen;
} 
```

#### 复杂度分析

- 时间复杂度：O(n)  

- 空间复杂度：O(1)

## **[567. 字符串的排列](https://leetcode.cn/problems/permutation-in-string/)**

### **题意**

给你两个字符串 `s1` 和 `s2` ，写一个函数来判断 `s2` 是否包含 `s1` 的排列。如果是，返回 `true` ；否则，返回 `false` 。

换句话说，`s1` 的排列之一是 `s2` 的 **子串** 。 

**示例 1：**

```
输入：s1 = "ab" s2 = "eidbaooo"
输出：true
解释：s2 包含 s1 的排列之一 ("ba").
```

**示例 2：**

```
输入：s1= "ab" s2 = "eidboaoo"
输出：false
```

**提示：**

- `1 <= s1.length, s2.length <= 104`
- `s1` 和 `s2` 仅包含小写字母

### 代码

这题和 [438. 找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/) 一模一样，除了返回值是bool型之外

```c++
bool checkInclusion(string s1, string s2) {
    vector<int> res;
    vector<int> need(128);//存储p的字母频次
    vector<int> win(128);//存储窗口内字符的出现频次
    //也可以都用26的大小，只不过取字符时就要做-'a'映射
    for (char &c : s1) need[c]++;

    int left = 0, right = 0;
    while (right < s2.size()){
        if (win[s2[right]] < need[s2[right]]){//窗口中出现的s2[r]不够，自然要把s2[r]加进来
            win[s2[right++]]++;
            if (right - left == s1.size()) return true;
        }
        else if (win[s2[right]] == need[s2[right]]){ //窗口中出现的s2[r]已够，再把s2[r]加进来就超了
            // 让left右移至与s2[r]相同的字符的下一个位置
            while (win[s2[right]] == need[s2[right]]) win[s2[left++]]--;
            //退出循环时win[s2[right]] = need[s2[right]] - 1，此时窗口刚把=s2[r]的那个字符的频次--，left指向下一个字符
        }
        else if (need[s2[right]] == 0){ //若s2[r]本就不是p中字符，则left右移至right+1
            while (left != right) win[s2[left++]]--;
            left++; right++;
        }
    }
    return false;
}
```

## :fire:[76. 最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/)

### 题意

给你一个字符串 `s` 、一个字符串 `t` 。返回 `s` 中涵盖 `t` 所有字符的最小子串。如果 `s` 中不存在涵盖 `t` 所有字符的子串，则返回空字符串 `""` 。

**注意：**

- 对于 `t` 中重复字符，我们寻找的子字符串中该字符数量必须不少于 `t` 中该字符数量。
- 如果 `s` 中存在这样的子串，我们保证它是唯一的答案。

**示例 1：**

```
输入：s = "ADOBECODEBANC", t = "ABC"
输出："BANC"
解释：最小覆盖子串 "BANC" 包含来自字符串 t 的 'A'、'B' 和 'C'。
```

**示例 2：**

```
输入：s = "a", t = "a"
输出："a"
解释：整个字符串 s 是最小覆盖子串。
```

**示例 3:**

```
输入: s = "a", t = "aa"
输出: ""
解释: t 中两个字符 'a' 均应包含在 s 的子串中，
因此没有符合条件的子字符串，返回空字符串。
```

**提示：**

- `m == s.length`
- `n == t.length`
- `1 <= m, n <= 105`
- `s` 和 `t` 由英文字母组成

**进阶：**你能设计一个在 `o(m+n)` 时间内解决此问题的算法吗？

### 思路

==:star: **核心思路：滑动窗口   **:star:==

**:key:  key：**

- right++扩大窗口找可行解 ——> left++缩小窗口找更优解 ——> 判断该更优解是否可能是最优解并对应更新变量 ——> left++继续往后找更多可行解
- 变量的更新时机：
    - 关于left和right的更新：
        - left更新：缩小窗口找更优解时，以及，找到更优解后继续开始找下一个可行解时
        - right更新：扩大窗口时

    - 关于need数组和needCnt的更新：
        - 窗口进一个字符就need[字符]--，如果该字符是窗口需要的字符就再needCnt--；
        - 窗口出一个字符就need[字符]++，如果该字符是窗口需要的字符就再needCnt++

    - 关于start和minlen的更新：
        - 找到一个更优解时，若窗口大小<minlen，就说明该更优解可能成为最优解，因此更新minlen和start

**:question:   problems:** 

1. 怎样判断窗口已经包含了t中所有字符？
2. 缩小窗口找更优解怎么实现？

:heavy_check_mark:  **answer:** 

1. 如果我们用两个vector来判断：

    - 两个vector分别存放窗口中字符频次和t中字符频次。
    - 那么每次判断窗口是否包含t中字符就需要遍历vector判断对应t中字符的出现频次与窗口中对应字符的出现频次是否相等。

    如果只用一个vector来判断：

    - 这个vector存放········的差值，即窗口中每个t中字符还需要出现多少次。
    - 那么每次仍需要遍历这个vector判断对应t中字符的出现频次是否为0。

    如果只用一个变量needCnt来判断：

    - 这个变量表示窗口中还需要出现的t中字符的总个数

    - 那么每次只需要根据needCnt是否为0，就能直接判断窗口是否包含了t中的所有字符。

        > :question: :question::question:  **为什么能直接根据needCnt判断窗口是否已经包含了t中的所有字符？**
        >
        > - 只有在窗口进来需要的字符（**need[字符]>0）**时才会让needCnt--，如果need[字符]<=0就不会让needCnt--，因此不会误判。每次让needCnt--的字符都一定是窗口还需要的t中字符。

2. 如果need[s[left]] < 0就一直缩小窗口，直到遇到必须包含的字母。因为：

    窗口每进一个字符就会need[字符]--，need[s[left]]<0就说明s[left]是窗口本不需要包含的字符（包括本就不属于t、属于t但所需个数多余了的字符），就可以直接跳过。

**:small_red_triangle_down:  steps: **

1.  right不断右移直到窗口包含所有t中的字母，找到一个可行解
2.  left++不断右移缩小窗口直到遇到必须包含的字母，找到一个最优解
3.  找到一个更优解之后，判断该更优解是否可能是最优解。若窗口大小<minlen，就说明该更优解可能成为最优解，更新与结果相关的变量
4.  left右移找下一个可行解。重复执行上述步骤直至s末尾。

 🎈  **收获： ** 

- 不要吝啬使用变量，有时候这是必要的！就算不是必要的，前期也可以尽量简化实现把题目AC了再说（这样至少能知道自己的大致思路是否正确，防止思路细节一把抓搞得脑子乱），再去优化

### 代码

#### 无注释版

```c++
class Solution {
public:
    string minWindow(string s, string t) {
        vector<int> need(128);
        for (auto& c : t) {
            need[c]++; 
        }
        int start = 0;
        int minlen = INT_MAX; 
        int needCnt = t.size(); 
        for (int left = 0, right = 0; right < s.size(); ++right) {
            char curChar = s[right];
            if (need[curChar]-- > 0) {  
                needCnt--;
            }        
            if (needCnt == 0) {  
                while (need[s[left]] < 0) {
                    need[s[left++]]++; 
                }
                int windowLen = right - left + 1; 
                if (windowLen < minlen) { 
                    minlen = windowLen;
                    start = left;
                }
                need[s[left++]]++;
                needCnt++;
            }
        }
        return minlen == INT_MAX ? "" : s.substr(start, minlen);
    }
};
```

也可以写成

```c++
class Solution {
public:
    string minWindow(string s, string t) {
        vector<int> need(128);
        for (auto& c : t) {
            need[c]++; 
        }
        int start = 0;
        int minlen = INT_MAX; 
        int needCnt = t.size(); 

        for (int left = 0, right = 0; right < s.size(); ++right) {
            char curChar = s[right];
            if (need[curChar]-- > 0) {  
                needCnt--;
                if (needCnt == 0) {  
                    while (need[s[left]] < 0) {
                        need[s[left++]]++; 
                    }
                    int windowLen = right - left + 1; 
                    if (windowLen < minlen) { 
                        minlen = windowLen;
                        start = left;
                    }
                    need[s[left++]]++;
                    needCnt++;
                }
            }   
        }
        return minlen == INT_MAX ? "" : s.substr(start, minlen);
    }
};
```

#### 带注释版

```c++
class Solution {
public: 
    string minWindow(string s, string t) {
        vector<int> need(128);
        for (auto& c : t) {
            need[c]++; 
        }
        int start = 0;
        int minlen = INT_MAX; 
        int needCnt = t.size(); 
        for (int left = 0, right = 0; right < s.size(); ++right) {
            char curChar = s[right];
            // 如果当前字符是窗口还需要的 
            if (need[curChar]-- > 0) {  
                needCnt--;
            }
            // needCnt == 0说明窗口包含了所有t中字符，找到了一个可行解
            if (needCnt == 0) {  
                // left++缩小窗口直到遇到必须包含的字母(求最优解)
                while (need[s[left]] < 0) {
                    need[s[left++]]++; 
                }
                // 比较看是否需要更新结果
                int windowLen = right - left + 1; 
                if (windowLen < minlen) { 
                    minlen = windowLen;
                    start = left;
                }
                // left++缩小窗口开始找下一个可行解
                need[s[left++]]++;
                // 因为缩小窗口前, s[left]一定是窗口需要包含的字母，因此needCnt也要记得++
                needCnt++;
            }
        }
        return minlen == INT_MAX ? "" : s.substr(start, minlen);
    }
};
```

### 复杂度分析

- 时间复杂度：O(n)  

- 空间复杂度：O(1)

## [424. 替换后的最长重复字符](https://leetcode.cn/problems/longest-repeating-character-replacement/):star::star:

### **题意**

给你一个字符串 `s` 和一个整数 `k` 。你可以选择字符串中的任一字符，并将其更改为任何其他大写英文字符。该操作最多可执行 `k` 次。

在执行上述操作后，返回 *包含相同字母的最长子字符串的长度。*

**示例 1：**

```
输入：s = "ABAB", k = 2
输出：4
解释：用两个'A'替换为两个'B',反之亦然。
```

**示例 2：**

```
输入：s = "AABABBA", k = 1
输出：4
解释：
将中间的一个'A'替换为'B',字符串变为 "AABBBBA"。
子串 "BBBB" 有最长重复字母, 答案为 4。
可能存在其他的方法来得到同样的结果。
```

**提示：**

- `1 <= s.length <= 105`
- `s` 仅由大写英文字母组成
- `0 <= k <= s.length`

### 参考题解

1. [wei神🐂！](https://leetcode.cn/problems/longest-repeating-character-replacement/solutions/586648/ti-huan-hou-de-zui-chang-zhong-fu-zi-fu-eaacp)

### 思路

==:star: **核心思路： 滑动窗口   **:star:==

首先考虑暴力解法：列举s的所有子串，找到  能通过k次替换后，包含相同字符的最长子串。

暴解优化：

1. 如果已经得到了长度为L的子串，则接下来只用找是否存在 满足条件的、长度更长的子串，长度<=L的所有子串就都没有必要考虑。

    > 因此窗口不会缩小，只会扩大（right++）或者不变（left++同时right++，窗口滑动前进）。

2. 长度为L的子串如果不满足条件，则左边界相同的、长度更长的子串也一定不会满足

    > :question::question::question:
    >
    > 设这个不满足条件的原长度为L的子串，其最高频字符'A'出现频次为x，其余'B'出现 y 次，'C'出现 z 次，因此就有`x>y, x>z`。又因为该子串不满足条件（k次替换替换不完非最高频字符），因此 `(y+z)>k`。
    > 接下来左边界相同的、长度更长的子串有两种情况：
    >
    > 1. 若原最高频字符'A'还是最高频字符：
    >     - 则'B'和'C'还是需要替换掉，但由于(y+z)>k，还是替换不完，仍不满足条件
    > 2. 若原非最高频字符'B'或'C'超过了'A'变成了最高频字符：
    >     - 假设是'B'变成了最高频字符，则 `y'>x, y'>z`。要替换'A'和'C'，有`(x+z)`个字符需要替换。由于x>y且(y+z)>k，因此`(x+z)>(y+z)>k`，还是替换不完，仍不满足条件

**:key:  key：**

- left和right的更新时机：
    - left更新：当窗口不满足条件时，
        - 由于我们前面说的`长度为L的子串如果不满足条件，则左边界相同的、长度更长的子串也一定不会满足`，因此以该左边界为起点的所有子串都不用再找了，直接从下一起点left+1开始找。
        - 同时，由于我们前面说的`如果已经得到了长度为L的子串，则接下来只用找是否存在 满足条件的、长度更长的子串，长度<=L的所有子串就都没有必要考虑`，因此窗口不会缩小。我们在left++的同时right++，就维持了窗口大小不变，相当于窗口滑动前进。
    - right更新：找是否有满足条件的**更长**子串时，扩大窗口。

**:question:   problems:** 

1. 子串什么时候不满足条件?
2. 怎么维护窗口的最大频次？

:heavy_check_mark:  **answer:** 

1. 当k次替换替换不完非最高频字符（len - maxCnt）时

2. 一开始想的是用multimap<int, cnt> map;维护字符出现频次（升序）以及对应字符，但其实没必要。只需要用一个变量maxCnt维护最高频字符的频次就行，没必要维护对应字符。

    因为只有在窗口进来字符时，最高频字符的频次才可能变化，因此直接将更新maxCnt的逻辑写在right++窗口移入字符的后面即可。

**:small_red_triangle_down: steps: **

1.  先right++扩大窗口（同时要更新maxCnt）直到窗口不满足条件（len - maxCnt > k）
2.  left++同时right++窗口平移滑动
3.  更新res
4.  继续重复上述步骤

### 代码

```c++
int characterReplacement(string s, int k) {
    int maxlen = 0, maxCnt = 1;//maxCnt维护最高频字符的频次
    vector<int> win(128);
    int left = 0, right = 0;
    while (right < s.size()) {
        win[s[right]]++;
        maxCnt = max(maxCnt, win[s[right]]);
        if (right - left + 1 - maxCnt > k) win[s[left++]]--;
        maxlen = max(maxlen, right - left + 1);
        right++;
    }
    return maxlen;//也可以直接返回right-1 - left + 1 即right-left
}
```

### 复杂度分析

- 时间复杂度：O(n)  

- 空间复杂度：O(1)

## :fire:[438. 找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/)

### 题意

给定两个字符串 `s` 和 `p`，找到 `s` 中所有 `p` 的 **异位词** 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。

**异位词** 指由相同字母重排列形成的字符串（包括相同的字符串）。

**示例 1:**

```
输入: s = "cbaebabacd", p = "abc"
输出: [0,6]
解释:
起始索引等于 0 的子串是 "cba", 它是 "abc" 的异位词。
起始索引等于 6 的子串是 "bac", 它是 "abc" 的异位词。
```

 **示例 2:**

```
输入: s = "abab", p = "ab"
输出: [0,1,2]
解释:
起始索引等于 0 的子串是 "ab", 它是 "ab" 的异位词。
起始索引等于 1 的子串是 "ba", 它是 "ab" 的异位词。
起始索引等于 2 的子串是 "ab", 它是 "ab" 的异位词。
```

**提示:**

- `1 <= s.length, p.length <= 3 * 104`
- `s` 和 `p` 仅包含小写字母



> 该题和:fire:[76. 最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/)的区别在于：
>
> - 76 找的是 s 中包含 t 的最短子串，子串可以有其它字符
> - 438 找的是 s 中所有 t 的异位词子串，子串不可以有其它字符
>
> 因此 438 就不能和 76 一样，用needCnt来判断窗口是否满足条件了。因为：
>
> - needCnt只和窗口需要的字符相关，如果窗口进来了不需要的字符，不会影响到needCnt，因此needCnt==0时窗口可能存在着窗口不需要的字符，也就是说，如果438这题也用needCnt来判断窗口是否满足条件，则无法保证窗口只包含所需要的 t 中字符。
>
> 我们可以用一个vector来判断（存放差值，窗口中每个t中字符还需要出现多少次），由于窗口中始终只会有需要的t中字符，因此这样判断窗口大小是否为t.size()就能知道窗口是否满足条件。———— 思路1
>
> 当然也可以用两个数组need，win判断（分别存放t的字母频次，窗口内字符的出现频次）。———— 思路2

### 思路1

==:star: **核心思路：滑动窗口 **:star:==

![image-20240403203227528](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202404032032621.png)

**:question:   problems:** 

1. 什么时候收缩窗口？

:heavy_check_mark:  **answer:** 

1. 当遇到不需要的字符时，即need[s[right]]--后<0，就说明s[right]是不需要的字符

**:small_red_triangle_down:  steps: **

1.  统计 p 中字符出现频次作为need数组。

2. 左右双指针初始化，开始向右滑动窗口。

    - 如果s[right]是不需要的字符，那就收缩左侧边界。收缩到什么时候呢？分两种情况：

        1. 若s[right]是多了的，此时需要left++收缩窗口直到将窗口中第一个=s[right]的值移出窗口

        2. 若窗口原本就不需要s[right]，可以有两种处理方式：

            - 可以将left直接移到right+1，窗口大小直接缩为0，然后将need中元素重新初始化为p中字符出现频次。

                > 是这样写会平添麻烦。
                >
                > 因为如果将left直接移到right+1，则`s[right]是多了的`和`窗口原本就不需要s[right]`这两种情况就不能合并，要分开写处理逻辑，那也就需要逻辑判断属于哪一种情况，然后进入各自的处理逻辑，对于`窗口原本就不需要s[right]`这种情况，我们就需要判断s[right]是否存在p串中，那就需要O(n)的空间存放p中字符出现频次，设用pCnt数组存放，且每次还需要让need初始化为pCnt。

            - 也可以复用第一种情况的循环让left++收缩窗口直到窗口大小缩为0

    - 窗口长度与p长度一致时达成条件 

#### 代码

```c++
class Solution {
public:
    vector<int> findAnagrams(string s, string t) {
        vector<int> res;
        vector<int> need(128);  //存放窗口中还需要的t中字符数
        for (auto ch : t) {
            need[ch]++;
        }
        int start = 0;
        for (int left = 0, right = 0; right < s.size(); ++right) {
            need[s[right]]--;
            // 1.遇到还需要的字符：直接need[s[right]]--;后判断窗口是否满足条件就完了
            // 2.1 遇到多余的字符：缩小窗口直到把与多余字符s[right]相同的第一个字符移出窗口（移出后need[s[right]]=0）
            // 2.2 遇到根本不需要的字符：窗口缩为0
            
            // 2的两种情况可以合并：
            while (need[s[right]] < 0) {
                need[s[left++]]++;
            }
            // 判断窗口是否满足条件
            if (right - left + 1 == t.size()) {
                res.emplace_back(left);
            }
        }
        return res;
    }
};
```

不应该写成如下代码：(这样写就是 不合并两种情况的处理逻辑，而是分开处理)

```cpp
vector<int> findAnagrams(string s, string p) {
    int s_len = s.size();
    int p_len = p.size();
    if(s_len < p_len) return {};
    vector<int> need(26);
    vector<int> pCnt(26); //用p中字符出现频次初始化之后就不会再变
    for(auto ch : p) {
        ++need[ch - 'a']; 
        ++pCnt[ch - 'a']; 
    }
    vector<int> ans;
    for(int left = 0, right = 0; right < s_len; ++right) {
        need[s[right] - 'a']--;
        // 如果s[right]是不需要的字符，那就收缩左侧边界。
        if (need[s[right] - 'a'] < 0) {
            // 不合并两种情况的处理逻辑, 如下:
            if (pCnt[s[right] - 'a'] == 0) {
                // (1) 窗口原本就不需要s[right]，
                // 将left直接移到right+1，窗口大小直接缩为0，然后将need中元素重新初始化
                left = right + 1;
                need = pCnt;
            }
            else {
                // (2) s[right]是多了的，
                // left++收缩窗口直到将窗口中第一个=s[right]的值移出窗口
                while(need[s[right] - 'a'] < 0) {
                    ++need[s[left] - 'a'];
                    ++left;
                }
            }
        }
        if(right - left + 1 == p_len) {
            ans.emplace_back(left);
        }
    }
    return ans;
}
```

### 思路2

==:star: **核心思路：滑动窗口   **:star:==

> 碎碎念...
>
> 起初自己的思路是正确的，但是当时没想清楚在到底用什么数据结构实现、用一个还是两个结构实现，在具体实现上遇了bug，以为是自己哪里想错了。
>
> 之后看了几小时别人的题解:crying_cat_face:，学到了一些解法但是都没找到我想要的，最后在讨论区发现一个很多人都说很精妙的解法于是就去研究，感觉和我的思路差不多，但是他这样子就写的很难理解。。明明没必要搞成这样啊。
>
> 在看题解的过程中我差不多明白了我这种思路 选择什么数据结构、几个数据结构最好懂，于是开干！
>
> 先把自己思路再捋顺一下然后重新开写，很快啊，啪的一下，一次AC！！击败99.58%！我又开心了芜湖~。

**:key:  key：**

- 用两个数组need，win分别存放 p的字母频次，窗口内字符的出现频次。

- 对于即将移入窗口的s[r]，有几种情况：窗口还需要s[r]、窗口不需要s[r]。其中，窗口不需要s[r]又分为两种情况：

    - t 中存在s[r]，再把s[r]加进来就超出需要了

    - t 中不存在s[r]，因此窗口根本就不能包含s[r]，本要构成异位词的窗口被打断

- 对于这三种情况，分别对应的处理逻辑是：

    1. 窗口还需要s[r]，自然要把s[r]加进来：
        - 将 s[r] 在窗口中还需要出现的频次 --，然后 r++ 将其移入窗口。
        - 如果此时窗口大小==p.size()就可以直接存结果了
    2. 窗口中出现的s[r]已够：
        - left不断右移至与窗口中与s[r]相同的第一个字符的下一个位置，同时s[left]在窗口中还需要出现的频次++
    3. s[r]本就不是 t 中字符：
        - 清空 存放 窗口中字符出现频次 的vector
        - left直接移至right+1，right++ 和left指向同一位置

    > 是不是似曾相识哈哈哈！[3. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)

**:question:   problems:** 

1. 为什么第一种情况，窗口大小==t.size()就可以直接存结果?
2. 为什么情况2 可以这样处理？

:heavy_check_mark:  **answer:** 

1. 因为执行该次循环前，窗口大小都到t.size()-1了。如果中间有出现 t 中不存在的字符 或者 出现次数超过的字符，那么窗口马上就会因为left右移被缩小，不可能还让窗口到t.size()-1的大小（当然前提不要忘了，s[r]是处于第一种情况，即该次循环s[r]仍是被需要的字符）
2. 因为：设与s[r]相同的第一个字符是s[m]，从left到m这中间的所有字符肯定是无法构成异位词了，因为窗口长度还不够t.size()就被多出来的s[r]打断了，因此[left,m]都可以直接跳过。情况3 也是差不多意思。

#### 代码

##### 无注释版

```c++
vector<int> findAnagrams(string s, string p) {
    vector<int> res;
    vector<int> need(128);
    vector<int> win(128);
    for (char &c : p) need[c]++;

    int left = 0, right = 0;
    while (right < s.size()){
        if (win[s[right]] < need[s[right]]){
            win[s[right++]]++;
            if (right - left == p.size()) res.push_back(left);
        }
        else if (win[s[right]] == need[s[right]]){
            while (win[s[right]] == need[s[right]]) win[s[left++]]--;
        }
        else if (need[s[right]] == 0){
            win.clear();
            left = right + 1; right++;
        }
    }
    return res;
}
```

##### 带注释版

```c++
vector<int> findAnagrams(string s, string p) {
    vector<int> res;
    vector<int> need(128);//存储p的字母频次
    vector<int> win(128);//存储窗口内字符的出现频次
    //也可以都用26的大小，只不过取字符时就要做-'a'映射
    for (char &c : p) need[c]++;

    int left = 0, right = 0;
    while (right < s.size()){
        if (win[s[right]] < need[s[right]]){//窗口中出现的s[r]不够，自然要把s[r]加进来
            win[s[right++]]++;
            if (right - left == p.size()) res.push_back(left);
            // 想清楚为什么窗口大小==p.size()就可以直接存结果？
        }
        else if (win[s[right]] == need[s[right]]){ //窗口中出现的s[r]已够，再把s[r]加进来就超了
            // 让left右移至与s[r]相同的字符的下一个位置
            while (win[s[right]] == need[s[right]]) win[s[left++]]--;
            //退出循环时win[s[right]] = need[s[right]] - 1，此时窗口刚把=s[r]的那个字符的频次--，left指向下一个字符
        }
        else if (need[s[right]] == 0){ //若s[r]本就不是p中字符，则left右移至right+1
            //可以加个优化，若right==n-1，此时就可以直接return res;而不用在继续往后遍历了
            while (left != right) win[s[left++]]--;
            left++; right++;
        }
    }
    return res;
}
```

### 复杂度分析

- 时间复杂度：O(n). 时间复杂度主要是看每一个元素被操作的次数，每个字符都最多只会进窗口一次，出窗口一次。每个元素都是被操作两次，所以时间复杂度是 2 × n 也就是O(n)。

- 空间复杂度：O(1). 26是常数
