## 目录

[TOC]



## 💛总结

- 设计链表--插删查
- 虚拟头结点
- 双指针
- 反转链表
- 环

## :car:[707. 设计链表](https://leetcode.cn/problems/design-linked-list/)

```c++
class MyLinkedList {
public:
    struct Listnode { //定义链表结点结构体
        int val;
        Listnode* next;
        //三个构造函数
        Listnode(): val(0), next(nullptr) {}
        Listnode(int x): val(x), next(nullptr) {}
        Listnode(int x, Listnode* p): val(x), next(p) {}
    };
    int len;//链表长度
    Listnode* dummyhead;////虚拟头结点
        
    MyLinkedList() {
        len = 0;
        dummyhead = new Listnode(0);//实例化虚拟头结点
    }
    
    int get(int index) {
        if (index > len - 1 || index < 0)  return -1;//下标无效
        //下面就是下标有效的情况
        Listnode* p = dummyhead->next;
        //从下标为0的dummmyhead->next到下标为index的节点需要p = p->next index次
        while (index--) p = p->next;//计数从index到1共index次
        return p->val;
    }
    
    void addAtHead(int val) {
        Listnode* head = new Listnode(val);
        head->next = dummyhead->next;//新头结点接管旧头结点以及其后所有
        dummyhead->next = head;
        ++len;
    }
    
    void addAtTail(int val) {
        Listnode* p = dummyhead;//用于遍历
        Listnode* end = new Listnode(val);
        while (p->next) p = p->next;
        p->next = end;
        ++len;
    }
    
    void addAtIndex(int index, int val) {
        if (index > len || index < 0) return;//越界
        Listnode* ins = new Listnode(val);
        Listnode* p = dummyhead;//用于遍历
        while (index--) p = p->next;//操作index次, p从dummyhead(-1)指到下标为index-1的节点
        ins->next = p->next;
        p->next = ins;
        ++len;
    }
    
    void deleteAtIndex(int index) {
        if (index > len - 1 || index < 0)  return;//下标无效
        Listnode* p = dummyhead;//遍历
        while (index--) p = p->next;//操作index次, p从dummyhead(-1)指到下标为index-1的节点
        Listnode* tmp = p->next;
        p->next = p->next->next;
        delete tmp;
        tmp = nullptr;//delete后记得置空
        --len;
    }
};
```

## :fire:[206. 反转链表](https://leetcode.cn/problems/reverse-linked-list/)   

### 题意

给你单链表的头节点 `head` , 请你反转链表, 并返回反转后的链表。

**示例 1：**

![img](https://cdn.jsdelivr.net/gh/rangbiubiu/picBed@main/202402081313999.jpeg)

```
输入：head = [1,2,3,4,5]
输出：[5,4,3,2,1]
```

### 迭代

```c++
ListNode* reverseList(ListNode* head) {
    // tmp = 要反转的结点cur的next; 然后反转cur; 之后cur = tmp, 重复上述步骤
    ListNode* pre = nullptr; 
    ListNode* cur = head;
    while (cur) {
        ListNode* tmp = cur->next;
        cur->next = pre;
        pre = cur;
        cur = tmp;
    }
    return pre;
}
```

复杂度分析

- 时间复杂度：O(n)  

- 空间复杂度：O(1)

### 递归

```c++
ListNode* reverse(ListNode* cur, ListNode* pre) {
    // 2.递归结束的条件
    if (cur == nullptr) return pre;
    // 3.单层递归的逻辑：
    // 暂存要反转的结点的next为tmp，然后反转一个结点，反转后该节点变为pre，tmp变为cur
    ListNode* tmp = cur->next;
    cur->next = pre; 
    // pre = cur;
    // cur = tmp;
    // return reverse(cur, pre);
    //上面三步可以直接合为一步
    return reverse(tmp, cur);
}
ListNode* reverseList(ListNode* head) {
    return reverse(head, nullptr);
}
```

**复杂度分析**

- 时间复杂度：O(n)  

- 空间复杂度：O(n)

## :fire:[92. 反转链表 II](https://leetcode.cn/problems/reverse-linked-list-ii/)

### 题意

给你单链表的头指针 `head` 和两个整数 `left` 和 `right` ，其中 `left <= right` 。请你反转从位置 `left` 到位置 `right` 的链表节点，返回 **反转后的链表** 。

**示例 1：**

![img](https://cdn.jsdelivr.net/gh/rangbiubiu/picBed@main/202405161310118.jpeg)

```
输入：head = [1,2,3,4,5], left = 2, right = 4
输出：[1,4,3,2,5]
```

**示例 2：**

```
输入：head = [5], left = 1, right = 1
输出：[5]
```

**提示：**

- 链表中节点数目为 `n`
- `1 <= n <= 500`
- `-500 <= Node.val <= 500`
- `1 <= left <= right <= n`

**进阶：** 你可以使用一趟扫描完成反转吗？

### 法一

**:key:  key：**

- 需要虚拟头节点。因为我们用frontLast->next表示开始反转的第一个节点，如果开始反转的结点是head结点，那么frontLast->next就是head，不加虚拟头节点的话，frontLast怎么表示呢？
- 最后一步接上去的时候! 不能先改变frontLast的next! 否则我们想要的原来的frontLast->next就丢失了!

**:small_red_triangle_down:  steps: **

1.  让两个指针走到反转区间的两端
2.  反转链表
3.  将反转部分接上

代码

```cpp
ListNode* reverseBetween(ListNode* head, int left, int right) {
/*
    frontEnd -> [i->···->j] -> backStart
    frontEnd -> [j->···->i] -> backStart
    用cur和prev反转结点，当cur==backStart时，停止反转，然后将反转区间接回去: frontEnd->next后面要接backStart，frontEnd后面要接prev 
*/ 
    ListNode* dummyhead = new ListNode(0, head);
    // 1. 找到frontEnd和backStart的位置
    ListNode* frontEnd = dummyhead; //处在下标0的位置
    // 下标从0走到left-1，定位到反转区间的前一个结点(frontEnd)
    for (int i = 0; i < left - 1; ++i) {
        frontEnd = frontEnd->next;
    }
    ListNode* backStart = frontEnd; 
    // 继续走一直走到下标right+1，定位到反转区间的下一个结点(backStart)
    // 因为前面循环的i是局部变量，因此这里for表达式中仍需要重新定义
    for (int i = left - 1; i < right + 1; ++i) {
        backStart = backStart->next;
    } 
    // 2. 反转区间 
    ListNode* prev = reverse(frontEnd->next, nullptr, backStart);
    //3. 将反转部分接上 (这两行的顺序不能变)
    frontEnd->next->next = backStart;
    frontEnd->next = prev; 
    
    ListNode* ans = dummyhead->next; 
    delete dummyhead;
    dummyhead = nullptr;
    return ans;
}
ListNode* reverse(ListNode* cur, ListNode* prev, ListNode* backStart) {
    if (cur == backStart) {
        return prev;
    }
    ListNode* tmp = cur->next;
    cur->next = prev;
    return reverse(tmp, cur, backStart);
}
```

**复杂度分析**

- 时间复杂度：O(n). 两次遍历  

- 空间复杂度：O(1)

### 法二（进阶, 一趟扫描）

==:star: **核心思路：头插法  **==  

反转逻辑：每次循环，head逐步后移（head->next逐步前移），改变对应的next并更新指针。

相当于把head->next头插到虚拟头节点pre的后面。

```cpp
ListNode* reverseBetween(ListNode* head, int left, int right) {
    ListNode* dummyhead = new ListNode(0, head);
    ListNode* pre = dummyhead;
    // 下标从0走到left-1，定位到反转区间的前一个结点
    for (int i = 0; i < left - 1; ++i) {
        pre = pre->next;
    }
    head = pre->next; //开始反转的第一个节点 2
    // pre和head的指向固定不变，始终指向反转区间的前一个结点 和 开始反转的第一个节点，以示例1[1,2,3,4,5]为例，pre和head始终指向1和2.
    // 边走边反转（这样才满足一趟扫描），反转的过程其实就是head逐步后移（head->next逐步前移），改变对应的next并更新指针。
    // 相当于每次把head->next头插到虚拟头节点pre的后面
    for (int i = left; i < right; ++i) {
        ListNode* tmp = head->next; //3
        head->next = tmp->next;//2->4 head后移
        tmp->next = pre->next; //3->2 头插，head->next前移
        pre->next = tmp;
    }
    return dummyhead->next;
}
```



**复杂度分析**

- 时间复杂度：O(n). 一次遍历  

- 空间复杂度：O(1)

## :fire:[25. K 个一组翻转链表](https://leetcode.cn/problems/reverse-nodes-in-k-group/)

### 题意



[常见的链表翻转，字节跳动加了个条件，面试者高呼「我太难了」| 图解算法 (qq.com)](https://mp.weixin.qq.com/s?__biz=MzIxNjc0ODExMA%3D%3D&chksm=9785150ea0f29c18526d17cefccce47720e8942cb2c96d9b0cd22544385ec17c50073326d9f4&idx=1&mid=2247486511&scene=21&sn=26d1ca6342a05dea1cb885da7a4c5ddc#wechat_redirect)

==:star: **核心思路： 双指针  **:star:==



### 代码

```cpp
```



## [:fire: 141. 环形链表](https://leetcode.cn/problems/linked-list-cycle/)

### 题意

给你一个链表的头节点 `head` , 判断链表中是否有环。存在返回 `true` 。 否则返回 `false` 。

 提示：链表中节点的数目范围是 `[0, 104]`

==:star: **核心思路： 双指针  **:star:==

注意：

1. 链表的题要注意开头都要特判！！！
2. 循环条件. 第n次把循环条件写成`while (slow != fast && fast->next && fast)`了...

### 代码

```c++
bool hasCycle(ListNode *head) {
    // 链表的题要注意开头都要特判！！！
    if (!head || !head->next) return false;
    ListNode *slow = head, *fast = head; 
    //芙拉! 一开始slow就==fast, 循环条件怎么能是slow != fast啊！！！
    //while (slow != fast && fast->next && fast) 或者写成 while (slow && fast->next) 都是错误的
    while (fast && fast->next) {
        slow = slow->next;
        fast = fast->next->next;
        if (slow == fast) return true;
    }
    return false;
}
```

### 复杂度分析

- 时间复杂度：O(n)  

- 空间复杂度：O(1)

## [:fire: 142. 环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/)

### 题意

给定一个链表的头节点  `head` , **返回链表开始入环的第一个节点**。 *如果链表无环, 则返回 `null`。*

### 法一

哈希

**代码**

```c++
 ListNode *detectCycle(ListNode *head) {
    // 法一、用哈希存放遍历过的结点, 当遍历到哈希中存在的结点时就说明有环
    unordered_set<ListNode*> visited;
    while (head != nullptr) {
        if (visited.count(head)) return head;
        visited.insert(head);
        head = head->next;
    }
    return nullptr;
 }
```

### 法二

==:star: **核心思路： 双指针  **:star:==

**:question:   problems:** 

1. 怎样判断是否成环？ 
2. 怎样找到入环的第一个结点？

:heavy_check_mark:  **answer:** 

![SmartSelect_20240126_225643_Samsung Notes](https://cdn.jsdelivr.net/gh/rangbiubiu/picBed@main/202402091057729.jpeg)

### 代码

```c++
ListNode *detectCycle(ListNode *head) {
/*
    先用快慢双指针判断链表是否有环，
    如果有环，那么再接着找环入口：
    设链头走x步到环入口，快慢双指针相遇在A点，从环入口到A点需要走y步，一圈为y+z步
    相遇时，慢指针走了x+y+T1圈，快指针走了x+y+T2圈，它俩走的步数是两倍关系
    2(x+y+T1圈) = x+y+T2圈 => x+y=(T2-2T1)圈，x+y=n(y+z), x+y=(n-1)(y+z)+(y+z), x=(n-1)(y+z)+z, x=(n-1)圈+z，也就是说，走x步相当于走N圈+z步
    因此如果让两个指针，分别从链头和相遇点A开始走，它们相遇的点就是环入口（由于x=(n-1)圈+z，它俩各自走了 x 和 (n-1)圈+z 步时就会相遇）
*/
    ListNode* slow = head;
    ListNode* fast = head;
    //因为一开始slow就==fast，因此不能写成while (slow != fast && fast->next && fast) 
    while (fast && fast->next) {
        slow = slow->next;
        fast = fast->next->next;
        if (slow == fast) {
            ListNode* p = head;
            while (p != slow) {
                p = p->next;
                slow = slow->next;
            }
            return p;
        }
    }
    return nullptr;
}
```

为什么找环入口的逻辑必须写while里？不能写在外面？

如果写在外面则是：

```cpp
ListNode *detectCycle(ListNode *head) {
    ListNode* slow = head;
    ListNode* fast = head;
    while (fast && fast->next) {
        slow = slow->next;
        fast = fast->next->next;
        if (slow == fast) break;
    }
    if (slow != fast) {
        return nullptr;
    }
    ListNode* p = head;
    while (p != slow) {
        p = p->next;
        slow = slow->next;
    }
    return p;
}
```

那么当head =[1]，无环时，不会进while循环，因此slow和fast仍为初始值，它俩相等，不会返回nullptr。而本来无环是应该返回nullptr的。



##  :fire:[146. LRU 缓存](https://leetcode.cn/problems/lru-cache/)

### 题意

请你设计并实现一个满足 [LRU (最近最少使用) 缓存](https://baike.baidu.com/item/LRU) 约束的数据结构。

实现 `LRUCache` 类：

- `LRUCache(int capacity)` 以 **正整数** 作为容量 `capacity` 初始化 LRU 缓存
- `int get(int key)` 如果关键字 `key` 存在于缓存中, 则返回关键字的值, 否则返回 `-1` 。
- `void put(int key, int value)` 如果关键字 `key` 已经存在, 则变更其数据值 `value` ；如果不存在, 则向缓存中插入该组 `key-value` 。如果插入操作导致关键字数量超过 `capacity` , 则应该 **逐出** 最久未使用的关键字。

函数 `get` 和 `put` 必须以 `O(1)` 的平均时间复杂度运行。

**示例：**

```
输入
["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"]
[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]
输出
[null, null, null, 1, null, -1, null, -1, 3, 4]

解释
LRUCache lRUCache = new LRUCache(2);
lRUCache.put(1, 1); // 缓存是 {1=1}
lRUCache.put(2, 2); // 缓存是 {1=1, 2=2}
lRUCache.get(1);    // 返回 1
lRUCache.put(3, 3); // 该操作会使得关键字 2 作废, 缓存是 {1=1, 3=3}
lRUCache.get(2);    // 返回 -1 (未找到)
lRUCache.put(4, 4); // 该操作会使得关键字 1 作废, 缓存是 {4=4, 3=3}
lRUCache.get(1);    // 返回 -1 (未找到)
lRUCache.get(3);    // 返回 3
lRUCache.get(4);    // 返回 4
```

**提示：**

- `1 <= capacity <= 3000`
- `0 <= key <= 10000`
- `0 <= value <= 105`
- 最多调用 `2 * 105` 次 `get` 和 `put`

### 参考题解

1. [【字节一面】 LRU Cache 实现剖析]( https://www.bilibili.com/video/BV1hp4y1x7MH/?share_source=copy_web&vd_source=8086e0fb4ccc0ee9410370076867092c)
1. [官解](https://leetcode.cn/problems/lru-cache/solutions/259678/lruhuan-cun-ji-zhi-by-leetcode-solution)

### 思路

==:star: **核心思路：哈希表 + 双向链表**:star:==

#### 1. 确定选用什么数据结构

- 由题，LRUCache维护一个cap容量，如果添加元素后size>cap，就需要逐出最久未使用的元素；且LRUCache有两个时间复杂度为O(1)的成员函数：get()和put()
    - get()的逻辑是：
        - 根据key获取value，这个操作要想时间复杂度为O(1)，那么就需要用到unordered_map
        - 另外，如果key存在于缓存中，那么get(key)之后，key就变为了最近使用的关键字。
    - put()的逻辑是：
        - 如果key存在，改变其value，然后将key变为最近使用的；
        - 否则，向缓存中插入key-value，然后将key变为最近使用的，如果put后LRUCache的size>cap，那么就需要将最久未使用的关键字逐出。
- 从这两个函数的逻辑我们就可以知道缓存应该选用什么结构了：
    - 除了要能快速根据键获取value之外，缓存选用的结构要能够体现关键字是最近使用还是最久未使用，因为我们需要在get以及put后，将操作的关键字变为最近使用的，以及如果put后LRUCache的size>cap，那就需要将最久未使用的关键字逐出。因此，关键字还需要按序组织，这个顺序就是从 最近使用 到 最久未使用。
    - 考虑到插入删除所需的时间复杂度，我们选用链表而不是数组。
    - 那用单向链表还是双向循环链表？双向循环链表！因为我们不仅需要操作最近使用的关键字，还需要操作最久未使用的关键字。也就是说，链表的头尾操作都需要是O(1)的时间复杂度。
    - 结合前面说的unordered_map，我们就能确定LRUCache选用的结构是unordered_map+双向循环链表，这样LRUCache查找插入删除的时间复杂度都是O(1)。
    - 这两个结构怎么联系起来呢？unordered_map的键值分别是关键字key和其对应在链表中的结点。双向循环链表每个结点存放了关键字key和它的value。

![image-20240211084944957](https://cdn.jsdelivr.net/gh/rangbiubiu/picBed@main/202402110849032.png)

#### 2. get和put的具体实现

确定了LRUCache选用的结构，我们再详细梳理一下get()和put()的逻辑。

- get的逻辑是：
    - 根据key从哈希map中获取key对应在链表中的结点。
    - 如果key存在于map中，则还需要将key变为最近使用的关键字（将原来key对应在链表中的结点删除，再重新new一个结点头插到链表，注意需要同步在map中删除添加）。
        - 为啥“将key变为最近使用的关键字”，需要同步把key从map中删除再添加？只操作链表不可以吗？
        - 不可以！因为如果只把key对应在链表中的结点删除，那么此时map[key]指向哪呢？
- put的逻辑是：

    - 如果key存在于哈希map，将其对应结点从链表中删除，**同时要在哈希map删除键值对**，然后用key和新的value重新new一个结点头插到链表，**同时要在哈希map添加键值对**。

    - 否则，将key-value头插到链表中，同时要在哈希map添加键值对，如果put后LRUCache的size>cap，那么就需要将最久未使用的关键字逐出，同时要在哈希map删除键值对。

#### 注意

几个卡一遍过的点：

1. :star:在put或get函数中调用DoubleList类的方法时，总是忘了在函数前面加上`cache.`。比如`cache.deleteNode(umap[key]);`总是写成`deleteNode(umap[key]);`
2. :star:对链表进行插入删除时，容易忘记哈希map中需要同步进行插入删除。
3. Node *prev, *next; 容易打快了，把两个\* 写成只有一个\*。
4. 要记得在doubleLinkList<font color='darkgray'>的构造函数的初始化列表</font>中**创建head和tail节点**！才能在构造函数中改变head和tail的指针指向。

### 代码

```c++
/*
    从put函数中的描述可以知道，我们需要让(key,value)有序组织，这个顺序是从最近使用->最久未使用。
    每次调用get和put都需要调整键值对在数据结构中的位置。
    又题目要求函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。因此对于在数据结构中进行查找、插入、删除的这三个操作都要是O(1)的。O(1)查找我们想到用哈希map，O(1)的插入和删除操作呢？
    插入操作的是最近使用，删除操作的是最久未使用，由于我们最近使用和最久未使用这两个位置我们都需要进行操作，因此我们想到用链表。如果是单链表，那么每次还需要遍历到链表末尾进行删除操作，事件复杂度是O(n)，因此要用循环链表。另外还需是双向的，这样就能直接根据头节点的prev指针找到尾节点。
    综上，我们需要哈希map和双向循环链表这两种数据结构。那这两种结构怎么联系起来呢？通过key. 哈希map的key就是关键字key, value就是关键字对应在链表中的节点。链表节点中存放键值。
    设双向循环链表从头到尾是：最近使用->最久未使用。
    调用get()时，先在哈希map中找是否存在关键字，如果存在则将对应在链表中的节点调整到链表头部并返回value，否则返回-1
    调用put()时，先在哈希map中找是否存在关键字，如果存在则将对应在链表中的节点调整到链表头部同时变更value，否则向哈希map以及链表中插入键值对，如果插入后size>capacity, 则尾删节点同时删除哈希map中对应的键值。
*/ 

//链表结点
struct Node { 
    int key, val;
    Node *prev, *next;
    Node(): key(-1), val(-1), prev(nullptr), next(nullptr) {}
    Node(int x, int y) : key(x), val(y), prev(nullptr), next(nullptr) {}
};

//双向循环链表：最近使用 -> 最近最久未使用
class doubleLinkList {
public:
    Node *head, *tail; 
    
    doubleLinkList() : head(new Node()), tail(new Node()) {
        head->next = tail;
        tail->prev = head;
    } 
    // 头插
    void insertHead(Node* node) {         
        // 先将node两端连上
        node->next = head->next;
        node->prev = head;
        // 再让head->next和head->next->prev连上node
        head->next->prev = node;
        head->next = node;
    }
    // 在中间进行删除
    // 因为deleteTail()需要返回int所以deleteNode()也要返回int
    int deleteNode(Node* node) { 
        // node->prev 2 -> 1 node->next
        node->next->prev = node->prev;
        node->prev->next = node->next;

        int _key = node->key;

        // 防止内存泄漏：
        delete node;
        node = nullptr;

        return _key;
    }
    // 尾删
    // 因为在链表尾删的同时要在哈希map中删除，因此函数需要返回key以便在map中进行删除
    int deleteTail() {
        // 如果链表中就只有head和tail两个哨兵结点，直接返回
        if (tail->next == head) {
            return -1;
        }
        return deleteNode(tail->prev);
    }
};

// LRU缓存
class LRUCache {
public:
    doubleLinkList cache;
    unordered_map<int, Node*> umap;
    int cap;

    LRUCache(int capacity) : cap(capacity) {}
    
    int get(int key) {
        // 先在哈希map中找是否存在关键字，如果存在则将对应在链表中的节点调整到链表头部并返回value，否则返回-1
        if (!umap.count(key)) {  
            return -1;
        }

        Node* node = new Node(key, umap[key]->val);
        cache.deleteNode(umap[key]);
        umap.erase(key);
        // 这两个删除不能换位置！

        cache.insertHead(node);
        umap[key] = node;
        return node->val; 
    }
    
    void put(int key, int value) {
        // 先在哈希map中找是否存在关键字，如果存在则将对应在链表中的节点调整到链表头部同时变更value，否则向哈希map以及链表中插入键值对，如果插入后size>capacity, 则尾删节点同时删除哈希map中对应的键值。
        if (umap.count(key)) {
            cache.deleteNode(umap[key]);
            umap.erase(key);
        }

        Node* node = new Node(key, value);
        cache.insertHead(node);
        umap[key] = node;

        if (umap.size() > cap) {
            int _key = cache.deleteTail();
            umap.erase(_key);
        }
    }
};
```

### 复杂度分析

- 时间复杂度：O(1) ，对于 put 和 get 都是 O(1)。 
- 空间复杂度：O(capacity)，因为哈希表和双向链表最多存储 capacity+1个元素

## [:fire: 21. 合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/)

### 题意

将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

**提示：**

- 两个链表的节点数目范围是 `[0, 50]`
- `-100 <= Node.val <= 100`
- `l1` 和 `l2` 均按 **非递减顺序** 排列

### 参考题解

1. 递归
    1. [腐烂的橘子](https://leetcode.cn/problems/merge-two-sorted-lists/solutions/103891/yi-kan-jiu-hui-yi-xie-jiu-fei-xiang-jie-di-gui-by-)
    1. [评论](https://leetcode.cn/problems/merge-two-sorted-lists/solutions/103891/yi-kan-jiu-hui-yi-xie-jiu-fei-xiang-jie-di-gui-by-/comments/1228656) ==递归思路！优秀！==

1. 迭代：[官解](https://leetcode.cn/problems/merge-two-sorted-lists/solutions/226408/he-bing-liang-ge-you-xu-lian-biao-by-leetcode-solu)

### 递归

```c++
ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
    // 递归出口
    if (!list1 || !list2) return list1 ? list1 : list2;
    // 单层递归要做啥事？要merge L1,L2
    // 如果L1第一个元素小于L2, 则这个大项目要交给L1负责
    if (list1->val <= list2->val) {
        // L1先接过下级员工干完的活: mergeTwoLists(list1->next, list2)
        // 然后把自己干的活附上去: list1->next = ()
        list1->next = mergeTwoLists(list1->next, list2);
        // 最后将任务结果提交给上级
        return list1;
    }
    // 否则, 这个大项目交给L2负责
    list2->next = mergeTwoLists(list1, list2->next);
    return list2;
}
```

**复杂度分析**

- 时间复杂度：O(n + m)  

- 空间复杂度：O(n + m)

### 迭代

- 设一个虚拟头节点, 让tail指针也指向它，
- 比较list1和list2指向的结点值的大小，谁小谁就接在tail后面，如果list1小，更新list1为list1->next
- 循环直到遍历到其中一个链表的末尾，把另一条没遍历完的链表接上。

![image-20240221200322546](https://cdn.jsdelivr.net/gh/rangbiubiu/picBed@main/202402212003767.png)

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        ListNode* dummyHead = new ListNode();
        ListNode* tail = dummyHead;
        while (list1 && list2) {
            if (list1->val < list2->val) {
                tail->next = list1;
                list1 = list1->next;
            } else {
                tail->next = list2;
                list2 = list2->next;
            }
            tail = tail->next;
        }
        tail->next = list1 ? list1 : list2;
        ListNode* head = dummyHead->next;
        delete dummyHead;
        dummyHead = nullptr;
        return head;
    }
};
```

**复杂度分析**

- 时间复杂度：O(n + m)  

- 空间复杂度：O(1)

### Follow Up：合并两个有序链表并去重

待补充。。。





## [:fire:160. 相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/)

### 题意

给你两个单链表的头节点 `headA` 和 `headB` ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 `null` 。

**注意**，函数返回结果后，链表必须 **保持其原始结构** 。

**示例 1：**

[![img](https://assets.leetcode.com/uploads/2021/03/05/160_example_1_1.png)](https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png)

```
输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3
输出：Intersected at '8'
解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。
从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。
在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。
— 请注意相交节点的值不为 1，因为在链表 A 和链表 B 之中值为 1 的节点 (A 中第二个节点和 B 中第三个节点) 是不同的节点。换句话说，它们在内存中指向两个不同的位置，而链表 A 和链表 B 中值为 8 的节点 (A 中第三个节点，B 中第四个节点) 在内存中指向相同的位置。
```

**提示：**

- `listA` 中节点数目为 `m`
- `listB` 中节点数目为 `n`
- `1 <= m, n <= 3 * 104`
- `1 <= Node.val <= 105`
- `0 <= skipA <= m`
- `0 <= skipB <= n`
- 如果 `listA` 和 `listB` 没有交点，`intersectVal` 为 `0`
- 如果 `listA` 和 `listB` 有交点，`intersectVal == listA[skipA] == listB[skipB]`

**进阶：**你能否设计一个时间复杂度 `O(m + n)` 、仅用 `O(1)` 内存的解决方案？

### 思路

==:star: **核心思路：双指针 + 数学   **:star:==

如果相交，设链表A,B从开头到相交点分别有a, b步，从相交点到链表末尾有c步。

让两个指针pA和pB分布从两个链表开头开始走，走完自己这条链表后就去走另一条链表，那么两指针一定会相遇，因为a+c+b==b+c+a。如果相交则它们一定会相遇在相交结点，否则相遇时候都指向空。

### 代码

关键是循环条件

#### 版本1

```c++
ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) { 
    ListNode* pA = headA;
    ListNode* pB = headB;
    while (pA != pB) {
        pA = pA ? pA->next : headB;
        pB = pB ? pB->next : headA;
        // 如果相交那么循环会因为pa==pb(不为空)结束
        // 如果不相交那么a走完A和B同时也b走完A和B，pa和pb都等于nullptr
    }
    return pA;
}
```

#### 版本2

```cpp
ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
    ListNode* pA = headA;
    ListNode* pB = headB;
    while (pA || pB) {
        if (pA == pB && pA) {
            return pA;
        }
        pA = pA == nullptr ? headB : pA->next;
        pB = pB == nullptr ? headA : pB->next;
        
    }
    return nullptr;
}
```

为什么不能写成这样？

```cpp
ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
    ListNode* pA = headA;
    ListNode* pB = headB;
    while (pA || pB) {        
        pA = pA == nullptr ? headB : pA->next;
        pB = pB == nullptr ? headA : pB->next;
        if (pA == pB) {
            return pA;
        }        
    }
    return nullptr;
}
```

比如对于intersectVal = 1，listA = [1]，listB = [1]，skipA = 0，skipB = 0这种情况，最后pa\==pb\==nullptr，return pA会得到nullptr，但实际相交结点是1. 

**复杂度分析**

- 时间复杂度：O(n + m)  

- 空间复杂度：O(1)

## :fire:[143. 重排链表](https://leetcode.cn/problems/reorder-list/)

### 题意

给定一个单链表 `L` 的头节点 `head` ，单链表 `L` 表示为：

```
L0 → L1 → … → Ln - 1 → Ln
```

请将其重新排列后变为：

```
L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …
```

不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

 

**示例 1：**

![img](https://pic.leetcode-cn.com/1626420311-PkUiGI-image.png)

```
输入：head = [1,2,3,4]
输出：[1,4,2,3]
```

**示例 2：**

![img](https://cdn.jsdelivr.net/gh/rangbiubiu/picBed@main/202405220845288.png)

```
输入：head = [1,2,3,4,5]
输出：[1,5,2,4,3]
```

**提示：**

- 链表的长度范围为 `[1, 5 * 104]`
- `1 <= node.val <= 1000` 

### 法一

==:star: **核心思路：分割链表->反转->合并   **:star:==

```c++
void reorderList(ListNode* head) {
/*
    1. 先找到链表中点，分割链表，（用快慢双指针）
    2. 反转分割下来的后半部分链表
    3. 合并两链表
*/
    // 1 分割，截断
    ListNode* frontback = middlePrevNode(head);//O(n)
    ListNode* cur = frontback->next;
    frontback->next = nullptr;//要截断!
    // 2 反转
    ListNode* p2 = reverse(cur, nullptr);//O(n/2)
    // 3 合并
    // 注意这里合并，不能新建一个结点作为合并后的头节点，然后逐个将两链表的结点接过去
    // 因为按题意，是要在head这条原链表上进行合并的
    mergeList(head, p2);//O(n)
} 

ListNode* middlePrevNode(ListNode* head) {
    ListNode* slow = head;
    ListNode* fast = head;
    // 如果不把分割链表的逻辑单独分离出来，那么循环条件也可以是while (fast && fast->next)
    while (fast->next && fast->next->next) {
        slow = slow->next;
        fast = fast->next->next;
    }
    // 1 2 3 4
    //   s f
    // 1 2 3 4 5
    //     s   f
    // 后半部分链表从slow->next开始
    // 返回slow而不是slow->next是因为要截断slow和slow->next
    return slow; 
}

ListNode* reverse(ListNode* cur, ListNode* prev) {
    if (!cur) {
        return prev;
    }
    ListNode* tmp = cur->next;
    cur->next = prev;
    return reverse(tmp, cur);
}

void mergeList(ListNode* p1, ListNode* p2) {
    // 1 2 , 4 3
    // p1   p2
    // 1 4 2 3
    // 在将4接到1后面来之前，需要保存2。将2接到4后面来之前，需要保存3
    //    p2   p1          p1->next(tmp1)                p2->next(tmp2)    
    // 即需这几句的顺序：tmp1=p1->next, p1->next=p2, tmp2=p2->next, p1->next=tmp1
    // 中间穿插更新指针的操作：                 p1=p1->next                    p1=p1->next, p2=tmp
     while (p1 && p2) {
        // while (p2) 也行
        ListNode* tmp1 = p1->next; //2 
        p1->next = p2;  //1->4
        p1 = p1->next;  //4
        ListNode* tmp2 = p2->next; //3
        p1->next = tmp1;//1->4->2
        p1 = p1->next;  //2
        p2 = tmp2;
    }
}
```

#### 复杂度分析

- 时间复杂度：O(n)

- 空间复杂度：O(1)

### 法二

==:star: **核心思路：用数组或deque模拟   **:star:==

通过把链表放进某结构中，再经过一系列操作重构链表。
重构链表都要注意结尾那步必要操作！

（1）数组模拟
首先遍历一边原链表，将所有的结点都存到数组中
把链表放进数组中，然后通过左右指针法遍历数组，构造链表。

（2）双向队列模拟
首先遍历一边原链表，将所有的结点都存到双端队列中
把链表放进双向队列，然后通过双向队列一前一后弹出数据，来构造新的链表。这种方法比操作数组容易一些，不用双指针模拟一前一后了

#### 代码

##### 数组模拟

```c++
void reorderList(ListNode* head) {
    vector<ListNode*> vec;//把链表放进数组中
    ListNode* cur = head;
    while (cur) {//将链表中指向每个结点的指针都存到vec1中
        vec.push_back(cur);
        cur = cur->next;
    }
    cur = head;
    // 利用左右双指针从第二个开始构造链表
    int i = 1, j = vec.size() - 1;
    for (; i <= j; i++, j--) {
        cur->next = vec[j];
        if (i == j) {//当链长为偶数时，最后一次循环i会==j
            cur = cur->next;//让cur指向最后一个结点
        }
        else {
            cur->next->next = vec[i];
            cur = cur->next->next;//让cur指向最后一个结点
        }
    }
    //前面统一让cur指向重排后的最后一个结点以统一执行末尾置空操作
    cur->next = nullptr; // 注意结尾这步是必要的！
/* 
    因为重构了链表，末尾也要重构，要不然可能死循环。
    假设原来的链表是1,2,3,4,null，重排后的链表就应为1,4,2,3,null。（实际每个结点都有专属的地址，这里为了方便直接用其值表示结点）
    没执行这一步之前，除了最后一个结点外其余结点的next域都重构了，都指向了另外的结点（next里存的地址变了）。
    重排后的最后一个结点(值为3的结点)原来的next域是指向值为4的结点(存的值为4的结点的地址),若没有这一步则依然会指向值为4的那个结点，也就是本来没有环的链表中形成了环。
*/
```

##### 双向队列模拟

```c++
void reorderList(ListNode* head) {
    ListNode* cur = head;
    deque<ListNode*> que;
    while (cur->next) {//从第二个结点开始把链表放进双向队列
        que.push_back(cur->next);//也可以使用C++11的emplace_back()
        cur = cur->next;
    }
    cur = head;
    while (que.size()) {//当que中没有元素(都被用去构造链表了)时循环结束
        cur->next = que.back();//先取后面的
        que.pop_back();
        if (que.size() == 0) {//当链长为偶数时，最后一次循环que中就只剩一个元素了,而上一步已经将这最后一个元素弹出了，因此此时que中没有元素了
            cur = cur->next;
        }
        else {
            cur->next->next = que.front();//再取前面的
            que.pop_front();
            cur = cur->next->next;
        }
    }
    //退出循环后cur都指向最后一个结点
    cur->next = nullptr;//同数组模拟一样，注意结尾给最后一个结点的next域置空
}
```



## [:fire:23. 合并 K 个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/)

### 题意

给你一个链表数组，每个链表都已经按升序排列。

请你将所有链表合并到一个升序链表中，返回合并后的链表。

**示例 1：**

```
输入：lists = [[1,4,5],[1,3,4],[2,6]]
输出：[1,1,2,3,4,4,5,6]
解释：链表数组如下：
[
  1->4->5,
  1->3->4,
  2->6
]
将它们合并到一个有序链表中得到。
1->1->2->3->4->4->5->6
```

**示例 2：**

```
输入：lists = []
输出：[]
```

**示例 3：**

```
输入：lists = [[]]
输出：[]
```

**提示：**

- `k == lists.length`
- `0 <= k <= 10^4`
- `0 <= lists[i].length <= 500`
- `-10^4 <= lists[i][j] <= 10^4`
- `lists[i]` 按 **升序** 排列
- `lists[i].length` 的总和不超过 `10^4`

### 参考题解

1. [官解](https://leetcode.cn/problems/merge-k-sorted-lists/solutions/219756/he-bing-kge-pai-xu-lian-biao-by-leetcode-solutio-2)

### 法一

暴力：合并两个有序链表。

将每条链表取出来与ans合并（合并两个有序链表），将合并结果返给ans，不断更新ans，最终ans就是所有链表合并后的结果。

```c++
ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
    if (!list1 || !list2) return list1 ? list1 : list2;
    ListNode* head = new ListNode();
    ListNode* cur = head;

    while (list1 && list2) { 
        if (list1->val <= list2->val) {
            cur->next = list1;
            list1 = list1->next;
        } else {
            cur->next = list2;
            list2 = list2->next;
        }
        cur = cur->next;
    } 
    cur->next = list1 ? list1 : list2;
    
    ListNode* ans = head->next;
    delete head;
    head = nullptr; 
    return ans;
}
ListNode* mergeKLists(vector<ListNode*>& lists) {
    ListNode* ans = nullptr;
    for (auto list : lists) {
        ans = mergeTwoLists(ans, list);
    }
    return ans;
}
```

#### 复杂度分析

假设每个链表的最长长度是 n.

- 时间复杂度：O(k^2^n)  

    ![image-20240226230825439](https://cdn.jsdelivr.net/gh/rangbiubiu/picBed@main/202402262308498.png)

- 空间复杂度：O(1)

### 法二

==:star: **核心思路： 分治合并  **:star:==

**:question:   problems:** 

1. 为什么mid下取整不能用上取整的分治写法? 即为什么mid下取整时不能写成 `ListNode* L1 = merge(lists, left, mid); ListNode* L2 = merge(lists, mid + 1, right);` ?

:heavy_check_mark:  **answer:** 

1. 如果mid下取整时分治逻辑写成 `ListNode* L1 = merge(lists, left, mid); ListNode* L2 = merge(lists, mid + 1, right);`如下：

![image-20240227124231265](C:\Users\Oscar\AppData\Roaming\Typora\typora-user-images\image-20240227124231265.png)

#### 代码

```c++
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        if (!list1 || !list2) return list1 ? list1 : list2;
        ListNode* head = new ListNode();
        ListNode* cur = head;

        while (list1 && list2) { 
            if (list1->val <= list2->val) {
                cur->next = list1;
                list1 = list1->next;
            } else {
                cur->next = list2;
                list2 = list2->next;
            }
            cur = cur->next;
        } 
        cur->next = list1 ? list1 : list2;
        
        ListNode* ans = head->next;
        delete head;
        head = nullptr; 
        return ans;
    }
    ListNode* merge(vector<ListNode*>& lists, int left, int right) {
        // 1.递归参数以及返回值: 需要两个int表示分治区间的两端点
        // 2.递归结束的条件: 分治区间长度为1时,即只有一个链表时
        if (left == right) return lists[left];
        else if (left > right) return nullptr;
        // 3.单层递归做什么事? 先分治(一分为二),再合并
        // 先分治
        int mid = left + (right - left) / 2; 		//mid下取整
        ListNode* L1 = merge(lists, left, mid);
        ListNode* L2 = merge(lists, mid + 1, right); 
        
        // int mid = left + (right - left + 1) / 2; // mid上取整
        // ListNode* L1 = merge(lists, left, mid - 1);
        // ListNode* L2 = merge(lists, mid, right);
        
        // 再合并
        return mergeTwoLists(L1, L2);
    }
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        if (lists.size() == 0) return nullptr; 
        return merge(lists, 0, lists.size() - 1);
    }
};
```

#### 复杂度分析

假设每个链表的最长长度是 n

- 时间复杂度：*O*(knlogk) 

    通过递归分治的方式将k个链表两两合并，每次合并的时间复杂度是O(kn)，而总共需要合并logk次，因此总的时间复杂度是*O*(knlogk) 。

    ![image-20240227150029742](https://cdn.jsdelivr.net/gh/rangbiubiu/picBed@main/202402271500841.png)

- 空间复杂度：O(logk)

### 法三

==:star: **核心思路：小根堆  **:star:==

#### 代码

##### 优先级队列实现小根堆

- 维护一个大小为 k （=链表数量）的小根堆（用优先级队列实现），堆中维护每个链表中最前面的那个未被合并的元素，每次选取堆顶元素尾插到 已合并的链表。

```c++
class compare {
public: //不要忘了class默认是private, 所以要写public
    bool operator() (ListNode* a, ListNode* b) {
        return a->val > b->val;
    }
};
class Solution {
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        priority_queue<ListNode*, vector<ListNode*>, compare> pri_que; 
        // 初始化小根堆为k个链表的首结点
        for (auto firstNode : lists) {
            // 注意判空！！！
            if (firstNode) pri_que.push(firstNode);
        }
        ListNode* dummyHead = new ListNode();
        ListNode* cur = dummyHead;
        // 开始边pop边合并边push
        while (!pri_que.empty()) {
            auto node = pri_que.top(); pri_que.pop();
            cur->next = node; 
            cur = cur->next;
            // 将该节点所在的链表的下一节点进堆。注意判空！！！
            if (node->next) pri_que.push(node->next);
        }
        ListNode* ans = dummyHead->next;
        delete dummyHead;
        dummyHead = nullptr;
        return ans;
    }
};
```

##### 手写小根堆

建堆调整堆都很熟了，就剩合并的地方还有一些要注意的细节。

```cpp
class Solution {
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {
/* 
    维护一个小根堆，里面存了每个链表剩下待选结点中的第一个结点，
    每次选堆顶结点尾加到合并后的链表, 然后将该节点所在链表的下一个结点push到小根堆
    再将用完的堆顶结点换到minHeap数组的末尾以便pop_back从堆中删除，
    然后重新调整堆
*/
        vector<ListNode*> minHeap; 
        // 不能一开始就初始化大小为lists.size()，因为之后边pop边合并 边push边调整堆时，
        // 需要将用完的堆顶结点换到minHeap数组的末尾以便pop_back从堆中删除

        // 1.建小根堆
        for (auto firstNode : lists) {
            if (firstNode) minHeap.emplace_back(firstNode);
        }
        buildMinHeap(minHeap);
        ListNode* dummyHead = new ListNode();
        ListNode* cur = dummyHead;
        // 2.边pop边合并 边push边调整堆
        while (!minHeap.empty()) {
            // 选堆顶结点尾加到合并后的链表
            ListNode* node = minHeap[0];
            cur->next = node;
            cur = cur->next;
            // 将node->next加入到堆中(注意判空)
            if (node->next) {
                minHeap.emplace_back(node->next);
            }
            // 将用完的堆顶结点换到minHeap数组的末尾以便pop_back从堆中删除
            swap(minHeap[0], minHeap.back());
            minHeap.pop_back();
            // 然后才是重新调整堆
            adjustMinHeap(minHeap, 0);
        }
        ListNode* ans = dummyHead->next;
        delete dummyHead;
        dummyHead = nullptr;
        return ans;
    }
    void buildMinHeap(vector<ListNode*>& minHeap) {
        for (int i = minHeap.size() / 2 - 1; i >= 0; --i) {
            adjustMinHeap(minHeap, i);
        }
    }
    void adjustMinHeap(vector<ListNode*>& minHeap, int start) {
        int parent = start;
        int Lnode = 2 * start + 1;
        int Rnode = 2 * start + 2;
        // 下滤操作让父节点作为三者中的最小的结点
        if (Lnode < minHeap.size() && minHeap[Lnode]->val < minHeap[parent]->val) {
            parent = Lnode;
        }
        if (Rnode < minHeap.size() && minHeap[Rnode]->val < minHeap[parent]->val) {
            parent = Rnode;
        }
        // 如果调整了结点，则继续调整原来父节点被换到的结点所在的子树
        if (parent != start) {
            swap(minHeap[parent], minHeap[start]);
            adjustMinHeap(minHeap, parent);
        }
    }
};
```

#### 复杂度分析

- 时间复杂度：O(knlogn)  。往堆中插入和删除元素的时间复杂度都是O(log k)，总共有 kn 个元素会被插入和删除各一次，因此总的时间复杂度就是O(knlogn)。

- 空间复杂度：O(k)

## [:fire:19. 删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/) 

### 题意

给你一个链表, 删除链表的倒数第 `n` 个结点, 并且返回链表的头结点。

### 思路

==:star: **核心思路：快慢双指针   **:star:==

关键：这一题必须要设置虚拟头节点！！！

**:small_red_triangle_down:  steps: **

1.  先要找到倒数第N个结点的前一个结点pre：让两个指针相隔N从左往右遍历,当快指针到链表末尾结点时慢指针就指向倒数第N+1个结点了
2.  然后让pre->next=pre->next->next就删除了倒数第N个结点

**:x: careless | ignore :**

- while ((n + 1)--)会造成无限循环。因为++、--都只能用于变量, 而不能用于常量或表达式。而(n+1)并不是一个变量, 而是一个确定值, 所以(n+1)--非法。

### 代码

```   c++
ListNode* removeNthFromEnd(ListNode* head, int n) {
/*
    用快慢指针分别指向链表末尾和链表倒数第n个结点的前一结点
    1 2 3 [4] 5
        sl    fa
    考虑到【链表只有一个结点，且该节点就是待删结点】的这种情况，我们应该用虚拟头节点
*/
    ListNode* dummyhead = new ListNode(-1, head);
    ListNode* slow = dummyhead;
    ListNode* fast = dummyhead;
    // 快指针先走n步，然后慢指针才开始同步和快指针一起走，这样它们就始终距离n步
    while (n--) {
        fast = fast->next;
    }
    while (fast && fast->next) {
        slow = slow->next;
        fast = fast->next;
    }
    // 删除节点，释放内存
    ListNode* delNode = slow->next;
    slow->next = slow->next->next;
    delete delNode;
    delNode = nullptr;

    ListNode* ans = dummyhead->next;
    delete dummyhead;
    dummyhead = nullptr;
    return ans; 
}
```

## :fire:[2. 两数相加](https://leetcode.cn/problems/add-two-numbers/)

### 题意

给你两个 **非空** 的链表，表示两个非负的整数。它们每位数字都是按照 **逆序** 的方式存储的，并且每个节点只能存储 **一位** 数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

**示例 1：**

![img](https://cdn.jsdelivr.net/gh/rangbiubiu/picBed@main/202403020030331.jpeg)

```
输入：l1 = [2,4,3], l2 = [5,6,4]
输出：[7,0,8]
解释：342 + 465 = 807.
```

**示例 2：**

```
输入：l1 = [0], l2 = [0]
输出：[0]
```

**示例 3：**

```
输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
输出：[8,9,9,9,0,0,0,1]
```

**提示：**

- 每个链表中的节点数在范围 `[1, 100]` 内
- `0 <= Node.val <= 9`
- 题目数据保证列表表示的数字不含前导零

### 思路 

**:key:  key：**

- 逐位进行相加并处理进位。步骤如下：

    1. 初始化一个虚拟头节点 `dummy` 和一个指针 `cur`，用于构建相加后的链表。同时，初始化一个变量 `carry` 用于存储进位。

    2. 循环直到两条链表都遍历完毕：

        - 计算两个节点值之和以及进位值(如果某条链表已经遍历完，则认为其值为 0)，更新进位值 `carry`。

        - 创建一个新节点，连在新链表后，并更新指针 `cur`。 

        - 更新l1和l2。
    3. 当两个链表都遍历完后，检查 `carry` 是否大于 0，如果大于 0，说明还有进位需要处理，创建一个值为 `carry` 的节点连在新链表后。
    4. 返回虚拟头节点的下一个节点。

**:x: careless | ignore :**

主要是注意两个地方：

- 循环条件是 || 而不是 &&（为了方便后续处理）=> 也因此，要记得在while中对l1和l2判空
- 退出循环后不能直接返回就完事了，还需要检查carry是否>0，是则需要新增结点到链表末尾。

**模拟：**

![image-20240416083716213](https://cdn.jsdelivr.net/gh/rangbiubiu/picBed@main/202404160837331.png)

### 代码

```c++
ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
/*
    用两个指针，同步从左往右遍历两链表，计算指针指向的两节点的和以及进位
*/ 
    ListNode* dummyhead = new ListNode();
    ListNode* p = dummyhead;
    int carry = 0;
    while (l1 || l2) {
        // 计算新节点的值以及进位
        int val1 = l1 ? l1->val : 0;
        int val2 = l2 ? l2->val : 0;
        int nodeVal = (val1 + val2 + carry) % 10;
        carry = (val1 + val2 + carry) / 10;
        // 生成新节点
        p->next = new ListNode(nodeVal);
        // 更新指针 
        p = p->next;
        if (l1) l1 = l1->next;
        if (l2) l2 = l2->next;
    }
    if (carry) {
        p->next = new ListNode(1, nullptr);
    } 
    ListNode* ans = dummyhead->next;
    delete dummyhead;
    dummyhead = nullptr;
    return ans;
}
```

### 复杂度分析

- 时间复杂度：O(max(n, m))  

- 空间复杂度：O(1)。返回值不计入空间复杂度。

## :fire:[234. 回文链表](https://leetcode.cn/problems/palindrome-linked-list/)

### 题意

给你一个单链表的头节点 `head` ，请你判断该链表是否为回文链表。如果是，返回 `true` ；否则，返回 `false` 。

**示例 1：**

![img](https://cdn.jsdelivr.net/gh/rangbiubiu/picBed@main/202403091934808.jpeg)

```
输入：head = [1,2,2,1]
输出：true
```

**示例 2：**

![img](https://cdn.jsdelivr.net/gh/rangbiubiu/picBed@main/202403091934648.jpeg)

```
输入：head = [1,2]
输出：false
```

**提示：**

- 链表中节点数目在范围`[1, 105]` 内
- `0 <= Node.val <= 9`

**进阶：**你能否用 `O(n)` 时间复杂度和 `O(1)` 空间复杂度解决此题？

### 参考题解

1. [官解](https://leetcode.cn/problems/palindrome-linked-list/solutions/457059/hui-wen-lian-biao-by-leetcode-solution)

### 思路

==:star: **核心思路：反转链表 + 快慢指针  **:star:==

**:key:  key：**

- ![SmartSelect_20240310_100226_Samsung Notes](https://cdn.jsdelivr.net/gh/rangbiubiu/picBed@main/202403101003735.jpg)

**:question:   problems:** 

1. 为什么【1.找到前半部分链表的尾节点】中循环条件是`while (fast->next && fast->next->next)`而不是`while (fast && fast->next)`? 可以是`while (fast && fast->next)`吗？

:heavy_check_mark:  **answer:** 

1. 不可以（会很麻烦）。因为要反抓后半部分链表，不仅要找到开始反转的结点，还要找到起始反转结点的前一个结点（即前半部分链表的尾节点）。

    - 如果用while (fast && fast->next) ，那么当节点数为偶数，退出循环时!fast，slow刚好指向开始反转的结点。也就是说此时会获取不到起始反转结点的前一个结点

        ```cpp
         1 2 3 4 5    需要 s 指向 3
        sf   f   f
           s s
        
         1 2 3 4     需要 s 指向 2
        sf   f   f
           s s
        ```

    - 因此要将条件改成`while (fast->next && fast->next->next)`，这样不管节点数为奇数还是为偶数，退出循环时slow都指向起始反转结点的前一个结点。
    
        ```cpp
         1 2 3 4 5 	 需要 s 指向 3
        sf   f   f
           s s
        
         1 2 3 4     需要 s 指向 2
        sf   f   
           s 
        ```
    
        

**:small_red_triangle_down:  steps: **

1. 找到前半部分链表的尾节点:  用快慢双指针(步数是两倍关系)，快指针走到末尾时，慢指针就指向了中间
2. 反转链表后半部分
3. 同向双指针判断是否回文
4. 还原链表（不是必须的，但最好将链表恢复原样，因为使用该函数的人通常不希望链表结构被更改）

### 代码

最后不还原链表的代码

```cpp
class Solution {
public:
    bool isPalindrome(ListNode* head) {
        if (!head->next) {
            return true;
        }
        // 1.从中间分割链表
        ListNode* slow = head;
        ListNode* fast = head;
        // 1 2 2 1
        //   s f
        // 1 2 3 2 1 
        //     s   f
        while (fast->next && fast->next->next) {
            // 循环条件是细节！！！
            slow = slow->next;
            fast = fast->next->next;
        }
        // 2.反转链表
        ListNode* head2 = reverseList(nullptr, slow->next);
        slow->next = nullptr;
        // 3.遍历比较两链表的结点是否相同
        while (head && head2 && head->val == head2->val) {
            head = head->next;
            head2 = head2->next;
        }
        return head == nullptr || head2 == nullptr;
    }
    ListNode* reverseList(ListNode* prev, ListNode* cur) {
        if (!cur) {
            return prev;
        }
        ListNode* tmp = cur->next;
        cur->next = prev;
        return reverseList(cur, tmp);
    }
};
```

如果最后需要还原链表：

```c++
class Solution {
public:
    ListNode* reverseList(ListNode* cur) {
        ListNode* pre = nullptr;
        while (cur) {
            ListNode* tmp = cur->next;
            cur->next = pre;
            pre = cur;
            cur = tmp;
        }
        return pre;
    }
    bool isPalindrome(ListNode* head) {
        if (head == nullptr) return true;
        // 1.找到前半部分链表的尾节点
        ListNode* slow = head;
        ListNode* fast = head;
        while (fast->next && fast->next->next) {
            slow = slow->next;
            fast = fast->next->next;
        }
        // 两种情况退出循环时slow都指向开始反转的结点的前一个结点
        ListNode* pre = slow;       //开始反转的结点的前一个结点
        ListNode* cur = slow->next; //开始反转的结点
        // 2.反转链表后半部分，并接在链表前半部分的末尾
        pre->next = reverseList(cur);
        // 3.同向双指针判断是否回文
        slow = head;
        fast = pre->next;
        while (fast) {
            if (slow->val != fast->val) {
                return false;
            }
            slow = slow->next;
            fast = fast->next;
        } 
        // 4.还原链表
        pre->next = reverseList(pre->next);
        return true;
    }
};
```

**复杂度分析**

- 时间复杂度：O(n)  

- 空间复杂度：O(1)

## :fire:[24. 两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/) 

### 题意

给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。 

**示例 1：**

![img](https://cdn.jsdelivr.net/gh/rangbiubiu/picBed@main/202407131516446.jpeg)

```
输入：head = [1,2,3,4]
输出：[2,1,4,3]
```

**示例 2：**

```
输入：head = []
输出：[]
```

**示例 3：**

```
输入：head = [1]
输出：[1]
```

 **提示：**

- 链表中节点的数目在范围 `[0, 100]` 内
- `0 <= Node.val <= 100`

### 代码

```cpp
ListNode* swapPairs(ListNode* head) {
    ListNode* dummyhead = new ListNode(0, head);
    ListNode* pre = dummyhead;
    /*
    pre -> pre->next -> pre->next->next，要将后两个交换，
    如果pre->next为空或者pre->next->next为空就停止循环
        ^   1   2  3  4
        pre tmp
        ^   2   3  4 
        pre  
    将tmp(1)接在pre->next(2)和pre->next->next(3)之间，更新1为pre
        ^   2   1   3        4 
                tmp
    */ 
    while (pre->next && pre->next->next) {
        ListNode* tmp = pre->next; // 1
        pre->next = pre->next->next;//^ 2 3 4 
        tmp->next = pre->next->next;//1 3 4
        pre->next->next = tmp;//^ 2 1 3 4
        pre = tmp;
    }
    // 可以根据需要释放空间
    return dummyhead->next;
}
```



## :fire:[83. 删除排序链表中的重复元素](https://leetcode.cn/problems/remove-duplicates-from-sorted-list/)

### 题意

给定一个已排序的链表的头 `head` ， *删除所有重复的元素，使每个元素只出现一次* 。返回 *已排序的链表* 。

**示例 1：**

![img](https://cdn.jsdelivr.net/gh/rangbiubiu/picBed@main/202407111634971.jpeg)

```
输入：head = [1,1,2]
输出：[1,2]
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/01/04/list2.jpg)

```
输入：head = [1,1,2,3,3]
输出：[1,2,3]
```

 **提示：**

- 链表中节点数目在范围 `[0, 300]` 内
- `-100 <= Node.val <= 100`
- 题目数据保证链表已经按升序 **排列**

### 代码

```cpp
ListNode* deleteDuplicates(ListNode* head) {
    ListNode* cur = head;
    while (cur && cur->next) {
        // 只要当前节点和下一个节点相同就删掉下一个节点
        if (cur->val == cur->next->val) {
            cur->next = cur->next->next;
        } else {
            cur = cur->next;
        }
    }
    return head;
}
```



## :fire:[82. 删除排序链表中的重复元素 II](https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/)

### 题意

给定一个已排序的链表的头 `head` ,  *删除原始链表中所有重复数字的节点, 只留下不同的数字* 。返回 *已排序的链表* 。

**示例 1：**

![img](https://cdn.jsdelivr.net/gh/rangbiubiu/picBed@main/202401221037613.jpeg)

```
输入：head = [1,2,3,3,4,4,5]
输出：[1,2,5]
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/01/04/linkedlist2.jpg)

```
输入：head = [1,1,1,2,3]
输出：[2,3]
```

**提示：**

- 链表中节点数目在范围 `[0, 300]` 内
- `-100 <= Node.val <= 100`
- 题目数据保证链表已经按升序 **排列**

### 思路

==:star: **核心思路： 双指针  **:star:==

![image-20240115160934861](https://cdn.jsdelivr.net/gh/rangbiubiu/picBed@main/202401151609014.png)

### 代码

```c++
ListNode* deleteDuplicates(ListNode* head) {
    ListNode* dummyhead = new ListNode(0, head);
    ListNode* prev = dummyhead;
    ListNode* cur = prev->next;
    while (cur) {
        while (cur->next && cur->val == cur->next->val) {
            cur = cur->next;
        }
        if (prev->next != cur) {
            prev->next = cur->next;
            // 不能接着就prev = prev->next;因为prev->next可能是下一个重复值的第一个结点
        } else {
            prev = prev->next;
        }
        cur = cur->next;
    }
    return dummyhead->next;
}
```

### 复杂度分析

- 时间复杂度：O(n)  

- 空间复杂度：O(1)

## :fire:[LCR 140. 训练计划 II](https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/)

### 题意

查找并返回链表的倒数第 `n` 个结点。

**示例 1：**

```
输入：head = [2,4,7,8], n = 1
输出：8
```

**提示：**

- `1 <= head.length <= 100`
- `0 <= head[i] <= 100`
- `1 <= n <= head.length`

### 代码

```cpp
ListNode* trainingPlan(ListNode* head, int n) {
/* 
    先让快指针走n步，然后让慢指针从头开始与快指针同步走，
    当快指针走到链表末尾时，慢指针指向倒数第n个结点
        2 4 7 8, n = 2, 返回7
    最终    s   f
        s   f
    与[19. 删除链表的倒数第 N 个结点]不同，该题只需要查找倒数第n个结点，因此不需要用虚拟头节点
*/
    ListNode* fast = head;
    int k = n;
    while (k--) {
        fast = fast->next;
    }
    ListNode* slow = head;
    while (fast != nullptr) {
        slow = slow->next;
        fast = fast->next;
    }
    return slow;
}
```

## :two:[328. 奇偶链表](https://leetcode.cn/problems/odd-even-linked-list/)

### 题意

给定单链表的头节点 `head` ，将所有索引为奇数的节点和索引为偶数的节点分别组合在一起，然后返回重新排序的列表。

**第一个**节点的索引被认为是 **奇数** ， **第二个**节点的索引为 **偶数** ，以此类推。

请注意，偶数组和奇数组内部的相对顺序应该与输入时保持一致。

你必须在 `O(1)` 的额外空间复杂度和 `O(n)` 的时间复杂度下解决这个问题。

 **示例 1:**

![](https://assets.leetcode.com/uploads/2021/03/10/oddeven-linked-list.jpg)

```
输入: head = [1,2,3,4,5]
输出: [1,3,5,2,4]
```

**示例 2:**

![img](https://assets.leetcode.com/uploads/2021/03/10/oddeven2-linked-list.jpg)

```
输入: head = [2,1,3,5,6,4,7]
输出: [2,3,6,7,1,5,4]
```

 **提示:**

- `n == ` 链表中的节点数
- `0 <= n <= 104`
- `-106 <= Node.val <= 106`

### 思路

将奇数节点和偶数节点分离成奇数链表和偶数链表，然后将偶数链表连接在奇数链表之后，合并后的链表即为结果链表。

#### 1 :hand:

![image-20240726164940184](https://cdn.jsdelivr.net/gh/rangbiubiu/picBed@main/202407261649253.png)

```cpp
ListNode* oddEvenList(ListNode* head) {
    if (head == nullptr || head->next == nullptr) {
        return head;
    }
    // 用odd和even遍历奇偶链表
    ListNode* evenHead = head->next;
    ListNode* odd = head;   
    ListNode* even = evenHead;
    while (even && even->next) { 
        // 从奇链表中删掉偶节点，更新odd
        odd->next = odd->next->next; 
        odd = odd->next;    
        // 将下一个偶节点(或nullptr)接在even后, 更新even
        even->next = odd->next; 
        even = even->next;
    }
    odd->next = evenHead;
    // 如果链表节点数为偶数个，那么最后even指向最后一个节点，odd指向倒数第二个节点，而odd表示奇链表的末尾。
    // 因为本题是需要将偶数链表连接在奇数链表之后，因此让odd->next（奇链表的末尾）直接连偶链表的开头即可；如果是需要彻底断开奇偶链表，则需要让odd->next=nullptr;
    return head;
}
```

循环条件写成 `while (odd && odd->next)  `行不行？

```cpp
1,3,2,2,3,1 ^
        o e
当oe到上面的位置时，由于条件仍满足，因此会再走一个循环，执行完前两句之后如下所示，odd指向空，要执行的下一句是even->next = odd->next;此时就会报空指针异常。
1,3,2,2,3,1 ^
          e o
```

#### 2

大坑！！！如果你没出现“超出内存限制”的错误，那就不用看下面的了。如果出现了，大概率是因为奇偶链表并未完全断开，成环了。我也是自己画了几遍才发现问题。。。

![image-20240726165117002](https://cdn.jsdelivr.net/gh/rangbiubiu/picBed@main/202407261651066.png)

最好不要写成这样，因为很容易错。如果一定要写，记得加上下面这个条件，这样才不会成环。

```cpp
// 如果链表节点数为奇数个，那么最后odd指向最后一个节点，even->next却仍指向odd。
// 通过这一步可以将偶链表与奇链表彻底断开
if (!odd->next) {
    even->next = nullptr;
}
```

完整代码（但不推荐这样写）

```cpp
ListNode* oddEvenList(ListNode* head) {
    if (head == nullptr || head->next == nullptr || !head->next->next) {
        return head;
    }
    // 用odd和even遍历奇偶链表，先将odd->next接到even后面，然后更新even，再让odd->next=odd->next->next, 更新odd
    // 1. 将偶数位的节点单独抽出组成一条新链表
    ListNode* odd = head;
    ListNode* even_dummyHead = new ListNode();
    ListNode* even = even_dummyHead;
    while (odd && odd->next) { 
        even->next = odd->next;
        even = even->next;
        if (odd->next->next) {
            odd->next = odd->next->next;
            odd = odd->next;
        } else {
            odd->next = nullptr;
        }
        // 关键！如果不加这个条件，那么当链表节点数为奇数时，结果链表会成环
        if (!odd->next) {
            even->next = nullptr;
        }
    }
    // 2.将新链表接上去
    odd->next = even_dummyHead->next;
    return head;
}
```

**复杂度分析**

- 时间复杂度：O(n)  

- 空间复杂度：O(1)

## :two:[排序奇升偶降链表](https://www.nowcoder.com/practice/3a188e9c06ce4844b031713b82784a2a?tpId=117&tqId=39396&rp=1&ru=/exam/oj&qru=/exam/oj&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26pageSize%3D50%26search%3D207%26tab%3D算法篇%26topicId%3D117&difficulty=undefined&judgeStatus=undefined)

### 题意

给定一个奇数位升序，偶数位降序的链表，返回对其排序后的链表。

题面解释：例如链表 1->3->2->2->3->1 是奇数位升序偶数位降序的链表，而 1->3->2->2->3->2 则不符合题目要求。

数据范围：链表中元素个数满足 1≤𝑛≤10000 1≤*n*≤10000 ，链表中的元素大小满足 1≤𝑣𝑎𝑙≤100000 1≤*v**a**l*≤100000 

示例1

```
输入：{1,3,2,2,3,1}
输出：{1,1,2,2,3,3}
```

示例2

```
输入：{1,2,2}
输出：{1,2,2}
```

### 思路

分三步：

1. 按奇偶位置拆分链表。对应 [328. 奇偶链表]()
2. 反转偶链表。对应 [206. 反转链表]()
3. 合并两个有序链表。对应 [21. 合并两个有序链表]()

第一步中注意，本题与:two:[328. 奇偶链表](https://leetcode.cn/problems/odd-even-linked-list/)不同，分离奇偶节点后不是让奇链表的末尾连偶链表的开头，而是要彻底断开奇偶链表。

如果忽略了`odd->next=nullptr;`则：

```cpp
1, 3, 2, 2, 3, 1 ^
o1 e1 o2 e2 o3 e3 
此时even->next为空，退出循环，奇偶链表分别为：
奇 1, 2, 3, 1, ^
        o3 
偶 3, 2, 1 ^
        e3 
注意到奇链表后还多连了一个偶节点，没断干净。
```

### 代码

```cpp
class Solution {
public: 
    ListNode* sortLinkedList(ListNode* head) {
        // 分离奇偶链表，然后反转偶链表，最后合并奇偶链表
        if (!head && !head->next) {
            return head;
        }
        ListNode* evenHead = detach(head);
        evenHead = reverseList(evenHead);
        // 返回链表合并后新的头节点
        return mergeList(head, evenHead);
    }
    ListNode* detach(ListNode* head) {
        // 初始化指针
        ListNode* evenHead = head->next;
        ListNode* odd = head;
        ListNode* even = evenHead;
        // 分离奇偶节点并更新指针
        while (even && even->next) { 
            odd->next = odd->next->next;
            odd = odd->next;
            even->next = odd->next;
            even = even->next;
        } 
        odd->next = nullptr;
        // 返回偶链表的头节点
        return evenHead;
    }
    ListNode* reverseList(ListNode* head) {
        ListNode* prev = nullptr;
        while (head) {
            //暂存下一个节点
            ListNode* temp = head->next; 
            // 改变指向
            head->next = prev;
            // 更新指针
            prev = head;
            head = temp;
        }
        // 返回偶链表反转后的头节点
        return prev;
    }
    ListNode* mergeList(ListNode* odd, ListNode* even) {
        ListNode* newHead = new ListNode(0);
        ListNode* tail = newHead; 
        while (odd && even) {
            // 判断odd和even谁小，tail->next就是谁，并更新对应链表中的指针以及tail指针
            if (odd->val <= even->val) {
                tail->next = odd;
                odd = odd->next;
            } else {
                tail->next = even;
                even = even->next;
            }
            tail = tail->next;
        }
        // 如果某个链表还剩一个节点未合并
        if (odd || even) {
            tail->next = odd ? odd : even;
        }
        // 返回链表合并后新的头节点
        ListNode* ans = newHead->next;
        delete newHead;
        newHead = nullptr;
        return ans;
    }
};
```

**复杂度分析**

- 时间复杂度：O(n)  

- 空间复杂度：O(1)



## :two:[61. 旋转链表](https://leetcode.cn/problems/rotate-list/)

### 题意

给你一个链表的头节点 `head` ，旋转链表，将链表每个节点向右移动 `k` 个位置。

 **示例 1：**

![img](https://assets.leetcode.com/uploads/2020/11/13/rotate1.jpg)

```
输入：head = [1,2,3,4,5], k = 2
输出：[4,5,1,2,3]
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2020/11/13/roate2.jpg)

```
输入：head = [0,1,2], k = 4
输出：[2,0,1]
```

 **提示：**

- 链表中节点的数目在范围 `[0, 500]` 内
- `-100 <= Node.val <= 100`
- `0 <= k <= 2 * 109`

### 思路

题目的意思其实就是：设链表节点数为n，将链表最后的 k%n 节点作为一个整体搬到前面。

1. 计算链表节点数并找出链表的尾节点tail。
2. 断开链表，将其分为前（n-k个节点）、后（倒数k个节点）两个部分。
    既然已知链表长度，就不用快慢双指针找了。直接循环，从第一个节点到第n-k个节点需要循环n-k-1次。
3. 将前半部分链表连在后半部分链表的末尾。

### 代码

```cpp
ListNode* rotateRight(ListNode* head, int k) {
    if (!head || !head->next) {
        return head;
    }
    // 1. 计算链表节点数并找出链表的尾节点tail
    ListNode* tail = head;
    int n = 0; 
    while (tail && tail->next) {
        tail = tail->next;
        n++;
    }
    n++; //因为最后tail指向尾节点而非指向空，少算了一次
    k %= n;
    if (k == 0) { //原来的k==0或者为n的倍数时，不用做变换
        return head;
    }
    // 2. 断开链表，将其分为前（n-k个节点）、后（倒数k个节点）两个部分
    ListNode* newHead_prev = head;
    int i = n - k - 1;
    while (i--) {
        newHead_prev =  newHead_prev->next;
    }
    // 3. 将前半部分链表连在后半部分链表的末尾
    // newHead_prev->next就是新链表的头节点newhead，然后将newHead_prev->next置空断开前后部分的链表，再让tail->next=head将前面的链表接到后面去
    ListNode* newHead = newHead_prev->next;
    newHead_prev->next = nullptr;
    tail->next = head;
    return newHead;
}
```

**复杂度分析**

- 时间复杂度：O(n)  

- 空间复杂度：O(1)
