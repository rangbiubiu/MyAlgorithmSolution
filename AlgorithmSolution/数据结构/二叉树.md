# 目录

[TOC]



## :fire:[102. 二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/)

### 题意

给你二叉树的根节点 `root` ，返回其节点值的 **层序遍历**

**提示：**

- 树中节点数目在范围 `[0, 2000]` 内
- `-1000 <= Node.val <= 1000`

[图源自负雪明烛大佬](https://leetcode.cn/problems/binary-tree-level-order-traversal/solutions/244292/tao-mo-ban-bfs-he-dfs-du-ke-yi-jie-jue-by-fuxuemin)

![image-20240224134554808](https://cdn.jsdelivr.net/gh/rangbiubiu/picBed@main/202402241345861.png)

### 总

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> res;

    vector<vector<int>> levelOrder(TreeNode* root) {
        // =================== 递归 =================== 
        // 用res存放树层序遍历的结果
        // 记录每一层递归所处的深度,如果是第一次到这一层,那么在res中开辟一个新数组
        // 然后将其push_back到res中对应vector的末尾
        // dfs(root, 0);
        // return res;

        //  =================== 迭代 =================== 
        // 借助队列
        // 先将第一层(只有根节点)push到队列
        // 之后每次先获取当前que的大小(即一层的结点数), 设为size, 然后循环size次
        // 每次pop一个结点, 将这个结点存到res中该层对应的vector, 然后将这个结点的左右结点push到队列中
        if (root == nullptr) {
            return res;
        }
        queue<TreeNode*> que;
        que.push(root);
        while (!que.empty()) {
            int size = que.size();
            vector<int> floor;
            while (size--) {
                auto node = que.front(); que.pop();
                floor.push_back(node->val);
                if (node->left) {
                    que.push(node->left);
                }
                if (node->right) {
                    que.push(node->right);
                }
            }
            res.push_back(floor);
        }
        return res;
    }

    // void dfs(TreeNode* root, int depth) {
    //     // 递归结束条件
    //     if (root == nullptr) {
    //         return;
    //     }
    //     // 单层递归做啥事?将root存到其对应depth的vector
    //     if (res.size() <= depth) {
    //         // 说明是第一次到这一层,那么在res中开辟一个新数组
    //         res.push_back(vector<int>{});
    //     }  
    //     // 将其push_back到res中对应vector的末尾
    //     res[depth].push_back(root->val);
    //     bfs(root->left, depth + 1);
    //     bfs(root->right, depth + 1);
    // }
};
```



### 迭代 BFS

**:question:   problems:** 

1. 不知道怎么给 BFS 遍历的**结果**分层

:heavy_check_mark:  **answer:** 

2. 在每一层出队前，先记录队列中的结点数量 n，并创建一个vector用来存放这一层节点，然后一口气处理完这一层的 n 个结点，处理完之后这一层节点存在的vector push到res。

```c++
vector<vector<int>> levelOrder(TreeNode* root) {
    vector<vector<int>> res;
    if (root == nullptr) return res;
    queue<TreeNode*> que;
    // 迭代
    que.push(root);
    // 先序遍历节点, 一层一层进入弹出，弹出时如果该节点有子结点则将其子结点入队
    while (!que.empty()) {
        int size = que.size();
        vector<int> floor; //存放一层的节点
        while (size--) {
            TreeNode* p = que.front();
            que.pop();
            floor.push_back(p->val);
            if (p->left) que.push(p->left);
            if (p->right) que.push(p->right);
        }
        res.push_back(floor);          
    }
    return res;
}
```

**复杂度分析**

- 时间复杂度：O(n)  

- 空间复杂度：O(n)

### 递归 DFS 

**:small_red_triangle_down:  steps: **

1.  递归参数和返回值：

    - 参数：为了让递归的过程中同一层的节点放到同一个数组中，在递归时要记录每个节点的深度 depth
    - 返回值：void

2.  递归出口：深搜直到为空就返回

3.  单层递归要做什么事？

    1.  如果是第一次来这一层，则需要开辟一个存放该层结点的数组；

        > 第一次来这一层的标志是什么?
        >
        > - 第一次来第0层，res.size()=0，之后要为这一层开辟一个数组，因此res.size()变为1
        > - 第一次来第1层，res.size()=1，之后要为这一层开辟一个数组，因此res.size()变为2
        > - ········ 
        >
        > 由此可知，标志是: `res.size() == depth`    

    2. 将当前深搜的结点值存到对应层的数组中；

    2. 往下(左右子结点)继续深搜

**代码**

```c++
void dfs(TreeNode* p, vector<vector<int>>& res, int depth) {
        // 1.递归参数和返回值：void
        // 2.递归出口：深搜直到为空就返回
        if (p == nullptr) return;
        // 3.单层递归要做什么事？

        // (1)如果是第一次来这一层，则需要开辟一个存放该层结点的数组；
        if (res.size() <= depth) res.push_back(vector<int>());

        // (2) 将当前深搜的结点值存到对应层的数组中；
        res[depth].push_back(p->val);

        // (3) 往下(左右子结点)继续深搜
        dfs(p->left, res, depth + 1);
        dfs(p->right, res, depth + 1);
    }
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> res;
        if (root == nullptr) return res;
        dfs(root, res, 0);
        return res;
    }
```

**复杂度分析**

- 时间复杂度：O(n)  

- 空间复杂度：O(n)

## :fire:（102变形）[103. 二叉树的锯齿形层序遍历](https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/)

### 题意

给你二叉树的根节点 `root` ，返回其节点值的 **锯齿形层序遍历** 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。

**示例 1：**

![img](https://cdn.jsdelivr.net/gh/rangbiubiu/picBed@main/202402241415178.jpeg)

```
输入：root = [3,9,20,null,null,15,7]
输出：[[3],[20,9],[15,7]]
```

**示例 2：**

```
输入：root = [1]
输出：[[1]]
```

**示例 3：**

```
输入：root = []
输出：[]
```

**提示：**

- 树中节点数目在范围 `[0, 2000]` 内
- `-100 <= Node.val <= 100`

###  法一

使用 vector 或 deque 存放单层结点. (deque更好因为不需要reverse一整层来实现逆序)

- 使用 数组 时，当需要从右往左存结果时, reverse存放该层结点的数组再存
    - 因为队列是先进先出, 因此要从左往右遍历, 就需要先进左子再进右子
        那再要从右往左遍历, 是不是先进右子再进左子就可以了呢?
        不行!!!因为这样不能实现一整层都逆序, 只能是局部逆序.
        要从左往右再从右往左遍历, 那就只能在需要从右往左的时候将存的一整层结点reverse

- 使用 deque 时，存结果时若是从左往右, 则头插结果, 反之则尾插结果 


```c++
vector<vector<int>> zigzagLevelOrder(TreeNode* root) {
    vector<vector<int>> ans;
    if (root == nullptr) {
        return ans;
    }
    queue<TreeNode*> que;
    que.push(root);
    bool isOdd = false;
    while (!que.empty()) {
        int size = que.size();
        //// ======== 使用vector存放单层结点 ========
        //// 如果floor中存的是奇数层结点，则reverse floor后存进ans
        // vector<int> floor;
        // while (size--) {
        //     TreeNode* node = que.front(); que.pop();
        //     floor.push_back(node->val);
        //     if (node->left) {
        //         que.push(node->left);
        //     }
        //     if (node->right) {
        //         que.push(node->right);
        //     }
        // }
        // if (isOdd) {
        //     reverse(floor.begin(), floor.end());
        // }
        // ans.push_back(floor);
        // isOdd = !isOdd;


        // ======== 使用deque存放单层结点 ========
        // 如果当前遍历的是奇数层，则pop然后存节点到floor时，用push_front实现逆序
        deque<int> floor;
        while (size--) {
            TreeNode* node = que.front(); que.pop();
            if (isOdd) { //奇数层，逆序存结果(通过头插结果实现逆序)
                floor.push_front(node->val); 
            } else {
                floor.push_back(node->val);
            }
            if (node->left) {
                que.push(node->left);
            }
            if (node->right) {
                que.push(node->right);
            }
        }
        ans.push_back(vector<int>(floor.begin(), floor.end()));
        isOdd = !isOdd;
    }
    return ans;
}
```

### 法二

[参考题解](https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/solutions/1455763/jiu-zhi-yong-yi-ge-queue-dui-lie-by-wy-l-8u7s)

已知一层结点的数量, 那么pop存结果时就可以通过 **数组下标 **实现正序存结果和逆序存结果.

将`while (size--)` 改成`for (int i = 0; i < size; i++) `, 当需要从左往右存结果时就直接是`floor[i] = 结点值;`,  当需要从右往左存结果时就是`floor[size - 1 - i] = 结点值;`

```c++
vector<vector<int>> zigzagLevelOrder(TreeNode* root) {
    vector<vector<int>> ans;
    if (root == nullptr) {
        return ans;
    }
    queue<TreeNode*> que;
    que.push(root);
    bool isOdd = false;
    while (!que.empty()) {
        int size = que.size();
        vector<int> floor(size);
        for (int i = 0; i < size; ++i) {
            TreeNode* node = que.front(); que.pop();
            if (isOdd) {
                floor[size - i - 1] = node->val;
            } else {
                floor[i] = node->val;
            }
            if (node->left) {
                que.push(node->left);
            }
            if (node->right) {
                que.push(node->right);
            }
        }
        ans.push_back(floor);
        isOdd = !isOdd;
    }
    return ans;
}
```

**复杂度分析**

- 时间复杂度：O(n)  

- 空间复杂度：O(n)

## :fire:[104. 二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)

### 题意

给定一个二叉树 `root` ，返回其最大深度。

二叉树的 **最大深度** 是指从根节点到最远叶子节点的最长路径上的节点数。

**示例 1：**

![img](https://cdn.jsdelivr.net/gh/rangbiubiu/picBed@main/202402241305220.jpeg)

```
输入：root = [3,9,20,null,null,15,7]
输出：3
```

**示例 2：**

```
输入：root = [1,null,2]
输出：2
```

**提示：**

- 树中节点的数量在 `[0, 104]` 区间内。
- `-100 <= Node.val <= 100`

### 参考题解

1. [看到递归就晕？带你理解递归的本质！](https://www.bilibili.com/video/BV1UD4y1Y769/?share_source=copy_web&vd_source=8086e0fb4ccc0ee9410370076867092c)

### 递归 DFS

![image-20240224130800663](https://cdn.jsdelivr.net/gh/rangbiubiu/picBed@main/202402241308698.png)

```c++
int maxDepth(TreeNode* root) {
    // 1.递归参数和返回值：int
    // 2.递归出口：  
    if (root == nullptr) return 0;
    // 3.单层递归要做什么事？ ——求以root为根节点的树的深度。那就得知道其左右子树的深度
    int Ldepth = maxDepth(root->left);
    int Rdepth = maxDepth(root->right);
    return max(Ldepth, Rdepth) + 1;
}
```

**复杂度分析**

- 时间复杂度：O(n)  

- 空间复杂度：O(n)

###  迭代 BFS

层序遍历+队列

**代码**

```c++
int maxDepth(TreeNode* root) {
    if (root == nullptr) return 0;
    int res = 0;
    queue<TreeNode*> que;
    que.push(root);
    while (!que.empty()) {
        res++; //只要que不为空就说明还有至少一层
        int size = que.size();
        while (size--) {
            TreeNode* p = que.front(); que.pop();
            if (p->left) que.push(p->left);
            if (p->right) que.push(p->right);
        }
    }
    return res;
}
```

**复杂度分析**

- 时间复杂度：O(n)  

- 空间复杂度：O(n)



## [:fire:236. 二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)

### 题意

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

[百度百科](https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin)中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。”

**示例 1：**

![img](https://cdn.jsdelivr.net/gh/rangbiubiu/picBed@main/202402262226834.png)

```
输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出：3
解释：节点 5 和节点 1 的最近公共祖先是节点 3 。
```

**示例 2：**

![img](https://cdn.jsdelivr.net/gh/rangbiubiu/picBed@main/202402262226834.png)

```
输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
输出：5
解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。
```

**示例 3：**

```
输入：root = [1,2], p = 1, q = 2
输出：1
```

**提示：**

- 树中节点数目在范围 `[2, 105]` 内。
- `-109 <= Node.val <= 109`
- 所有 `Node.val` `互不相同` 。
- `p != q`
- `p` 和 `q` 均存在于给定的二叉树中。

### DFS 

经典递归

```c++
TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
    // 二叉树遍历顺序: 后序遍历
    // 递归结束条件: 
    if (root == p || root == q || root == nullptr) {
        return root;
    }
    // 单层递归：看p和q是否存在于自己部门,如果p和q都存在则将自己上报，如果只存在p和q中的一个，则上报有p/q的那个分部。
    TreeNode* lson = lowestCommonAncestor(root->left, p, q);
    TreeNode* rson = lowestCommonAncestor(root->right, p, q);
    // 函数返回值有几种情况：空，p，q，某个节点
    // 如果返回值不空，说明子树包含p或q，或者子树就是p,q的最近公共祖先
    // 由于是后序遍历，从下往上遍历时，一开始函数返回值都是空，只有遍历到了p或q之后函数返回值才不空。

    // 如果左右子树把p,q都包含了，则root就是最近公共祖先
    if (lson && rson) {
        return root;
    } else if (lson) {
        return lson;
    } else if (rson) {
        return rson;
    } else {
        return nullptr;
    }
}
```

#### 复杂度分析

- 时间复杂度：O(n)  

- 空间复杂度：O(n)

## [:fire:124. 二叉树中的最大路径和](https://leetcode.cn/problems/binary-tree-maximum-path-sum/)

### 题意

二叉树中的 **路径** 被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中 **至多出现一次** 。该路径 **至少包含一个** 节点，且不一定经过根节点。

**路径和** 是路径中各节点值的总和。

给你一个二叉树的根节点 `root` ，返回其 **最大路径和** 。

**示例 1：**

![img](https://cdn.jsdelivr.net/gh/rangbiubiu/picBed@main/202402281114828.jpeg)

```
输入：root = [1,2,3]
输出：6
解释：最优路径是 2 -> 1 -> 3 ，路径和为 2 + 1 + 3 = 6
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2020/10/13/exx2.jpg)

```
输入：root = [-10,9,20,null,null,15,7]
输出：42
解释：最优路径是 15 -> 20 -> 7 ，路径和为 15 + 20 + 7 = 42
```

**提示：**

- 树中节点数目范围是 `[1, 3 * 104]`
- `-1000 <= Node.val <= 1000`

### 参考题解

1. [我爱讨论区！！！](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/solution/shou-hui-tu-jie-hen-you-ya-de-yi-dao-dfsti-by-hyj8/)

### DFS 

![image-20240228131310738](https://cdn.jsdelivr.net/gh/rangbiubiu/picBed@main/202402281313805.png)

<font color='red'>特别注意！！！本题结点值可为负！！！为了防止0把结果覆盖掉，需要：</font>

1. 注意递归结束条件中返回值！！返回0或INT_MIN都会比较麻烦。

    > :chestnut:如果root是值为负(设为-3)的叶子节点，则它应返回的noAddSum=-3。如果节点为空时返回0，那么该叶子节点计算noAddSum时，左右空节点返回的leftCanAdd(或rightCanAdd)为0 > root->val，会把真正的结果覆盖掉

2. 不可递归累加的最大路径和不能初始化为0。

> 这题和:fire:[543. 二叉树的直径](https://leetcode.cn/problems/diameter-of-binary-tree/) 主要的区别其中之一就是这。

```c++
class Solution {
public:
 /*
    root的最大路径和有几种可能：
    1. 左根，右根，根
    1. 左右根，左，右
    这两种分别对应了 可向上累加的路径和、不可向上累加的路径和。
    其中，可向上累加的最大路径和需要返回给上面的节点。

    因此整体思路：
    从下往上遍历，可向上累加的最大路径和通过返回值返回给上面，不可向上累加的最大路径和可以用一个类变量表示。
*/ 
    int NoAddUpSum = INT_MIN; //【不可递归累加】的最大路径和,不能初始化为0
    
    int dfs(TreeNode* root) {
        // 1.遍历顺序：后序遍历, 要根据左右子的最大路径和才能知道root的··
        // 2.返回值是以root为根的子树 可向上累加的最大路径和
        // 3.结束条件：因为结点可能值为负, 因此不能return 0 !!!
        if (root == nullptr) return -2000;
        // 4.单层递归: 统计 可向上累加的最大路径和 和 不可向上累加的最大路径和,并返回可向上累加最大的路径和
        int LeftAddUpSum = dfs(root->left);  //左
        int RightAddUpSum = dfs(root->right);//右
        // 中.【可递归累加】的最大路径和
        int AddUpSum =  root->val + max({0, LeftAddUpSum, RightAddUpSum});
        // 中.【不可递归累加】的最大路径和
        NoAddUpSum = max({NoAddUpSum, root->val + LeftAddUpSum + RightAddUpSum, LeftAddUpSum, RightAddUpSum});
        return AddUpSum;
    }
    int maxPathSum(TreeNode* root) { 
        return max(NoAddUpSum, dfs(root));
    }
};
```

而如果递归结束的条件是：`if (root == nullptr) return 0;`，则需要额外增加一些判断逻辑:

```c++
class Solution {
public:
    int NoAddUpSum = INT_MIN; 
    int dfs(TreeNode* root) {
        if (root == nullptr) return 0; 

        int left_addUp_max = dfs(root->left);
        int right_addUp_max = dfs(root->right);

        int AddUpSum = max({left_addUp_max, right_addUp_max, 0}) + root->val;
        int sum = root->val + max({left_addUp_max, 0}) + max({right_addUp_max, 0});
        NoAddUpSum = max(sum, NoAddUpSum);

        return AddUpSum;
    }
    int maxPathSum(TreeNode* root) {
        return max(NoAddUpSum, dfs(root));
    } 
};
```

**复杂度分析**

- 时间复杂度：O(n)  。因为每个结点只会遍历一次（从下往上归）。  
- 空间复杂度：O(n)

### FllowUp: 打印路径

待完成。。。

```cpp
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def maxPathSum(self, root: TreeNode) -> int:
        self.ans = -1000 # 或者 float("-inf") 
        self.path = [] # 存储路径
        self.dfs(root)
        print(self.path)
        return self.ans
    
    def dfs(self, root): # 返回从该根节点到叶节点最大路径和
        if root is None: return 0, []
        left, leftPath = self.dfs(root.left)
        right, rightPath = self.dfs(root.right)
        
        if root.val + left + right > self.ans:
            self.ans = root.val + left + right
            self.path = leftPath + [root.val] + rightPath

        if left > 0 and left > right:
            res = left + root.val
            path = leftPath + [root.val]
        elif right > 0 and right > left:
            res = right + root.val
            path = [root.val] + rightPath 
        else:
            res = root.val
            path = [root.val]
            
        if self.ans < res: 
            self.ans = res
            self.path = path
            
        return res, path # res 是路径和，path 是路径数组
```



## :fire:[543. 二叉树的直径](https://leetcode.cn/problems/diameter-of-binary-tree/)

### 题意

给你一棵二叉树的根节点，返回该树的 **直径** 。

二叉树的 **直径** 是指树中任意两个节点之间最长路径的 **长度** 。这条路径可能经过也可能不经过根节点 `root` 。

两节点之间路径的 **长度** 由它们之间边数表示。

**示例 1：**

![img](https://cdn.jsdelivr.net/gh/rangbiubiu/picBed@main/202402281626466.jpeg)

```
输入：root = [1,2,3,4,5]
输出：3
解释：3 ，取路径 [4,2,1,3] 或 [5,2,1,3] 的长度。
```

**示例 2：**

```
输入：root = [1,2]
输出：1
```

**提示：**

- 树中节点数目在范围 `[1, 104]` 内
- `-100 <= Node.val <= 100`

### 参考题解

1. 和上一题 [:fire:124. 二叉树中的最大路径和](https://leetcode.cn/problems/binary-tree-maximum-path-sum/) 几乎没差，只不过这个是求边的个数而不是结点个数。

### DFS 

```c++
class Solution {
public:
    int maxLen = 0;//不可往上递归累加的最长路径长度
    int dfs(TreeNode* root) {
        // 遍历顺序：后序遍历, 要根据左右子的最长路径才能计算root的 
        // 返回值是可递归累加的最长路径长度
        if (root == nullptr) return -1;
        int leftMaxLen = dfs(root->left);//包含root->left的、可往上递归累加的最长路径长度
        int rightMaxLen = dfs(root->right);
        // 【不往上递归累加】的最长路径 = 根左右
        maxLen = max(maxLen, 2 + leftMaxLen + rightMaxLen);
        // 【可往上递归累加】的最长路径 = max(根左,根右)，作为返回值
        return 1 + max(leftMaxLen, rightMaxLen);
    }
    int diameterOfBinaryTree(TreeNode* root) {
        return max(maxLen, dfs(root));
    }
};
```

**复杂度分析**

- 时间复杂度：O(n)。因为每个结点只会遍历一次（从下往上归）。  

- 空间复杂度：O(n)

## :fire:[94. 二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/) 

### 题意

给定一个二叉树的根节点 `root` ，返回 *它的 **中序** 遍历* 。

**示例 1：**

![img](https://cdn.jsdelivr.net/gh/rangbiubiu/picBed@main/202402291030016.jpeg)

```
输入：root = [1,null,2,3]
输出：[1,3,2]
```

**示例 2：**

```
输入：root = []
输出：[]
```

**示例 3：**

```
输入：root = [1]
输出：[1]
```

**提示：**

- 树中节点数目在范围 `[0, 100]` 内
- `-100 <= Node.val <= 100`

**进阶:** 递归算法很简单，你可以通过迭代算法完成吗？

### 参考题解

1. 迭代的颜色标记法：[henry](https://leetcode.cn/problems/binary-tree-inorder-traversal/solutions/25220/yan-se-biao-ji-fa-yi-chong-tong-yong-qie-jian-ming)

### 递归

```c++
class Solution {
public:  
    vector<int> res;
    void dfs(TreeNode* root) {
        if (root == nullptr) return;
        dfs(root->left);
        res.push_back(root->val);
        dfs(root->right);
    }
    vector<int> inorderTraversal(TreeNode* root) {
        dfs(root);
        return res;
    }
};
```

**复杂度分析**

- 时间复杂度：O(n)  

- 空间复杂度：O(n)

### 迭代

==:star: **核心思路：颜色标记法  **:star:==  如要实现前序、后序遍历，只需要调整左右子节点的入栈顺序即可

**:key:  key：**

- ![image-20240229130423581](https://cdn.jsdelivr.net/gh/rangbiubiu/picBed@main/202402291304638.png)

- 即第一次走到根的时候，先不将其放入结果，先存到栈中等着（同时将其左右子都push进栈）；
    等到其左子树的所有节点都出栈之后，根在紧跟着出来。![image-20240309183245679](https://cdn.jsdelivr.net/gh/rangbiubiu/picBed@main/202403091832743.png)

#### 代码

```c++
vector<int> inorderTraversal(TreeNode* root) {
    const int WHITE = 0; //【隐忍不发】走过该节点，但走完它后只是将其暂存在了栈中
    const int GREY  = 1; //【出头之日】如果访问到某节点时它是灰色，那它就要存入结果了

    vector<int> res;
    stack<pair<int, TreeNode*>> st;
    st.push({WHITE, root});
    
    while (!st.empty()) { 
        auto [color, node] = st.top();  st.pop();
        if (node == nullptr) continue;
        // 节点【隐忍不发】，将其以及左右孩入栈
        if (color == WHITE) { 
            st.push({WHITE, node->right}); 
            st.push({GREY, node});
            st.push({WHITE, node->left});
        } else {  
        // 节点【出头之日】，存入结果
            res.push_back(node->val);
        }
    }
    return res;
}
```

#### 复杂度分析

- 时间复杂度：O(2n)，即O(n)  

- 空间复杂度：O(n)

## :fire:[105. 从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

### 题意

给定两个整数数组 `preorder` 和 `inorder` ，其中 `preorder` 是二叉树的**先序遍历**， `inorder` 是同一棵树的**中序遍历**，请构造二叉树并返回其根节点。

**示例 1:**

![img](https://cdn.jsdelivr.net/gh/rangbiubiu/picBed@main/202403032226914.jpeg)

```
输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
输出: [3,9,20,null,null,15,7]
```

**示例 2:**

```
输入: preorder = [-1], inorder = [-1]
输出: [-1]
```

**提示:**

- `1 <= preorder.length <= 3000`
- `inorder.length == preorder.length`
- `-3000 <= preorder[i], inorder[i] <= 3000`
- `preorder` 和 `inorder` 均 **无重复** 元素
- `inorder` 均出现在 `preorder`
- `preorder` **保证** 为二叉树的前序遍历序列
- `inorder` **保证** 为二叉树的中序遍历序列

### 第一种、未优化的版本

==:star: **核心思路：递归分治   **:star:==

**:key:  key：**

分治法的思想：**把原问题拆解成若干个与原问题结构相同但规模更小的子问题，待子问题解决以后，原问题就得以解决。**

原问题：构建一个二叉树需要构建三部分：root、左子树、右子树
子问题：左子树、右子树的构建，又包括：root、左子树、右子树

解题关键在于==定位出根节点，划分出左右子树，然后 递归构建左右子树，返回该根节点的构建结果==（向上归）。

**:small_red_triangle_down:  steps: **

1.  切割中序序列和先序序列，得到根节点的左右子树的中序序列和先序序列。
    - 先要找到根，怎么找？先序序列的首元素就是根的值。由于序列中无重复元素，因此直接拿着 root->val 去找其在中序序列中的位置。
    - 该位置将中序序列分成三部分（左根右）。至此，中序序列切割成功，还差先序序列。
    - 用切割得到的中序序列左区间的大小，去切割先序序列。至此，先序序列也切割成功。
1.  递归构建左右子树
1.  向上级返回自己的构建结果

#### 代码

带step注释版：

```c++
TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
    if (preorder.size() == 0) return nullptr;
    //1、用先序找到根节点的值
    int rootValue = preorder[0];
    TreeNode* root = new TreeNode(rootValue); 
    if (preorder.size() == 1) return root;
    //2、利用先序得到的根的值在中序中找到根的位置
    int i = 0;
    while (inorder[i] != rootValue) i++;
    //3、利用根的位置i切割中序: [0,i) i [i+1,end)
    vector<int> leftInorder(inorder.begin(), inorder.begin() + i);
    vector<int> rightInorder(inorder.begin() + i + 1, inorder.end());
    //4、利用中序的左区间大小[0,i)=i切割先序: [1,i+1) [i+1,end)
    vector<int> leftPreorder(preorder.begin() + 1, preorder.begin() + i + 1);
    vector<int> rightPreorder(preorder.begin() + i + 1, preorder.end()); 
    //5、递归构建左右子树
    root->left = buildTree(leftPreorder, leftInorder); 
    root->right = buildTree(rightPreorder, rightInorder); 
    //6、向上级返回自己的构建结果
    return root;
}
```

带递归三部曲注释版：

```c++
TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
    // 1、递归参数以及返回值：参数(先序和中序序列)、返回值(结点)
    // 2、递归结束的条件
    if (preorder.size() == 0) return nullptr;
    int rootValue = preorder[0];
    TreeNode* root = new TreeNode(rootValue); 
    if (preorder.size() == 1) return root;
    // 3、单层递归逻辑：该根节点(preorder[0])需要构建其树，并将其成果交给上头 
    // (1) 切割
    int i = 0;
    while (inorder[i] != rootValue) i++; 
    vector<int> leftInorder(inorder.begin(), inorder.begin() + i);			 //左中序
    vector<int> rightInorder(inorder.begin() + i + 1, inorder.end()); 		 //右中序
    vector<int> leftPreorder(preorder.begin() + 1, preorder.begin() + i + 1);//左先序
    vector<int> rightPreorder(preorder.begin() + i + 1, preorder.end()); 	 //右先序 
    // (2) 递归构建左右子树（解决子问题）
    root->left = buildTree(leftPreorder, leftInorder); 
    root->right = buildTree(rightPreorder, rightInorder);
    // (3) 向上归
    return root;
}
```

#### 复杂度分析

- 时间复杂度：O(n^2^)  每次递归就会创建一个新节点，需要创建n个结点，因此递归n次，每一次递归的时间复杂度是O(n)。因此总时间复杂度是O(n^2^)。

- 空间复杂度：O(n)。

### 第二种、优化后的版本

>  优化一、
>
>  问题：每次都要扫描中序遍历找根节点，时间复杂度较高。
>
>  办法：可以使用哈希表O(1)快速定位根节点。选择使用哈希map进行哈希映射，key为值，value为其在中序遍历中的出现位置，在构造二叉树之前遍历一遍中序遍历，就可以构造出哈希映射，往后构造的过程中就只需要O(1)的时间就能快速在中序中定位根节点
>
>  优化二、
>
>  问题：每次递归都需要拷贝中序数组和前序数组的左右区间，时间复杂度高。
>
>  办法：可以在函数中传下标表示区间范围，这样就不需要多次拷贝容器了 

这道题的思路用一下图片即可说明：

<img src="https://cdn.jsdelivr.net/gh/rangbiubiu/picBed@main/202404172053634.webp" alt="图片" style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/rangbiubiu/picBed@main/202404172053205.webp" alt="图片" style="zoom:50%;" />

> [详细思路可以看这里](https://mp.weixin.qq.com/s/OlpaDhPDTJlQ5MJ8tsARlA)

#### 代码

```cpp
class Solution {
public:
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
    /*
        先通过先序遍历获取根节点的值，将根节点添加到构造的二叉树中，
        然后根据该值找到根节点在中序遍历中的位置(哈希查找，每次查找的时间复杂度就是O(1))
        以该位置切割中序序列，得到左右子的中序序列，利用其中一个区间的长度切割先序序列得到左右子的先序序列
    */ 
        unordered_map<int, int> umap;
        for (int i = 0; i < inorder.size(); ++i) {
            umap[inorder[i]] = i;
        }
        return bulid(umap, preorder, inorder, 0, preorder.size() - 1, 0);
    }
    TreeNode* bulid(unordered_map<int, int>& umap, vector<int>& preorder, vector<int>& inorder, int preLeft, int preRight, int inLeft) { // 左闭右闭区间
        // 2、递归结束的条件
        if (preLeft > preRight) {
            return nullptr;
        }
        // 3、单层递归逻辑：该根节点(preorder[0])需要构建其树，并将其成果交给上头 
        int rootVal = preorder[preLeft]; 
        TreeNode* node = new TreeNode(rootVal);
        if (preLeft == preRight) {
            return node;
        }
        int i = umap[rootVal];
        // 中序区间 [inLeft, i) i [i+1, ]
        int leftSize = i - inLeft; 
        // 先序区间 preLeft [preLeft + 1, leftSize + preleft] [leftSize + preleft + 1, preRight]
        // (2) 递归构建左右子树（解决子问题） 
        node->left = bulid(umap, preorder, inorder, preLeft + 1, leftSize + preLeft, inLeft);
        node->right = bulid(umap, preorder, inorder, leftSize + preLeft + 1, preRight, i + 1);

        // (3) 向上归
        return node;
    } 
};
```

#### 复杂度分析

- 时间复杂度：O(n)  

- 空间复杂度：O(n)

## :fire:[129. 求根节点到叶节点数字之和](https://leetcode.cn/problems/sum-root-to-leaf-numbers/)

### 题意

给你一个二叉树的根节点 `root` ，树中每个节点都存放有一个 `0` 到 `9` 之间的数字。

每条从根节点到叶节点的路径都代表一个数字：例如，从根节点到叶节点的路径 `1 -> 2 -> 3` 表示数字 `123` 。

计算从根节点到叶子节点生成的 **所有数字之和** 。 

**示例 1：**

![img](https://cdn.jsdelivr.net/gh/rangbiubiu/picBed@main/202406151028767.jpeg)

```
输入：root = [1,2,3]
输出：25
解释：
从根到叶子节点路径 1->2 代表数字 12
从根到叶子节点路径 1->3 代表数字 13
因此，数字总和 = 12 + 13 = 25
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/02/19/num2tree.jpg)

```
输入：root = [4,9,0,5,1]
输出：1026
解释：
从根到叶子节点路径 4->9->5 代表数字 495
从根到叶子节点路径 4->9->1 代表数字 491
从根到叶子节点路径 4->0 代表数字 40
因此，数字总和 = 495 + 491 + 40 = 1026
```

**提示：**

- 树中节点的数目在范围 `[1, 1000]` 内
- `0 <= Node.val <= 9`
- 树的深度不超过 `10`

### 参考题解

1. [官解](https://leetcode.cn/problems/sum-root-to-leaf-numbers/solutions/464666/qiu-gen-dao-xie-zi-jie-dian-shu-zi-zhi-he-by-leetc)

### 递归

```cpp
class Solution {
public:
// 回溯.
// 用什么存当前路径的数字呢？往下递归以及回溯时怎么处理. 通过传参的方式传递数字.
    int ans = 0;

    int sumNumbers(TreeNode* root) {
        backTracking(root, root->val);
        return ans;
    }
    void backTracking(TreeNode* root, int val) {
        // val表示当前路径的数字，那是否需要包含root的值呢？包含.(不包含也可以，只不过我觉得包含的写法会简洁一点点)
        // 递归结束条件
        if (!root->left && !root->right) {
            ans += val;
            return;
        }
        // 单层递归
        if (root->left) {
            backTracking(root->left, val * 10 + root->left->val);
        }
        if (root->right) {
            backTracking(root->right, val * 10 + root->right->val);
        }
    }
};
```

### 非递归

```cpp
class Solution {
public:
    int sumNumbers(TreeNode* root) {
    /*
        BFS
        维护两个队列，分别存放 结点node 和 当前以该结点结束的路径的和sum
        如果遍历到叶子节点，则将其对应的sum加到ans中，并弹出这个node
        否则，计算更新sum，将这个node和对应的sum分别push到两个队列
    */ 
        if (root == nullptr) {
            return 0;
        }
        int ans = 0;
        queue<TreeNode*> nodeQue;
        queue<int> sumQue;
        nodeQue.push(root);
        sumQue.push(root->val);
        while (!nodeQue.empty()) {
            TreeNode* node = nodeQue.front(); nodeQue.pop();
            int sum = sumQue.front(); sumQue.pop();
            // 计算node的左右子的sum
            // 如果node是叶子节点则直接将其对应的sum加到ans中
            if (!node->left && !node->right) {
                ans += sum;
                continue;
            }
            if (node->left) {
                nodeQue.push(node->left);
                sumQue.push(sum * 10 + node->left->val);
            }
            if (node->right) {
                nodeQue.push(node->right);
                sumQue.push(sum * 10 + node->right->val);
            }
        }
        return ans;
    }
};
```



## :fire:[110. 平衡二叉树](https://leetcode.cn/problems/balanced-binary-tree/)

### 题意

给定一个二叉树，判断它是否是平衡二叉树。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/10/06/balance_1.jpg)

```
输入：root = [3,9,20,null,null,15,7]
输出：true
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2020/10/06/balance_2.jpg)

```
输入：root = [1,2,2,3,3,null,null,4,4]
输出：false
```

**示例 3：**

```
输入：root = []
输出：true
```

 **提示：**

- 树中的节点数在范围 `[0, 5000]` 内
- `-104 <= Node.val <= 104`

### 代码

```cpp
class Solution {
public:
    bool isBalanced(TreeNode* root) {
    /*
        平衡二叉树：左右子树的高度差<=1
        对于每个结点，它是不知道其下子树的高度的，自然也不知道它们的高度差
        那怎么让它们知道呢？—— 递归函数通过返回值告诉上层自己的高度。因此是后序遍历。

        但是如果在遍历过程中发现了某棵子树不平衡，怎么让其上层知道整棵树已经不平衡了呢？返回值已经用来表示子树的高度了。
        —— 仍可以通过返回值表示！因为子树高度总为正，我们可以设定返回-1表示子树不平衡。
    */ 
        return dfs(root) != -1;
    }
    int dfs(TreeNode* root) {
        // 递归结束条件
        if (!root) {
            return 0;
        }
        // 单层递归：获取左右子树的高度，并判断自己是否平衡，最后返回自己的高度
        // 注意如果左/右子树不平衡那么直接return -1
        int leftHight = dfs(root->left);
        if (leftHight == -1) {
            return -1;
        }
        int rightHight = dfs(root->right);
        if (rightHight == -1) {
            return -1;
        }
        if (abs(leftHight - rightHight) > 1) {
            return -1;
        }
        return max(leftHight, rightHight) + 1;
    }
};
```



## :fire:[101. 对称二叉树](https://leetcode.cn/problems/symmetric-tree/)

### 题意

给你一个二叉树的根节点 `root` ， 检查它是否轴对称。

**示例 1：**

![img](https://cdn.jsdelivr.net/gh/rangbiubiu/picBed@main/202403080842063.png)

```
输入：root = [1,2,2,3,4,4,3]
输出：true
```

**示例 2：**

![img](https://pic.leetcode.cn/1698027008-nPFLbM-image.png)

```
输入：root = [1,2,2,null,3,null,3]
输出：false
```

 

**提示：**

- 树中节点数目在范围 `[1, 1000]` 内
- `-100 <= Node.val <= 100`

**进阶：**你可以运用递归和迭代两种方法解决这个问题吗？

### 递归

首先想清楚判断对称二叉树要比较的是什么，不是左孩子和右孩子是否相等，而是左右子的外侧是否相等，内侧是否相等。

![SmartSelect_20240308_103113_Samsung Notes](https://cdn.jsdelivr.net/gh/rangbiubiu/picBed@main/202403081033138.jpg)

#### 代码

```c++
bool compare(TreeNode* leftNode, TreeNode* rightNode){
    /* 1.递归参数及返回值：
        由于判断二叉树是否对称比较的是左右子的外侧是否相等，内侧是否相等，
        因此需要传左右子结点进来比较，而不能只传一个root */
    // 2.终止条件: 含空节点 || 数值不相同
    if (!leftNode && !rightNode) {
        return true;
    } else if (!leftNode || !rightNode) {
        return false;
    } else if (leftNode->val != rightNode->val) {
        return false;
    }
    // 3.单层递归做啥事？
    // 让下级判断leftNode的外侧与rightNode的外侧是否相等，内侧与内侧是否相等
    // 自己再汇总结果并上交
    bool outside = compare(leftNode->left, rightNode->right);
    bool inside = compare(leftNode->right, rightNode->left);
    return outside && inside;
}
bool isSymmetric(TreeNode* root) {
    if (root == nullptr) return true;
    return compare(root->left, root->right);
}
```

#### 复杂度分析

- 时间复杂度：O(n)  

- 空间复杂度：O(n)

### 迭代

 ![image-20240308103319676](https://cdn.jsdelivr.net/gh/rangbiubiu/picBed@main/202403081033725.png)

注意不要push(root)进去！！！

#### 代码

```c++
bool isSymmetric(TreeNode* root) {
    if (root == nullptr) return true;
    queue<TreeNode*> que;
    que.push(root->left); 
    que.push(root->right); 
    while (!que.empty()) {
        TreeNode* leftNode  = que.front();  que.pop();
        TreeNode* rightNode = que.front();  que.pop();

        if (!leftNode && !rightNode) continue;
        if (!leftNode || !rightNode) return false;
        if (leftNode->val != rightNode->val) return false;
        
        que.push(leftNode->left);
        que.push(rightNode->right); 
        que.push(leftNode->right); 
        que.push(rightNode->left);
    }
    return true;
}
```

#### 复杂度分析

- 时间复杂度：O(n)  

- 空间复杂度：O(n)

## :fire:[98. 验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/)

### 题意

给你一个二叉树的根节点 `root` ，判断其是否是一个有效的二叉搜索树。

**有效** 二叉搜索树定义如下：

- 节点的左子树只包含小于当前节点的数。
- 节点的右子树只包含 **大于** 当前节点的数。
- 所有左子树和右子树自身必须也是二叉搜索树。

 **示例 1：**

![img](https://cdn.jsdelivr.net/gh/rangbiubiu/picBed@main/202403090853916.jpeg)

```
输入：root = [2,1,3]
输出：true
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg)

```
输入：root = [5,1,4,null,null,3,6]
输出：false
解释：根节点的值是 5 ，但是右子节点的值是 4 。
```

**提示：**

- 树中节点数目范围在`[1, 104]` 内
- `-231 <= Node.val <= 231 - 1`

### 法一

==:star: **核心思路：用BST性质先序遍历**:star:==

该题必须用long表示正无穷和负无穷。

**:x: careless | ignore :**

- 不能单纯的比较 左结点小于根&&右结点大于根 就完事了。这样最多只能判断当前三个结点是符合BST性质的，但是整个子树不一定符合。相当于是只向上交了自己做的事，但是没有把下级做的事上交。

    ————我们要比较的是 左子树**所有节点**小于根，右子树**所有节点**大于根。

```c++
class Solution {
public:
    bool preTraversal(TreeNode* root, long root_lowerBound, long root_upperBound) { 
        // BST满足 左 < 根 < 右
        if (root == nullptr) return true; 
        // 1.自己干的活
        bool base = root_lowerBound < root->val && root->val < root_upperBound;
        if (!base) return false;
        // 2.下属干的活
        bool is_leftVaild  = preTraversal(root->left, root_lowerBound, root->val);
        bool is_rightVaild = preTraversal(root->right, root->val, root_upperBound);
        // 3.将结果交给上级
        return is_leftVaild && is_rightVaild;
    } 
    bool isValidBST(TreeNode* root) { 
        return preTraversal(root, LONG_MIN, LONG_MAX);
    }
};
 
```

优化（用&&将三个条件连接起来的话，若第一个条件不满足则后面两个条件就不会再去判断，也就不会再进行后面的递归），但是可读性就没那么好

```c++
bool preTraversal(TreeNode* root, long left, long right) {  
    if (root == nullptr) return true;
    long mid = root->val;
    return root_lowerBound < mid && mid < root_upperBound
     && preTraversal(root->left, root_lowerBound, mid)
     && preTraversal(root->right, mid, root_upperBound);
}  
```

**复杂度分析**

- 时间复杂度：O(n)  

- 空间复杂度：O(n)

### 法二（看这个就行）

==:star: **核心思路： BST中序序列性质：升序  **:star:==

**:key:  key：**

- 二叉搜索树「中序遍历」得到的值构成的序列一定是升序的，这启示我们在中序遍历的时候实时检查当前节点的值是否大于前一个中序遍历到的节点的值（记为lastIsMax）即可。如果不大于说明当前结点的左子树中出现了比自己还大的，直接return false.

#### 递归代码

##### 正确写法1

```c++
class Solution {
public:
    long lastIsMax = LONG_MIN; //记录目前为止中序遍历已遍历的最后一个值
     //若初始化为INT_MIN，则当树只有一个节点且节点值=INT_MIN时，由于lastVal==root->val，会返回false
    bool isValidBST(TreeNode* root) {
        // 利用BST左中右单调递增的性质,一旦递增被破坏,就return false;
        // 中序遍历时不断更新lastIsMax，一旦发现lastIsMax >= root->val，就返回false
        if (!root) return true;
        // 左
        if (!isValidBST(root->left)) return false;
        // 中，更新lastIsMax为当前root值
        if (root->val <= lastIsMax) return false;
        lastIsMax = root->val;
        // 右
        // if (!isValidBST(root->right)) return false;
        // // 下面这句可写可不写，但是一定不能写成 >= 
        // if (root->val > lastIsMax) return false;
        // return true; 
        
        // 上面三行可以写成一行
        return isValidBST(root->right); 
    }
};
```

> 关于这一句`if (root->val > lastIsMax) return false;`
>
> 1. 为什么说这句可写可不写？
>     - 因为实际在上一步isValidBST(root->right)就已经做了这一步判断
> 2. 为什么不能写成大于等于？
>     - 因为当root是叶子节点时，它执行isValidBST(root->right)是return的，lastIsMax仍=root->val，此时不能return false;

##### 递归优化

如果测试用例中有比LONG_MIN还小的值怎么办呢？因此建议避免 初始化最小值，而是取到最左节点的数值来比较

```c++
class Solution {
public:
    TreeNode* prev = nullptr;
    //若初始化为INT_MIN，则当树只有一个节点且节点值=INT_MIN时，由于lastVal==root->val，会返回false
    bool isValidBST(TreeNode* root) {
        // 利用BST左中右单调递增的性质,一旦递增被破坏,就return false;
        // 中序遍历时不断更新lastIsMax，一旦发现lastIsMax >= root->val，就返回false
        if (!root) return true;
        // 左
        if (!isValidBST(root->left)) return false;
        // 中
        if (prev != nullptr && root->val <= prev->val) return false;
        prev = root;
        // 右
        return isValidBST(root->right); 
    }
};
```

#### 迭代代码

用栈来模拟中序遍历的过程。

##### 一、颜色标记法

```c++
bool isValidBST(TreeNode* root) {
    const int WHITE = 0; //【隐忍不发】走过该节点，但那时它只是暂存在栈中
    const int GREY  = 1; //【出头之日】如果访问到某节点时它是灰色，那它就要存入结果了

    long lastIsMax = LONG_MIN; //当前中序序列的最后一个节点的值
    stack<pair<int, TreeNode*>> st;
    st.push({WHITE, root});
    
    while (!st.empty()) { 
        auto [color, node] = st.top();  st.pop();

        if (node == nullptr) continue;
        
        // 该节点【隐忍不发】，将其以及左右孩入栈
        if (color == WHITE) { 
            st.push({WHITE, node->right}); 
            st.push({GREY, node});
            st.push({WHITE, node->left});
        } else {  
        // 该节点【出头之日】，存入结果
            if (node->val <= lastIsMax) {
                return false;
            }
            // 实时更新中序序列的最后一个结点 lastIsMax
            lastIsMax = node->val;
        }
    }
    return true;
}
```

#####  二、传统中序写法

```c++
bool isValidBST(TreeNode* root) { 
    long lastIsMax = LONG_MIN; //当前中序序列的最后一个节点的值
    stack<TreeNode*> st;
    TreeNode* cur = root;
    while(!st.empty() || cur) {
        // 一路向左压栈直到最左
        while (cur) {
            st.push(cur);
            cur = cur->left;//左
        }
        cur = st.top(); st.pop();//中
        if (cur->val <= lastIsMax) {
            return false;
        }
        lastIsMax = cur->val;
        cur = cur->right;//右
    }
    return true;
}
```

同递归一样可以优化：

```c++
class Solution {
public: 
    TreeNode* pre = nullptr;//当前中序序列的最后一个节点
	bool isValidBST(TreeNode* root) {
        stack<TreeNode*> st;
        TreeNode* cur = root;
        while(!st.empty() || cur) {
            while (cur) {
                st.push(cur);
                cur = cur->left;//左
            }
            cur = st.top(); st.pop();//中
            if (pre && pre->val >= cur->val) {
                return false;
            }
            pre = cur;
            cur = cur->right;//右
        }
        return true;
    }
}
```

**复杂度分析**

- 时间复杂度：O(n)  

- 空间复杂度：O(n)

## :fire:[662. 二叉树最大宽度](https://leetcode.cn/problems/maximum-width-of-binary-tree/)

### 题意

给你一棵二叉树的根节点 `root` ，返回树的 **最大宽度** 。

树的 **最大宽度** 是所有层中最大的 **宽度** 。

每一层的 **宽度** 被定义为该层最左和最右的非空节点（即，两个端点）之间的长度。将这个二叉树视作与满二叉树结构相同，两端点间会出现一些延伸到这一层的 `null` 节点，这些 `null` 节点也计入长度。

题目数据保证答案将会在 **32 位** 带符号整数范围内。

 **示例 1：**

![img](https://cdn.jsdelivr.net/gh/rangbiubiu/picBed@main/202407061201033.jpeg)

```
输入：root = [1,3,2,5,3,null,9]
输出：4
解释：最大宽度出现在树的第 3 层，宽度为 4 (5,3,null,9) 。
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2022/03/14/maximum-width-of-binary-tree-v3.jpg)

```
输入：root = [1,3,2,5,null,null,9,6,null,7]
输出：7
解释：最大宽度出现在树的第 4 层，宽度为 7 (6,null,null,null,null,null,7) 。
```

**示例 3：**

![img](https://assets.leetcode.com/uploads/2021/05/03/width3-tree.jpg)

```
输入：root = [1,3,2,5]
输出：2
解释：最大宽度出现在树的第 2 层，宽度为 2 (3,2) 。
```

 **提示：**

- 树中节点的数目范围是 `[1, 3000]`
- `-100 <= Node.val <= 100`

### 参考题解

1. 

### 思路

对节点进行编号。从0开始和从1开始编号都行，若从0开始编号，则编号为index的节点，其左子编号为2×index+1，右子编号为 2×index+2。

假设从1开始编号，则编号为index的节点，其左子编号为2×index，右子编号为 2×index+1。
每层宽度 = 每层节点的最大编号 - 最小编号 + 1。



要防止编号溢出，有两种方法：

1. 将编号设置为ULL（unsigned long long）类型。
2. 重编号



#### ULL防溢出

##### 广度优先

遍历节点时，可以用广度优先搜索来遍历每一层的节点，并对比每一层的宽度和最大宽度。

```c++
using ULL = unsigned long long;
class Solution {
public:
    unordered_map<int, ULL> levelMin;
    
    int widthOfBinaryTree(TreeNode* root) { 
        ULL res = 1;
        vector<pair<TreeNode *, ULL>> arr;//记录结点以及编号
        arr.emplace_back(root, 1);
        while (!arr.empty()) {
            vector<pair<TreeNode *, ULL>> floor;//用来存放arr中结点的下一层结点及其编号
            for (auto &[node, index] : arr) {
                if (node->left) {
                    floor.emplace_back(node->left, index * 2);
                }
                if (node->right) {
                    floor.emplace_back(node->right, index * 2 + 1);
                }
            }
            res = max(res, arr.back().second - arr[0].second + 1);
            arr = move(floor);
        }
        return res;
    } 
};
```

**复杂度分析**

- 时间复杂度：O(n)，其中 n 是二叉树的节点个数。需要遍历所有节点。

- 空间复杂度：O(n)。

##### 深度优先

用一个unordered_map存放每一层结点的最小编号，即key为depth, value为index

```c++
using ULL = unsigned long long;
class Solution {
public:
    unordered_map<int, ULL> levelMin;
    ULL ans; 

    int widthOfBinaryTree(TreeNode* root) {
        dfs(root, 1, 1);
        return ans; 
    }
    void dfs(TreeNode* node, int depth, ULL index) { 
        // 1.递归参数及返回值：
        // 参数：当前遍历节点为node，node的深度为depth，node的编号为index
        // 返回值：返回目前的最大宽度
        
        // 2.递归结束条件
        if (node == nullptr) {
            return;
        }
        
        // 3.单层递归做什么事
        if (!levelMin.count(depth)) {
            levelMin[depth] = index;
        }
        ans = max(ans, index - levelMin[depth] + 1);
        dfs(node->left, depth + 1, index * 2);
        dfs(node->right, depth + 1, index * 2 + 1);
    }
};
```

**复杂度分析**

- 时间复杂度：O(n)。

- 空间复杂度：O(n)。

#### 重编号防溢出

##### 广度优先

```cpp
class Solution {
public:
    unordered_map<int, int> levelMin;
    
    int widthOfBinaryTree(TreeNode* root) { 
        int res = 1;
        vector<pair<TreeNode *, int>> arr;//记录结点以及编号
        arr.emplace_back(root, 1);
        while (!arr.empty()) {
            vector<pair<TreeNode *, int>> floor;//用来存放arr中结点的下一层结点及其编号
            for (auto &[node, index] : arr) {
                index = index - arr.back().second + 1;
                //重编号使得同层最靠左的非空节点编号为1，消除编号溢出问题
                if (node->left) {
                    floor.emplace_back(node->left, index * 2);
                }
                if (node->right) {
                    floor.emplace_back(node->right, index * 2 + 1);
                }
            }
            res = max(res, arr.back().second - arr[0].second + 1);
            arr = move(floor);
        }
        return res;
    } 
};
```

##### 深度优先

```cpp
class Solution {
public:
    unordered_map<int, int> levelMin;
    int ans;
    
    int widthOfBinaryTree(TreeNode* root) {
        dfs(root, 1, 1);
        return ans; 
    }
    void dfs(TreeNode* node, int depth, int index) { 
        if (node == nullptr) {
            return;
        }
        if (!levelMin.count(depth)) {
            levelMin[depth] = index;
        }
        ans = max(ans, index - levelMin[depth] + 1);
        //重编号使得同层最靠左的非空节点编号为 1，消除编号溢出问题
        index = index - levelMin[depth] + 1;
        dfs(node->left, depth + 1, index << 1);
        dfs(node->right, depth + 1, index << 1 | 1);
    }
};
```



## :fire:[226. 翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/)

### 题意

给你一棵二叉树的根节点 `root` ，翻转这棵二叉树，并返回其根节点。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg)

```
输入：root = [4,2,7,1,3,6,9]
输出：[4,7,2,9,6,3,1]
```

**示例 2：**

![img](https://cdn.jsdelivr.net/gh/rangbiubiu/picBed@main/202403111254708.jpeg)

```
输入：root = [2,1,3]
输出：[2,3,1]
```

**示例 3：**

```
输入：root = []
输出：[]
```

**提示：**

- 树中节点数目范围在 `[0, 100]` 内
- `-100 <= Node.val <= 100`

### 参考题解

1. [王尼玛](https://leetcode.cn/problems/invert-binary-tree/solutions/73159/dong-hua-yan-shi-liang-chong-shi-xian-226-fan-zhua)  动画很直观

### 递归

**:question:   problems:** 

1. 为什么不能写成这样?

    ```c++
    TreeNode* invertTree(TreeNode* root) {
        // 2.结束条件 
        if (!root) return nullptr; 
        // 3.单层逻辑：将自己的左右子翻转，合并上左右子树的翻转结果，交给上级
        root->left = invertTree(root->right);
        root->right = invertTree(root->left); 
        return root;
    }
    ```

:heavy_check_mark:  **answer:** 

1. 因为`root->left = invertTree(root->right);` 这一步已经把root->left 改了 ！！其下一行用的root->left就不是自己以为的原来的左子，自己带入三个结点就能发现问题。

    如果在翻转左子树之前暂存左子就可以：

    ```c++
    TreeNode* invertTree(TreeNode* root) {
        // 2.结束条件 
        if (!root) return nullptr; 
        // 3.单层逻辑：将自己的左右子翻转，合并上左右子树的翻转结果，交给上级
        TreeNode *origin = root->left;    
        root->left = invertTree(root->right);
        root->right = invertTree(origin); 
        return root;
    }
    ```

#### 代码

可以写成这样：

```c++
TreeNode* invertTree(TreeNode* root) {
    // 2.结束条件 
    if (!root) return nullptr; 
    // 3.单层逻辑：将自己的左右子翻转，合并上左右子树的翻转结果，交给上级
    swap(root->left, root->right); 
    invertTree(root->left);
    invertTree(root->right);
    return root;
}
```

或这样

```cpp
TreeNode* invertTree(TreeNode* root) {
    // 递归结束条件
    if (!root || (!root->left && !root->right)) {
        return root;
    }
    // 单层递归做什么事？root的左右子各自完成自己的任务（翻转子树），root再将左右子进行翻转，然后上交结果
    TreeNode* tmp = root->left;
    root->left = invertTree(root->right);
    root->right = invertTree(tmp); 
    return root;
}
```



#### 复杂度分析

- 时间复杂度：O(n)  

- 空间复杂度：O(n)

### 迭代

**层序遍历**

```c++
TreeNode* invertTree(TreeNode* root) {
    if (!root) return nullptr;
    queue<TreeNode*> que;
    que.push(root);
    while (!que.empty()) {
        TreeNode* cur = que.front(); que.pop();
        if (cur->left) que.push(cur->left);
        if (cur->right) que.push(cur->right);
        //swap放在两个push的前面或者后面都行
        swap(cur->left, cur->right); 
    }
    return root;
}
```

复杂度分析

- 时间复杂度：O(n)  

- 空间复杂度：O(n)

## :fire:[297. 二叉树的序列化与反序列化](https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/)

### 题意

序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。

请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。

**提示:** 输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 [LeetCode 序列化二叉树的格式](https://support.leetcode.cn/hc/kb/article/1567641/)。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。

**示例 1：**

![img](https://cdn.jsdelivr.net/gh/rangbiubiu/picBed@main/202403152057345.jpeg)

```
输入：root = [1,2,3,null,null,4,5]
输出：[1,2,3,null,null,4,5]
```

**示例 2：**

```
输入：root = []
输出：[]
```

**示例 3：**

```
输入：root = [1]
输出：[1]
```

**示例 4：**

```
输入：root = [1,2]
输出：[1,2]
```

**提示：**

- 树中结点数在范围 `[0, 104]` 内
- `-1000 <= Node.val <= 1000`

### 参考题解

1. [笨猪爆破组](https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/solutions/290289/shou-hui-tu-jie-gei-chu-dfshe-bfsliang-chong-jie-f)
2. [评论区](https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/solutions/290289/shou-hui-tu-jie-gei-chu-dfshe-bfsliang-chong-jie-f/comments/1696066)

### DFS

![image-20240318145400330](https://cdn.jsdelivr.net/gh/rangbiubiu/picBed@main/202403181454636.png)

 :balloon:  **收获: **

- 巧妙利用 `istringstream`

    1. 用一个字符串初始化istringstream对象 is
    2. 用一个字符串s, 接收被空格分割出来的前一部分字符串（通过使用">>"读取 is 到 s 中） 

    ```cpp
    string data = "1 2 # # 3 4 5";
    //用字符串data来初始化输入字符串流 is, 这意味着 is 对象可以像流一样从中读取数据，就像从标准输入流 std::cin 中读取数据一样
    istringstream is(data);
    string s;
    is >> s; //">>"使用空格作为分隔符来读取输入流中的数据
    // 这步操作之后is变成"2 # # 3 4 5", s = "1" 
    ```

#### 代码

```c++
class Codec {
public:
    // Encodes a tree to a single string.
    string serialize(TreeNode* root) {
        // 得到二叉树的先序序列
        if (root == nullptr) return "#";   
        string left_str = serialize(root->left);
        string right_str = serialize(root->right);
        return to_string(root->val) + " " + left_str + " " + right_str;
    }

    // Decodes your encoded data to tree.
    TreeNode* deserialize(string data) { 
        istringstream is(data); //用一个字符串data来初始化输入字符串流is
        return buildTree(is);
    }
    TreeNode* buildTree(istringstream& is) {
        // 由于-1000 <= Node.val可能为负，因此s不能是char类型
        string s;
        // ">>"使用空格作为分隔符来读取输入流中的数据
        is >> s;
        if (s == "#") return nullptr;
        TreeNode* root = new TreeNode(stoi(s));
        root->left = buildTree(is);
        root->right = buildTree(is);
        return root;
    }
};
```

#### 复杂度分析

- 时间复杂度：O(n)  

- 空间复杂度：O(n)

### BFS

#### 代码

```c++
class Codec {
public:
    // Encodes a tree to a single string.
    string serialize(TreeNode* root) {
        if (!root) return "#";
        string ans;
        queue<TreeNode*> que;
        que.push(root);
        // 层序遍历，得到的字符串中同一棵树上的三个结点根左右是紧挨的
        while (!que.empty()) { 
            TreeNode* node = que.front();  que.pop();  
            if (node) {
                // 空格放在值前面还是值后面都行
                ans += to_string(node->val) + " ";
                que.push(node->left);  
                que.push(node->right); 
            } else {
                ans += "# ";
            }
        }
        return ans;
    }

    // Decodes your encoded data to tree.
    TreeNode* deserialize(string data) {
        istringstream is(data); 
        string s;
        is >> s;
        if (s == "#") return nullptr;
        TreeNode* root = new TreeNode(stoi(s));
        queue<TreeNode*> que;
        que.push(root);
        string leftStr, rightStr;
        while (is >> leftStr >> rightStr) {
            TreeNode* node = que.front();  que.pop();
            if (leftStr != "#") {
                node->left = new TreeNode(stoi(leftStr));
                que.push(node->left);
            }
            if (rightStr != "#") {
                node->right = new TreeNode(stoi(rightStr));
                que.push(node->right);
            }
        }
        return root;
    }
};
```

#### 复杂度分析

- 时间复杂度：O(n)  

- 空间复杂度：O(n)

## :two:[LCR 155. 将二叉搜索树转化为排序的双向链表](https://leetcode.cn/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/)

### 题意

将一个 **二叉搜索树** 就地转化为一个 **已排序的双向循环链表** 。

对于双向循环列表，你可以将左右孩子指针作为双向循环链表的前驱和后继指针，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。

特别地，我们希望可以 **就地** 完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中最小元素的指针。

**示例 1：**

```
输入：root = [4,2,5,1,3] 


输出：[1,2,3,4,5]

解释：下图显示了转化后的二叉搜索树，实线表示后继关系，虚线表示前驱关系。
```

**示例 2：**

```
输入：root = [2,1,3]
输出：[1,2,3]
```

**示例 3：**

```
输入：root = []
输出：[]
解释：输入是空树，所以输出也是空链表。
```

**示例 4：**

```
输入：root = [1]
输出：[1]
```

**提示：**

- `-1000 <= Node.val <= 1000`
- `Node.left.val < Node.val < Node.right.val`
- `Node.val` 的所有值都是独一无二的
- `0 <= Number of Nodes <= 2000`

### 参考题解

1. [K神](https://leetcode.cn/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/solutions/186518/mian-shi-ti-36-er-cha-sou-suo-shu-yu-shuang-xian-5)

### 递归

要求是“已排序的” “双向循环” 链表，要是有序的，因此就要用到 二叉搜索树的性质：中序遍历为递增序列，因此要中序遍历树，将节点连起来。另外，需要找到中序遍历的两个端点，即最左节点和最右结点，它俩作为双向循环链表的头和尾节点，互连起来。最左节点需要在中序遍历过程中去找，最右结点即是遍历结束时所处的节点

```c++
class Solution {
public: 
    Node *prev = nullptr;
    Node *head = nullptr;
    
    void inorderTraversal(Node* cur) {
        // 中序遍历会一直往下递归到最左结点，再开始逐层返回做互连
        // 递归结束条件：
        if (cur == nullptr) {
            return;
        }
        // 单层递归做啥事？1.往左子递归 2.互连cur和prev 3.往右子递归
        inorderTraversal(cur->left);
        if (prev == nullptr) { 
            // 说明cur就是最左节点
            head = cur;
        } else {
            cur->left = prev;
            prev->right = cur;
        }
        // 更新指针
        prev = cur;
        inorderTraversal(cur->right);
    }
    Node* treeToDoublyList(Node* root) {
        // 1.判空
        if (root == nullptr) {
            return nullptr;
        }
        // 2.中序遍历，连接节点
        inorderTraversal(root);
        // 3.连接头尾节点
        head->left = prev;
        prev->right = head;
        return head;
    }
};
```

**复杂度分析**

- 时间复杂度：O(N)  

- 空间复杂度：O(N)。 最差情况下，即树退化为链表时，递归深度达到 N，系统使用 *O*(N) 栈空间。

### 迭代

用 双色标记法 来进行中序遍历

```c++
class Solution {
public: 
    Node *prev = nullptr;
    Node *head = nullptr;
    
    void inorderTraversal(Node* root) {
        stack<pair<Node*, int>> st; //pair.second表示color, 为0时表示未访问, 为1时表示已访问
        st.push({root, 0});
        while (!st.empty()) {
            auto [cur, color] = st.top(); st.pop();
            if (cur == nullptr) {
                continue;
            }
            // 每次弹出的结点的color都是0，直到弹出最左节点
            if (color == 0) {
                st.push({cur->right, 0});
                st.push({cur, 1});
                st.push({cur->left, 0});
            } else {
                // 第一次走else时就是cur为最左节点时，此时将prev仍为初始值，更新prev
                if (prev == nullptr) {
                    head = cur;
                } else {
                    // 互连
                    prev->right = cur;
                    cur->left = prev;
                }
                // 更新指针
                prev = cur;
            }
        }
    }
    Node* treeToDoublyList(Node* root) {
        // 1.判空
        if (root == nullptr) {
            return nullptr;
        }
        // 2.中序遍历，连接节点
        inorderTraversal(root);
        // 3.连接头尾节点
        head->left = prev;
        prev->right = head;
        return head;
    }
};
```

**复杂度分析**

- 时间复杂度：O(n)  

- 空间复杂度：O(n)

## :fire:[114. 二叉树展开为链表](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/)

### 题意

给你二叉树的根结点 `root` ，请你将它展开为一个单链表：

- 展开后的单链表应该同样使用 `TreeNode` ，其中 `right` 子指针指向链表中下一个结点，而左子指针始终为 `null` 。
- 展开后的单链表应该与二叉树 [**先序遍历**](https://baike.baidu.com/item/先序遍历/6442839?fr=aladdin) 顺序相同。

**示例 1：**

![img](https://cdn.jsdelivr.net/gh/rangbiubiu/picBed@main/202403230940531.jpeg)

```
输入：root = [1,2,5,3,4,null,6]
输出：[1,null,2,null,3,null,4,null,5,null,6]
```

**示例 2：**

```
输入：root = []
输出：[]
```

**示例 3：**

```
输入：root = [0]
输出：[0]
```

**提示：**

- 树中结点数在范围 `[0, 2000]` 内
- `-100 <= Node.val <= 100`

**进阶：**你可以使用原地算法（`O(1)` 额外空间）展开这棵树吗？

### 参考题解

1. [官解](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/solutions/356853/er-cha-shu-zhan-kai-wei-lian-biao-by-leetcode-solu) 法三，图把过程模拟的很清晰

### 代码

```c++
void flatten(TreeNode* root) {
    while (root) {
        // 如果root的左子为空，则其无需进行任何展开操作
        if (root->left) {
            auto leftTail = root->left;
            // 找到左子树的最右结点leftTail
            while (leftTail->right) {
                leftTail = leftTail->right;
            }
            // 将root的右子树接到leftTail的右子树上
            leftTail->right = root->right;
            // 然后将接好的左右子树(都在root->left)接在root右子树
            root->right = root->left;
            root->left = nullptr;
        }
        // 当前root任务完成, 继续往下展开
        root = root->right; 
    }
}
```

### 复杂度分析

- 时间复杂度：O(n)  

- 空间复杂度：O(1)

## :fire:[208. 实现 Trie (前缀树)](https://leetcode.cn/problems/implement-trie-prefix-tree/)

### 题意

**[Trie](https://baike.baidu.com/item/字典树/9825209?fr=aladdin)**（发音类似 "try"）或者说 **前缀树** 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。

请你实现 Trie 类：

- `Trie()` 初始化前缀树对象。
- `void insert(String word)` 向前缀树中插入字符串 `word` 。
- `boolean search(String word)` 如果字符串 `word` 在前缀树中，返回 `true`（即，在检索之前已经插入）；否则，返回 `false` 。
- `boolean startsWith(String prefix)` 如果之前已经插入的字符串 `word` 的前缀之一为 `prefix` ，返回 `true` ；否则，返回 `false` 。

**示例：**

```
输入
["Trie", "insert", "search", "search", "startsWith", "insert", "search"]
[[], ["apple"], ["apple"], ["app"], ["app"], ["app"], ["app"]]
输出
[null, null, true, false, true, null, true]

解释
Trie trie = new Trie();
trie.insert("apple");
trie.search("apple");   // 返回 True
trie.search("app");     // 返回 False
trie.startsWith("app"); // 返回 True
trie.insert("app");
trie.search("app");     // 返回 True
```

**提示：**

- `1 <= word.length, prefix.length <= 2000`
- `word` 和 `prefix` 仅由小写英文字母组成
- `insert`、`search` 和 `startsWith` 调用次数 **总计** 不超过 `3 * 104` 次

### 参考题解

1. [samarua](https://blog.csdn.net/m0_46202073/article/details/107253959)

### 思路

**:question:   problems:** 

1. 为什么search()最后不是return true;?

:heavy_check_mark:  **answer:** 

1. 如果最后return true;的话那search()不是和startWith()一样了吗？

    因此要弄清楚！seach(word)是找前缀树中是否存在完整的word

    退出循环时cur指向word最后一个字符,说明word不在前缀树中

    如果走到word末尾了，但cur->isWord=false，说明word仅仅是一个前缀，并不完整

### 代码

```c++
class TrieNode {
public:
    bool isWord; //截至该结点是否是一个完整单词
    vector<TrieNode*> next; //下一个字母映射表
    TrieNode() : isWord(false), next(26) {}
};

class Trie {
private:
    TrieNode* root; 
public:
    // 【1.初始化前缀树对象】
    Trie() {
        root = new TrieNode();
    }
    // 【2.向前缀树中插入word】
    void insert(string word) {
        TrieNode* cur = root;
        // 逐个字符逐层找，只要在某一层没找到就插入结点
        for (char& ch : word) {
            int index = ch - 'a';
            // 找ch是否存在前缀树的第i层
            if (cur->next[index] == nullptr) {
                cur->next[index] = new TrieNode();
            }
            cur = cur->next[index];
        }
        cur->isWord = true;
    }
    // 【3.判断word是否在前缀树中（不能以前缀的形式存在！要以完整单词的形式存在！）】
    bool search(string word) {
        TrieNode* cur = root;
        // 逐个字符逐层找，只要在某一层没找到就return false;
        for (char& ch : word) {
            int index = ch - 'a';
            if (cur->next[index] == nullptr) return false;
            cur = cur->next[index];
        }
        return cur->isWord; //注意返回值！！！
    }
    // 【4.判断前缀树中是否有以prefix为前缀的单词】
    bool startsWith(string prefix) {
        TrieNode* cur = root;
        // 逐个字符逐层找，只要在某一层没找到就return false;
        for (char& ch : prefix) {
            int index = ch - 'a';
            if (cur->next[index] == nullptr) return false;
            cur = cur->next[index];
        }
        return true;
    }
};

/**
 * Your Trie object will be instantiated and called as such:
 * Trie* obj = new Trie();
 * obj->insert(word);
 * bool param_2 = obj->search(word);
 * bool param_3 = obj->startsWith(prefix);
 */
```

## :fire:[538. 把二叉搜索树转换为累加树](https://leetcode.cn/problems/convert-bst-to-greater-tree/)

### 题意

给出二叉 **搜索** 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 `node` 的新值等于原树中大于或等于 `node.val` 的值之和。

提醒一下，二叉搜索树满足下列约束条件：

- 节点的左子树仅包含键 **小于** 节点键的节点。
- 节点的右子树仅包含键 **大于** 节点键的节点。
- 左右子树也必须是二叉搜索树。

**注意：**本题和 1038: https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/ 相同

**示例 1：**

**![img](https://cdn.jsdelivr.net/gh/rangbiubiu/picBed@main/202404031648901.png)**

```
输入：[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]
输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]
```

**示例 2：**

```
输入：root = [0,null,1]
输出：[1,null,1]
```

**示例 3：**

```
输入：root = [1,0,2]
输出：[3,3,2]
```

**示例 4：**

```
输入：root = [3,2,4,1]
输出：[7,9,4,10] 
```

**提示：**

- 树中的节点数介于 `0` 和 `104` 之间。
- 每个节点的值介于 `-104` 和 `104` 之间。
- 树中的所有值 **互不相同** 。
- 给定的树为二叉搜索树。

### 参考题解

1. [笨猪爆破组](https://leetcode.cn/problems/convert-bst-to-greater-tree/solutions/421686/shou-hua-tu-jie-zhong-xu-bian-li-fan-xiang-de-by-x)

### 递归

```c++
class Solution {
public:
    int sum = 0;
    
    TreeNode* convertBST(TreeNode* root) {
        // 计算(处理)顺序为：右中左
        if (!root) return nullptr;
        convertBST(root->right); //右
        // 处理完右子树之后，sum已经等于右子树的所有结点之和了
        root->val += sum;    //中
        sum = root->val;     //更新sum
        convertBST(root->left);  //左
        return root;
    }
};
```

#### 复杂度分析

- 时间复杂度：O(n)  

- 空间复杂度：O(n)

### 迭代

==:star: **核心思路：颜色标记法 **:star:==

颜色标记法 可以参考:fire:[94. 二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/) 

```c++
class Solution {
public:
    const int WHITE = 0;
    const int GRAY = 1;
    int sum = 0;
    
    TreeNode* convertBST(TreeNode* root) {
        // 计算(处理)顺序为：右中左, 
        // 由于栈是先进后出，而处理(计算)结点的时候是在出栈的时候，
        // 因此，右要先出栈, 那右就要后进，因此进栈顺序是左中右
        if (!root) return nullptr;
        stack<pair<TreeNode*, int>> st;
        st.push({root, 0});
        while (!st.empty()) {
            auto [node, color] = st.top(); st.pop();
            if (node == nullptr) continue;
            if (color == 0) {
                st.push({node->left, 0});
                st.push({node, 1});
                st.push({node->right, 0});
            } else {
                node->val += sum;
                sum = node->val;
            }
        }
        return root;
    }
};
```

#### 复杂度分析

- 时间复杂度：O(n)  

- 空间复杂度：O(n)

## :fire:[199. 二叉树的右视图](https://leetcode.cn/problems/binary-tree-right-side-view/)

### 题意

给定一个二叉树的 **根节点** `root`，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。

**示例 1**

![img](https://cdn.jsdelivr.net/gh/rangbiubiu/picBed@main/202405261331962.jpeg)

```
输入: [1,2,3,null,5,null,4]
输出: [1,3,4]
```

**示例 2:**

```
输入: [1,null,3]
输出: [1,3]
```

**示例 3:**

```
输入: []
输出: []
```

**提示:**

- 二叉树的节点个数的范围是 `[0,100]`
- `-100 <= Node.val <= 100` 

### 代码

```cpp
vector<int> rightSideView(TreeNode* root) {
/*
    层序遍历，每一层的最后一个结点就是最右结点，将其存入结果
*/
    vector<int> ans;
    if (!root) return ans;
    queue<TreeNode*> que;
    que.push(root);
    while (!que.empty()) {
        int size = que.size();
        while (size--) {
            TreeNode* node = que.front(); que.pop();
            if (node->left) {
                que.push(node->left);
            }
            if (node->right) {
                que.push(node->right);
            }
            if (size == 0) {
                ans.emplace_back(node->val);
            }
        }
    }
    return ans;
}
```

## :two:[958. 二叉树的完全性检验](https://leetcode.cn/problems/check-completeness-of-a-binary-tree/)

### 题意

给你一棵二叉树的根节点 `root` ，请你判断这棵树是否是一棵 **完全二叉树** 。

在一棵 **[完全二叉树](https://baike.baidu.com/item/完全二叉树/7773232?fr=aladdin)** 中，除了最后一层外，所有层都被完全填满，并且最后一层中的所有节点都尽可能靠左。最后一层（第 `h` 层）中可以包含 `1` 到 `2h` 个节点。

 **示例 1：**

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/15/complete-binary-tree-1.png)

```
输入：root = [1,2,3,4,5,6]
输出：true
解释：最后一层前的每一层都是满的（即，节点值为 {1} 和 {2,3} 的两层），且最后一层中的所有节点（{4,5,6}）尽可能靠左。
```

**示例 2：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/15/complete-binary-tree-2.png)

```
输入：root = [1,2,3,4,5,null,7]
输出：false
解释：值为 7 的节点不满足条件「节点尽可能靠左」。
```

**提示：**

- 树中节点数目在范围 `[1, 100]` 内
- `1 <= Node.val <= 1000`

### 参考题解

1. [林小鹿](https://leetcode.cn/problems/check-completeness-of-a-binary-tree/solutions/54681/hen-jian-dan-de-si-lu-dai-ma-hen-jian-ji-by-yuanyb)

### BFS

用一个prev指针作为层序遍历过程中上一个遍历的结点，当prev为空时，若node不为空，则return false

```c++
class Solution {
public:
    bool isCompleteTree(TreeNode* root) {
        queue<TreeNode*> que;
        que.push(root);
        // 层序遍历的过程中遇到第一个空节点之后不应该再出现非空节点
        TreeNode* prev = root;
        while (!que.empty()) {
            TreeNode* node = que.front(); que.pop();
            if (!prev && node) {
                return false;
            }
            if (node) {
                que.push(node->left);
                que.push(node->right);
            }
            prev = node;
        }
        return true;
    }
};
```

**复杂度分析**

- 时间复杂度：O(n)  

- 空间复杂度：O(n)

### DFS

**:key:  key：**   从1开始对树结点进行编号，`完全二叉树满足：最大编号结点的编号 == 树的结点个数`

不推荐DFS解法，因为只有所有递归全部结束n和p都收集完毕才能根据n和p来判断是否是完全二叉树。如果树表现为一条向右延伸的链表，那么结点编号就会溢出。

下面的代码过不了，会溢出。

```c++
class Solution {
public:
    int maxIndex = 1; //最大结点编号
    int nodeCnt = 0;  //节点个数
    void dfs(TreeNode* root, int index) {
        // root的编号是index
        if (root == nullptr) {
            return;
        }
        nodeCnt++;
        maxIndex = max(index, maxIndex);
        dfs(root->left, index * 2);
        dfs(root->right, index * 2 + 1);
    }
    bool isCompleteTree(TreeNode* root) {
        dfs(root, 1);
        return maxIndex == nodeCnt; 
    }
};
```

## :two:[LCR 174. 寻找二叉搜索树中的目标节点](https://leetcode.cn/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/)

### 题意

某公司组织架构以二叉搜索树形式记录，节点值为处于该职位的员工编号。请返回第 `cnt` 大的员工编号。 

**示例 1：**

![img](https://pic.leetcode.cn/1695101634-kzHKZW-image.png)

```
输入：root = [7, 3, 9, 1, 5], cnt = 2
       7
      / \
     3   9
    / \
   1   5
输出：7
```

**示例 2：**

![img](https://pic.leetcode.cn/1695101636-ESZtLa-image.png)

```
输入: root = [10, 5, 15, 2, 7, null, 20, 1, null, 6, 8], cnt = 4
       10
      / \
     5   15
    / \    \
   2   7    20
  /   / \ 
 1   6   8
输出: 8
```

 **提示：**

- 1 ≤ cnt ≤ 二叉搜索树元素个数

### 参考题解

1. https://leetcode.cn/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/solutions/184216/mian-shi-ti-54-er-cha-sou-suo-shu-de-di-k-da-jie-d

### 思路

二叉搜索树的中序遍历是递增的，因此第cnt大结点就是中序遍历的倒序的第cnt个结点。

### 代码

```c++
class Solution {
private:
    int res, cnt;
    void dfs(TreeNode* root) {
        // 递归结束条件
        if(root == nullptr) {
            return;
        }
        // 右
        dfs(root->right);
        // 中
        // 如果cnt减到0了,说明前面在往右子树递归的过程中就已经找到结果了
        if(cnt == 0) {
            return;
        }
        // 每遍历一个结点就让cnt-1, 如果减1后cnt为0,说明找到第cnt大的结点了
        if(--cnt == 0) {
            res = root->val;
        }
        // 左
        dfs(root->left);
    }
public:
    int findTargetNode(TreeNode* root, int cnt) {
        this->cnt = cnt;
        dfs(root);
        return res;
    }
};
```

**复杂度分析**

- 时间复杂度：O(n)  

- 空间复杂度：O(n)

## 

## [LCR 153. 二叉树中和为目标值的路径](https://leetcode.cn/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/)