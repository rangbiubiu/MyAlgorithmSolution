

## 目录

[TOC]



## c++二分查找API

> 二分查找的函数有3个：
>
> int lower_bound(起始地址，结束地址，要查找的数值) 返回的是数值 第一个**大于等于**某元素 的位置。
>
> int upper_bound(起始地址，结束地址，要查找的数值) 返回的是数值 第一个**大于**某个元素 的位置。
>
> bool binary_search(起始地址，结束地址，要查找的数值) 返回的是 是否存在 这么一个数，是一个bool值。

- **函数lower_bound()** 

    功能：函数lower_bound()在first和last中的**前闭后开**区间进行二分查找，返回**大于或等于val**的第一个元素位置。

    如果所有元素都小于val，则返回last的位置，因为是前闭后开因此这个时候的last会越界，要注意。

- **函数upper_bound()**

    功能：函数upper_bound()返回的在**前闭后开**区间查找的关键字的上界，返回**大于val**的第一个元素位置。

    同样，如果val大于数组中全部元素，返回的是last。(注意：数组下标越界)

- **函数binary_search()**

    功能： 在数组中以二分法检索的方式查找，若在数组(要求数组元素非递减)中查找到indx元素则真，若查找不到则返回值为假。



### 💛总结题型

> 待完善。。。

1. 搜索旋转排序数组
2. 搜索二维矩阵
3. 最大值最小化

## [:fire: 4. 寻找两个正序数组的中位数](https://leetcode.cn/problems/median-of-two-sorted-arrays/)

### 题意

:  给定两个大小分别为 `m` 和 `n` 的升序数组 `n1` 和 `n2`。请你找出并返回这两个正序数组的 **中位数** 。

算法的时间复杂度应该为 `O(log (m+n))` 。

**示例 1：**

```
输入：n1 = [1,3], n2 = [2]
输出：2.00000
解释：合并数组 = [1,2,3] ，中位数 2
```

**示例 2：**

```
输入：n1 = [1,2], n2 = [3,4]
输出：2.50000
解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5
```

### 参考题解

1. [liweiwei大佬](https://leetcode.cn/problems/median-of-two-sorted-arrays/solutions/258842/xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-s-114/) 以及大佬录制的官方视频题解

###  思路

==:star: **核心思路：二分查找   **:star:==

:key:  **key**：

- 用一条分割线分割两数组，使分割线左右两半元素数量差不多。除此之外，要能根据分割线确定中位数，就要让分割线左边所有元素 <= 分割线 右边所有元素。这样，中位数就由分割线左右两侧的元素决定

- 分割线要能决定中位数，那就要满足两个性质：

    1. **左右两边元素数量相等或差一**（相等还是差一与两个数组长度和的奇偶性有关）。差1时我们让分割线左边的元素比右边多一个。

    2. **分割线 左边所有元素 <= 分割线 右边所有元素**。
        - 设分割线左右两侧的四个数从左往右从上往下分别为a1, a2; b1,b2，
        - 由于同一数组中左边元素肯定<=右边元素，因此肯定有a1<=a2,b1<=b2。
        - 除此之外，我们需要让 a1<=b2, b1<=a2。
        - 因此我们需要找到满足a1<=b2, b1<=a2 的分割线的位置

- 怎么找？

    - 利用二段性。比如若不满足a1<=b2（n1[i-1]<=n2[j]），也就是说n1[i-1]>n2[j]，则分割线就一定不在i及i之后的位置，可以排除一段范围。因此就可以用二分查找。不断排除不可能的范围，缩小查找区间，最终找到解。


**:question:   problems:** 

1. 怎么想到分割线的？
2. :star:==为什么要选择两个数组中长度更小的那个来确定分割线的位置?==（且这个选择是必要的）
3. 该题的二段性是？
4. right是初始化为len1还是len1-1？
5. 最后求得分割线在n1和n2中的位置之后，怎么求中位数？

:heavy_check_mark:  **answer:** 

1. 因为题目要求是要log (m+n)的时间复杂度，如果不分割，那就只能线性去找。

2. ==最重要的原因是为了防止数组下标越界==；其次，在短数组中进行二分查找时间复杂度更优，为O(log min(len1, len2))

    > 为什么选择短数组就能防止下标越界？选择长数组作为要二分查找的n1难道会导致下标越界吗？
    >
    > ——是的。若选择长数组作为n1，如下
    >
    > ![image-20240206094708051](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202402060947095.png)

3. 【不可能，可能】。

    - 不可能：只要分割线左右数值不满足`n1[i-1]<=n2[j] && n2[j-1]<=n1[i]`中的任意一个，那就可以排除一边。

    - 而满足交叉关系也不一定就是分割线的位置。

4. 要不要-1就看下标len1有没有有没有可能是答案。而分割线的位置可能是len1，因此初始化为len1

5. 两数组元素总数

    - 为奇，则中位数就是分割线左边的最大值

    - 为偶，则中位数=(分割线左边的最大值 + 与分割线右边的最小值) / 2 

        ![image-20231210171147715](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202312101711888.png) 


**:small_red_triangle_down: steps: **

1.  让n1代表短数组
2.  计算分割线一边的元素个数（我们选择左边）
3.  在短数组中二分查找分割线的位置
    1.  根据分割线在短数组(n1)中的位置，求得分割线在长数组(n2)中的位置
    2.  根据`左右两边数值【不满足任一交叉小于等于条件】的分割线位置【一定不是】结果位置，【满足交叉小于等于条件】的分割线位置【可能】是结果位置`这样的二段性，写if-else分支

4.  找到了分割线在n1和n2中的位置后，先要处理下标越界的情况

5.  最后再取中位数

:smiley: **收获： ** 

1. 不仅仅只有满足 01 特性（满足/不满足）的「二段性」可以使用二分，满足 1? 特性（一定满足/不一定满足）或者满足 0? 特性（一定不满足/可能满足） 也可以二分。
2. 【x为奇数时，`(x + 1) / 2`的结果】 = 【x为偶数时，`x / 2` 的结果】=【x为偶数时，`(x + 1) / 2` 的结果】。因此在分奇偶计算一个值/2时，可以合并奇偶两种情况的计算式为一种：`(x+1)/2`
3. 要将计算结果从int转换为double，可以直接将式子中的数值用小数表示（比如最后计算式子中的2.0），这样就不用显式强转了

> 二刷卡住的点：
>
> 1. 知道要分割但不知道怎么分割 ——>就是要确定分割线的位置
>
>     1. 由于是求中位数，因此分割线要将两数组总元素数一分为二，因此分割线两边的元素数就能求得。因此只要知道了分割线在一个数组中的位置（也就知道了该数组在分割线左边的元素数），就能根据性质1知道分割线在另一个数组中的位置。因此，我们只需要求分割线在一个数组中的位置。
>     2. 设分割线在两个数组中的位置为i,j，就能根据性质2在一个数组中二分查找分割线的位置，求完后另一个数组中分割线的位置就也能知道了。
>
> 2. 不知道else的逻辑怎么写
>
>     1. 可以直接根据if的反面写出来
>
>     2. 若要解释的话，就是：
>
>         ![image-20240206000645104](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202402060006353.png)

### 代码

```c++
double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
/*
    如果用一个分割线分割这两个正序数组，
    分割线左右两边的元素满足: 左边的都<=右边的 & 左右两边元素数量相等或差1
    这样中位数就由分割线左右侧紧挨着的元素决定。
    因此，问题就转化为了：找这样一条分割线在两个数组中的位置。
    怎么找？只需找到分割线在其中一个数组中的位置，那么它在另一个数组中的位置也就知道了
    设分割线在两个数组中的位置分别是i和j, 那么分割线左右两侧需满足
    (1) nums1[i - 1] <= nums2[j] && nums1[i] >= nums[j - 1]
    (2) i + j = (len1 - i) + (len2 - j)
        0~i-1 | i ~ len1-1
        0~j-1 | j ~ len2-1
    根据这两个性质来移动分割线在其中一个数组中的位置
*/

    // 让n1作为短数组
    // 为什么必须让n1作为短数组？不然就报错？—— 为了防止数组下标越界！
    // 因为比如n1={1,3}, n2={2}时, leftCnt=2, left=0, right=len1=2 => i=1, j=leftCnt-i=1，越界！！！
    if (nums1.size() > nums2.size()) {
        return findMedianSortedArrays(nums2, nums1);
    }
    int len1 = nums1.size();
    int len2 = nums2.size();
    int leftCnt = (len1 + len2 + 1) / 2; //分割线左侧的元素数量
    //如果是偶数则leftCnt就是两数组元素数量的一半，如果是奇数则leftCnt就是··还多一
    int left = 0;
    int right = len1; //因为分割线可能在len1处
    while (left < right) {
        int i = (left + right + 1) / 2; //分割线在nums1中的位置
        int j = leftCnt - i;        //分割线在nums2中的位置
        if (nums1[i - 1] > nums2[j]) { //分割线要往左移
            right = i - 1;
        } else {
            left = i;
        }
    }
    // 退出循环时已找到分割线在nums1中的位置，进而其在nums2中的位置也可以找到
    int divLine1 = left;
    int divLine2 = leftCnt - divLine1;
    // 中位数由分割线左右侧紧挨着的元素决定，由于分割线可能在数组边界，所以要处理特殊情况：
    // 设分割线左右侧紧挨着的元素分别为：LeftN1, LeftN2 | RightN1, RightN2
    // 如果分割线在nums1中的位置是0，那么由于中位数要取左边的最大值，因此LeftN1要为INT_MIN
    // 如果分割线在nums1中的位置是len1，那么由于中位数要取右边的最小值，因此RightN1要为INT_MAX
    // 在nums2中的这两种情况也同理
    int LeftN1 = divLine1 == 0 ? INT_MIN : nums1[divLine1 - 1];
    int LeftN2 = divLine2 == 0 ? INT_MIN : nums2[divLine2 - 1];
    int RightN1 = divLine1 == len1 ? INT_MAX : nums1[divLine1];
    int RightN2 = divLine2 == len2 ? INT_MAX : nums2[divLine2];
    // 接下来计算中位数
    int leftMax = max(LeftN1, LeftN2);
    int rightMin = min(RightN1, RightN2);
    return (len1 + len2) % 2 ? leftMax : (leftMax + rightMin) / 2.0;
}
```

### 复杂度分析

- 时间复杂度：O(log min(len1+len2) )  

- 空间复杂度：O(1)

## :fire:[153. 寻找旋转排序数组中的最小值](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/)

### 题意

已知一个长度为 `n` 的数组，预先按照升序排列，经由 `1` 到 `n` 次 **旋转** 后，得到输入数组。

数组 `[a[0], a[1], a[2], ..., a[n-1]]` **旋转一次** 的结果为数组 `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]` 。例如，原数组 `nums = [0,1,2,4,5,6,7]` ：

- 旋转 `4` 次得到 `[4,5,6,7,0,1,2]`
- 旋转 `7` 次得到 `[0,1,2,4,5,6,7]`

给你一个元素值 **互不相同** 的数组 `nums` ，它原来是一个升序排列的数组，后进行了多次旋转。请你找出并返回数组中的 **最小元素** 。

你必须设计一个时间复杂度为 `O(log n)` 的算法解决此问题。

**示例 1：**

```cpp
输入：nums = [3,4,5,1,2]
输出：1
解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。
```

**示例 2：**

```cpp
输入：nums = [11,13,15,17]
输出：11
解释：原数组为 [11,13,15,17] ，旋转 4 次得到输入数组。
```

### 分析过程：

数组经旋转后一分为2，一部分是来自数组后面部分的那一坨（旋转后到了前面，旋转了几次这一坨就有几个元素），一部分是之前在数组前面部分的那一坨（旋转后到了后面）。

根据：**如果两点是「上升」的，那么两点之间一定是「上升」的。**我们可以将情况分为4种：

- 若`n[mid] < n[right]` ，则[mid,right]一定是上升的，往[left,mid]继续查找最小值（mid可能是最小值）；
- 若`n[mid] > [right]` ，则最小值一定在[mid + 1,right]区间;
- 若`n[left] > n[mid]` ，则最小值一定在[left,mid]区间；
- 若`n[left] < n[mid] ` ，则[left,mid]一定是上升的

那我们是选择根据mid和right的比较二分还是根据left和mid的比较二分呢？

如果根据mid和right的比较二分，if-else逻辑：

- `if (n[mid] < n[right]) right = mid;`//说明[mid,right]一定是上升的，也就是说[mid,right]一定是旋转后的数组最后面的那一坨（一直到末尾），那么最小值肯定不会在(mid,right]。我们往[left,mid]继续查找最小值（mid可能是最小值）
- `else left = mid + 1;`//否则最小值一定在[mid + 1,right]区间

如果根据mid和left的比较二分，if-else逻辑：

- `if (n[left] > n[mid]) right = mid;`//说明最小值一定在[left,mid]区间
- `else left = mid + 1;`//说明[left,mid]一定是上升的，:no_good_man::x: ~~往[mid+1,right]继续查找最小值~~:x::no_good_man: 不能直接就认为[left,mid]一定就不存在最小值。因为left可能就是最小值，此时的查找区间[left,right]是单调递增的。因此先要做特殊判断处理这种情况。

### 思路

==:star: **核心思路： 二分   **:star:==

**:question:   problems:** 

1. 选择根据mid和right 还是left和mid的比较二分?

:heavy_check_mark:  **answer:** 

1. 都可以，只不过选择根据left和mid二分要想清楚特殊情况。

    比如这两个例子，nums[left]都<nums[mid]，但是最小值可能在mid左边（即left就是最小值，[left,right]递增）也可能在mid右边。因此要特判。

    - 例 1：`[1, 2, 3, 4, 5]`；
    - 例 2：`[2, 3, 4, 5, 1]`。

### 代码

#### (1) 根据mid,right的比较二分 :raised_hands:

```c++
int findMin(vector<int>& nums) {
    int left = 0, right = nums.size() - 1;
    while (left < right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] < nums[right]) right = mid;//最小值肯定不会在(mid,right]
        else left = mid + 1;//最小值一定在[mid + 1,right]
    }
    return nums[left];
}
```

#### (2) 根据mid,left的比较二分

```c++
int findMin(vector<int>& nums) {
/*
    二分：这里的二段性是一段有序(1)，一段不确定是否有序(0),
    目标值一定在0这段（或者在1那段的第一个元素--当右区间有序时）
    可以根据有序区间的特性，判断哪段是有序的(1)，那另一段就是不确定是否有序的(0)，来缩小查找范围
*/ 
    int left = 0;
    int right = nums.size() - 1;
    while (left < right) {
        // 如果搜索区间完全有序，则区间左端点一定就是最小值。
        // 如果这里不作特判的话，因为nums[left]<nums[mid]，走执行逻辑left=mid+1会使本来位于left位置的最小值掉出搜索区间
        if (nums[left] < nums[right]) return nums[left];
        // 否则，搜索区间是一段有序一段无序的，此时最小值一定在无序的那段（或者在有序的那段的第一个元素--当右区间有序时）
        int mid = (left + right) / 2;
        // 左区间有序，目标值在右区间
        if (nums[left] <= nums[mid]) { //注意等号！
            left = mid + 1;//最小值一定在[mid + 1,right]
        } else {
        // 右区间有序，目标值在左区间（右区间的第一个元素也可能是目标值）
            right = mid;//最小值肯定不会在(mid,right]
        }
    }
    return nums[left];
}
```

### 复杂度分析

- 时间复杂度：O(logn)  

- 空间复杂度：O(1)

## [lc154. 寻找旋转排序数组中的最小值 II](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array-ii/)

### 题意

:  已知一个长度为 `n` 的数组，预先按照升序排列，经由 `1` 到 `n` 次 **旋转** 后，得到输入数组。

数组 `[a[0], a[1], a[2], ..., a[n-1]]` **旋转一次** 的结果为数组 `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]` 。例如，原数组 `nums = [0,1,4,4,5,6,7]` ：

- 旋转 `4` 次得到 `[4,5,6,7,0,1,4]`
- 旋转 `7` 次得到 `[0,1,4,4,5,6,7]`

给你一个可能存在 **重复** 元素值的数组 `nums` ，它原来是一个升序排列的数组，后进行了多次旋转。请你找出并返回数组中的 **最小元素** 。

你必须尽可能减少整个过程的操作步骤。

**进阶：**这道题与 [寻找旋转排序数组中的最小值](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/description/) 类似，但 `nums` 可能包含重复元素。允许重复会影响算法的时间复杂度吗？会如何影响，为什么？

### 参考题解

1. [liweiwei大佬](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array-ii/solutions/8217/er-fen-fa-fen-zhi-fa-python-dai-ma-by-liweiwei1419/)
2. [三叶大佬](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array-ii/solutions/710212/gong-shui-san-xie-xiang-jie-wei-he-yuan-7xbty/) 一张图就说明白了:thumbsup:

### 思路

==:star: **核心思路：二分 ，二段性丢失时改用线性查找   **:star:==

**:question:   problems:** 

1. 这道题与 [寻找旋转排序数组中的最小值](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/description/) 类似，但 `nums` 可能包含重复元素。允许重复会影响算法的时间复杂度吗？会如何影响，为什么？

:heavy_check_mark:  **answer:** 

1. 会，当mid值和边界值相等时，二段性丢失，我们无法确定最小值在mid左边还是mid右边。因此这种情况要改用线性搜索，--r或++l遍历排除与mid值相等的边界。

### 代码

#### (1) 根据mid,right的比较二分 :raised_hands:

```c++
int findMin(vector<int>& nums) {
    int left = 0, right = nums.size() - 1;
    while (left < right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] < nums[right]) right = mid;//说明[mid,right]一定是上升的，也就是说[mid,right]一定是旋转后的数组最后面的那一坨（一直到末尾），那么最小值肯定不会在(mid,right]。我们往[left,mid]继续查找最小值（mid可能是最小值）
        else if (nums[mid] == nums[right]) --right;//right一定不是最小值
        //比如当[3 x 3 x 3]其中x可能为1也可能为3,如果mid值和right值相等了, 就无法确定最小值是在mid左边还是在mid右边，弃用二分法改用线性搜索,r--把右边界排除掉就好了
        else left = mid + 1;//否则最小值一定在[mid + 1,right]区间
    }
    return nums[left];
}
```

#### (2) 根据mid,left的比较二分

```c++
int findMin(vector<int>& nums) {
        int left = 0, right = nums.size() - 1;
        while (left < right) {
            //当搜索区间（答案一定在其中）单调递增时，区间左端点一定就是最小值。
            if (nums[left] < nums[right]) return nums[left];
            //如果搜索区间已经单调递增了，不作特判继续往下执行的话，因为nums[left]<nums[mid],走执行逻辑left=mid+1缩小查找区间后，就使得本来位于left位置的最小值掉出查找区间
            int mid = left + (right - left) / 2;
            if (nums[left] > nums[mid]) right = mid;//说明最小值一定在[left,mid]区间
            else if (nums[left] == nums[mid]) ++left;//left一定不是最小值
             //比如当[3 x 3 x 3]其中x可能为1也可能为3,如果mid值和left值相等了, 就无法确定最小值是在mid左边还是在mid右边，弃用二分法改用线性搜索,++l把左边界排除掉就好了
            else left = mid + 1;//说明[left,mid]一定是上升的
        }
        return nums[left];
    }
```

### 复杂度分析

- 时间复杂度： 

    平均时间复杂度为 O(log⁡n)，如果数组是随机生成的，那么数组中包含相同元素的概率很低，在二分查找的过程中，大部分情况都会忽略一半的区间。

    而在最坏情况下，如果数组中的元素完全相同，每次执行 `right = right - 1;` 时间复杂度是 `O(N)` 。  

- 空间复杂度：O(1)



## [:fire:33. 搜索旋转排序数组](https://leetcode.cn/problems/search-in-rotated-sorted-array/)

### 题意

整数数组 `nums` 按升序排列，数组中的值 **互不相同** 。

在传递给函数之前，`nums` 在预先未知的某个下标 `k`（`0 <= k < nums.length`）上进行了 **旋转**，使数组变为 `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]`

给你 **旋转后** 的数组 `nums` 和一个整数 `target` ，如果 `nums` 中存在这个目标值 `target` ，则返回它的下标，否则返回 `-1` 。

设计一个时间复杂度为 `O(log n)` 的算法。

**示例 1：**

```C++
输入：nums = [4,5,6,7,0,1,2], target = 0
输出：4
```

**示例 2：**

```c++
输入：nums = [4,5,6,7,0,1,2], target = 3
输出：-1
```

### 参考题解

1. [liweiwei]

### 思路

==:star: **核心思路：二分  **:star:==

**:key:  key：**

- 旋转数组可以用mid一分为二, **其中一个区间一定有序, 一个区间可能有序, 也可能无序**。

- 我们可以根据有序的那个区间来确定如何缩小查找区间。

    - 如果target在有序区间, 则继续在有序区间中缩小查找区间;
    - 如果不在, 说明target在另外一个区间, 此时调整left或者right, 往另外那个区间找

- 判断区间有序还是无序：只要 `nums[区间左端点] < nums[区间左端点]`就说明有序

**:question:   problems:** 

1. 这一题的【两段性】是什么？

:heavy_check_mark:  **answer:** 

1. 一段一定有序，一段不一定有序

:smiley: **收获： ** 

- ###### 当执行逻辑冲突时（即while中同时出现了left=mid和right=mid），此时无论是上取整取mid还是下取整取mid，都会出现死循环。我们就要调整判断逻辑让mid的取法能合并。

### 代码

#### 版本1（while中为if-else分支）

```cpp
class Solution {
public:
    int search(vector<int>& nums, int target) {
/*
    要求O(logn)的时间复杂度，因此想到是否能用二分解决？
    观察nums是否有二段性：
        旋转后的数组[4,5,6,7,0,1,2]，随意取一个下标i，
        i将数组分割为两个区间：一个一定有序，一个不一定有序。因此数组的范围有二段性，可以用二分。
    怎么二分？我们可以根据有序区间的特性来二分，缩小查找范围。
*/ 
        int left = 0, right = nums.size() - 1;
        while (left < right) {
            int mid = (left + right) / 2;
            if (nums[left] < nums[mid]) { //如果mid左边是有序区间
                // 可以比较target和nums[left]、nums[mid]的大小，判断target在1还是0区间
                if (nums[left] <= target && target <= nums[mid]) {
                    right = mid;
                } else {
                    left = mid + 1;
                }
            } else { //如果mid右边是有序区间
                // 可以比较target和nums[mid]、nums[right]的大小，判断target在1还是0区间
                if (nums[mid + 1] <= target && target <= nums[right]) {
                    left = mid + 1; 
                    //与mid向下取整冲突了，会死循环，因此需要做调整让其变为left = mid + 1;
                    // 这意味着mid不会是target, 将条件中nums[mid] <= target改为nums[mid + 1] <= target即可，
                    // 或者将nums[mid] <= target改为nums[mid] < target也可以。
                } else {
                    right = mid; 
                }
            }
        }
        return nums[left] == target ? left : -1;
    }
};
```

**复杂度分析**

- 时间复杂度：O(logn)  

- 空间复杂度：O(1)

## [81. 搜索旋转排序数组 II](https://leetcode.cn/problems/search-in-rotated-sorted-array-ii/)

### 题意

已知一个非降序的整数数组 `nums` ，数组中的值可能相同。

在传递给函数之前，`nums` 在预先未知的某个下标 `k`（`0 <= k < nums.length`）上进行了 **旋转** ，使数组变为 `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]`（下标 **从 0 开始** 计数）。例如， `[0,1,2,4,4,4,5,6,6,7]` 在`下标 5` 处经旋转后变为 `[4,5,6,6,7,0,1,2,4,4]` 。

给你 **旋转后** 的数组 `nums` 和一个整数 `target` 。如果 `nums` 中存在 `target` 则返回 `true` ，否则返回 `false` 。

你必须尽可能减少整个操作步骤。

**示例 1：**

```CPP
输入：nums = [2,5,6,0,0,1,2], target = 0
输出：true
```

**示例 2：**

```cpp
输入：nums = [2,5,6,0,0,1,2], target = 3
输出：false
```

**进阶：**

- 这是 [33. 搜索旋转排序数组](https://leetcode.cn/problems/search-in-rotated-sorted-array/) 的延伸题目，本题中的 `nums` 可能包含重复元素。这会影响到程序的时间复杂度吗？会有怎样的影响，为什么？

### 思路

==:star: **核心思路： 二分 ，二段性丢失时改用线性查找     **:star:==

**:key:  key：**

- 和[lc33. 搜索旋转排序数组](https://leetcode.cn/problems/search-in-rotated-sorted-array/)不同的是，nums中的值有可能重复，因此就不是单纯的二分【正面+反面】了，此时要转为线性搜索。

    对重复值的处理【当mid值和边界值相等时，二段性丢失，我们无法确定target在mid左边还是mid右边。因此这种情况要改用线性搜索】和 [lc154. 寻找旋转排序数组中的最小值 II](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array-ii/) 一样。

### 代码

```c++
bool search(vector<int>& nums, int target) {
    if (nums.size() == 0) return -1;
    int left = 0, right = nums.size() - 1;
    while (left < right) {
        int mid = left + (right - left + 1) / 2;
        // 情况1: [mid,right]是有序的, 则[left..mid-1]是不确定有序还是无序的
        if (nums[mid] < nums[right]) {  
            if (nums[mid] <= target && target <= nums[right]) left = mid;//target在有序区间
            else right = mid - 1;//否则在另一个区间
        }  
        // 情况2:  [left,mid-1]有序
        else if (nums[mid] > nums[right]) {
            if (nums[left] <= target && target <= nums[mid - 1]) right = mid - 1;//target在有序区间
            // 这里是经过调整的, 原因同33. 搜索旋转排序数组
            else left = mid;
        }
        else { 
            /*
            * nums[mid] == nums[right]。
            * 比如10111 和 11101，此时无法确定到底是mid左边区间有序还是mid右边区间有序，因此直接--right即可，相当于去掉一个重复的干扰项
            * 比如当[3 x 3 x 3]其中x可能为1也可能为3,如果mid值和right值相等了, 就无法确定最小值是在mid左边还是在mid右边，弃用二分法改用线性搜索,r--把右边界排除掉就好了
            */
            if (nums[right] == target) return true;
            //不做这步判断行不行呢？不行！当mid==right, 即查找区间只剩两个元素时，此时nums[mid]本来就是nums[right]，因此如果nums[mid](nums[right])就是答案，那么直接就right--就会跳过答案
            //比如{1,3},target=3时，不做判断就会使答案被跳过
            --right;
        }
    }
    return nums[left] == target;
}
```

### 复杂度分析

- 时间复杂度：（同 [lc154. 寻找旋转排序数组中的最小值 II](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array-ii/)）

    - 平均时间复杂度为 O(log⁡n)，如果数组是随机生成的，那么数组中包含相同元素的概率很低，在二分查找的过程中，大部分情况都会忽略一半的区间。

        而在最坏情况下，如果数组中的元素完全相同，每次执行 `right = right - 1;` 时间复杂度是 `O(N)` 。  

- 空间复杂度：O(1)

## :crossed_swords:[剑指03. 数组中重复的数字](https://leetcode.cn/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/solutions/96623/mian-shi-ti-03-shu-zu-zhong-zhong-fu-de-shu-zi-yua/)

----

### 题意

找出数组中重复的数字。

在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。

示例 1：

```c++
输入：
[2, 3, 1, 0, 2, 5, 3]
输出：2 或 3 
```

### 参考题解

1. [帅地玩编程](https://leetcode.cn/problems/linked-list-cycle/solutions/175734/yi-wen-gao-ding-chang-jian-de-lian-biao-wen-ti-h-2)

> 这题和[287. 寻找重复数](https://leetcode.cn/problems/find-the-duplicate-number/)不一样的两个点：
>
> - [287. 寻找重复数](https://leetcode.cn/problems/find-the-duplicate-number/) 
>
>     1. **不能修改** 数组 `nums`，因此不能用原地交换的方式。
>
>     1. `nums` 中 **只有一个整数** 出现 **两次或多次** ，其余整数均只出现 **一次**
>
> 而这一题不知道有几个数字重复了，也不知道每个数字重复了几次，因此二分查找和快慢指针法都不行

### 思路

1. 法一：排序法
2. 法二：哈希法![SmartSelect_20240129_071810_Samsung Notes](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202402121958656.jpg)

3. 法三：==:star: **核心思路： 下标法 + 原地交换   **:star:==

**:key:  key：**

- 关键是用到题目条件： `在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内` 
- ![SmartSelect_20240129_071917_Samsung Notes](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202402121958703.jpeg)

**:small_red_triangle_down:  steps: **

遍历数组，

1.  如果当前元素与其下标不等，则将该元素nums[i]换到它应该在的位置(下标nums[i]处)
    - 如果发现它应该在的位置nums[i]，与该位置的值nums[nums[i]]相等（nums[i]==nums[nums[i]]），则说明找到了重复值，直接return
2.  当前元素与其下标相等，直接++i跳过

### 代码

```c++
int findRepeatDocument(vector<int>& nums) {
// int findRepeatNumber(vector<int>& nums) {
    for (int i = 0; i < nums.size(); ) {
        // 如果当前元素与其下标不等，则将该元素nums[i]换到它应该在的位置(下标nums[i]处)
        // 如果发现它应该在的位置nums[i]，与该位置的值nums[nums[i]]相等（nums[i]==nums[nums[i]]），则说明找到了重复值，直接return
        if (nums[i] != i) {
            if (nums[nums[i]] == nums[i]) return nums[i];
            swap(nums[i], nums[nums[i]]);
            //将nums[i]交换到它应该在的位置-->下标nums[i]处
        }
        else ++i;
    }
    return -1;
}
```

或用while写也是一样：

```c++
int findaRepeatDocument(vector<int>& nums) {
// int findRepeatNumber(vector<int>& nums) {
    for (int i = 0; i < nums.size(); ++i) {
        while (nums[i] != i) {
            if (nums[nums[i]] == nums[i]) return nums[i];
            swap(nums[i], nums[nums[i]]);
            //将nums[i]交换到它应该在的位置-->下标nums[i]处
        }
    }
    return -1;
}
```

### 复杂度分析

- 时间复杂度：O(n)  最多遍历一遍数组

- 空间复杂度：O(1)

## [:fire: lc287. 寻找重复数](https://leetcode.cn/problems/find-the-duplicate-number/)

### 题意

给定一个包含 `n + 1` 个整数的数组 `nums` ，其数字都在 `[1, n]` 范围内（包括 `1` 和 `n`），可知至少存在一个重复的整数。

假设 `nums` 只有 **一个重复的整数** ，返回 **这个重复的数** 。

你设计的解决方案必须 **不修改** 数组 `nums` 且只用常量级 `O(1)` 的额外空间。

**示例 1：**

```
输入：nums = [1,3,4,2,2]
输出：2
```

**示例 2：**

```
输入：nums = [3,1,3,4,2]
输出：3
```

**提示：**

- `1 <= n <= 105`
- `nums.length == n + 1`
- `1 <= nums[i] <= n`
- `nums` 中 **只有一个整数** 出现 **两次或多次** ，其余整数均只出现 **一次**

**进阶：**

- 如何证明 `nums` 中至少存在一个重复的数字?
- 你可以设计一个线性级时间复杂度 `O(n)` 的解决方案吗？

### 参考题解

1. [法一、wei神](https://leetcode.cn/problems/find-the-duplicate-number/solutions/7038/er-fen-fa-si-lu-ji-dai-ma-python-by-liweiwei1419)

### 法一

==:star: **核心思路： 在一个确定的范围内查找一个整数  :point_right:  二分查找   **:star:==

**:key:  key：**

- 这个问题使用是在数组 `[1, 2,.., n]` 中查找一个整数，而 **并非在输入数组数组中查找一个整数**。
- 抽屉原理：m个抽屉装了数量>m的苹果那么一定有多个苹果被装到同一抽屉

2. ![image-20240207223844919](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202402072238983.png)

#### 代码

```c++
int findDuplicate(vector<int>& nums) {
    int left = 1, right = nums.size() - 1;//数组长度为n+1,因此nums.size()-1就是n
    while (left < right) { //在值1~n中查找nums中重复的元素
        int mid = (left + right) / 2;//对于值mid
        int cnt = 0;//统计<=mid的值的个数
        for (int num : nums) {
            if (num <= mid) cnt++;
        }
        //抽屉原理
        //对于值mid, 如果<=mid的值中没有重复值, 那么最多1~mid共mid个 <=mid的值
        //如果超过了, 就说明<=mid的值中有重复值，因此就可以缩小重复值的查找范围至left~mid 
        if (cnt > mid) right = mid;//重复值在left~mid的范围内
        else left = mid + 1;//说明重复值不在left~mid的范围内，而在mid+1~right中
    } 
    return left;
}
```

#### 复杂度分析

- 时间复杂度：O(nlogn)  

- 空间复杂度：O(1)


### 法二

==:star: **核心思路：快慢双指针   **:star:==

**:key:  key：**

- ![image-20240208103927090](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202402081039296.png)

- 找环入口就跟 [141. 环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)，[142. 环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/solution/huan-xing-lian-biao-ii-by-leetcode/) 一样啦

    > 「Floyd 判圈算法」（龟兔赛跑算法），用于环入口

#### 代码

```c++
int findDuplicate(vector<int>& nums) {
    int slow = 0, fast = 0;
    // 如果直接用while (slow != fast)那么一开始slow就=fast就不会进入循环
    do{
        slow = nums[slow];
        fast = nums[nums[fast]]; 
    }while (slow != fast);
    slow = 0;
    while (slow != fast) {
        slow = nums[slow];
        fast = nums[fast]; 
    }
    return slow;
}
```

#### 复杂度分析

- 时间复杂度：O(n)  

- 空间复杂度：O(1)

## :fire:[704. 二分查找](https://leetcode.cn/problems/binary-search/)

### 题意

**示例 1:**

```
输入: nums = [-1,0,3,5,9,12], target = 9
输出: 4
解释: 9 出现在 nums 中并且下标为 4
```

**示例 2:**

```
输入: nums = [-1,0,3,5,9,12], target = 2
输出: -1
解释: 2 不存在 nums 中因此返回 -1
```

**提示：**

1. 你可以假设 `nums` 中的所有元素是不重复的。
2. `n` 将在 `[1, 10000]`之间。
3. `nums` 的每个元素都将在 `[-9999, 9999]`之间。

### 代码

```cpp
int search(vector<int>& nums, int target) {
    int left = 0;
    int right = nums.size() - 1;
    while (left < right) {
        int mid = (left + right) / 2;
        if (nums[mid] < target) {
            left = mid + 1;
        } else if (nums[mid] > target) {
            right = mid;
        } else {
            return mid;
        }
    }
    return nums[left] == target ? left : -1;
}
```

## [lc374. 猜数字大小](https://leetcode.cn/problems/guess-number-higher-or-lower/)

### 题意

:  对方从1到n选一个数字，我可以通过调用guess API: `int guess(int num)`来判断我猜的数num比对方选的数大（返回-1）还是小（返回1）还是相等（返回0），要求返回对方选出的数字。

```c++
输入：n = 10, pick = 6
输出：6
```

### 代码

```c++
 int guessNumber(int n) {
    int left = 0, right = n;//选的数字在1~n之间
    while (left < right) {  
        int mid = left + (right - left) / 2;
        int x = guess(mid);//x是猜测结果
        //如果guess(n)返回0，则直接返回n
        if (x == 0) return mid;
        //如果返回-1，说明实际选的数字比我猜的小，所以我要往小了猜
        else if (x == -1) right = mid;
        //如果返回1，说明实际选的数字比我猜的大，所以我要往大了猜
        else if (x == 1) left = mid + 1;
    }
    return left;
 }
```

##  [lc35. 搜索插入位置](https://leetcode.cn/problems/search-insert-position/)

### 题意

给定一个升序数组和目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

```cpp
//示例1：
输入: nums = [1,3,5,6], target = 2
输出: 1
//示例 2：
输入: nums = [1,3,5,6], target = 7
输出: 4
```

### 代码

```cpp
int searchInsert(vector<int>& nums, int target) {
    int left = 0, right = nums.size();
    /* 【关于right的初始化】
    因为该题nums.size()是有可能成为答案的，所以可以初始化为nums.size()，相比初始化为nums.size()-1会少一次判断。只有在nums.size()不可能是答案的情况下，才必须初始化为nums.size()-1。right的初始化和「左闭右开」还是「左闭右闭」毫无关系。

    也就是说：设置的初始搜索区间[left,right]是什么，要看题目怎么说。

    也可以将right初始化为nums.size()-1，那接下来查找的范围就是0~nums.size()-1，因此对于数组所有元素都小于target的情况，由于target要插到nums.size()，nums.size()不在初始设定的查找范围[0,nums.size()-1]中，因此做个特判就好了，如下：
    int left = 0, right = nums.size() - 1;
    if (nums[num.size() - 1] < target) return nums.size();*/
    
    while (left < right) {  
        int mid = left + (right - left) / 2;
        if (nums[mid] < target) left = mid + 1;
        //比mid小的元素及其左边的元素都不可能是插入位置
        else right = mid;
    }
    return left;

    // 法二、把可能的答案用ans保存起来，因此初始应该为nums.size()。
    //这种解法类似lc34.在排序数组中查找元素的第一个和最后一个位置 其中的一个版本，由于有了 ans 变量，并且在 if 和 else 语句中 left 一定是 mid + 1，right 一定是 mid - 1，这种情况不会出现死循环，所以 while 里面可以写 left <= right。
    
    // int left = 0, right = nums.size() - 1, ans = nums.size();
    // while (left <= right) {
    //     int mid = left + (right - left) / 2;
    //     if (target <= nums[mid]) {
    //         ans = mid;//保存可能的答案
    //         right = mid - 1;
    //     } else left = mid + 1;
    // }
    // return ans;
}
```

## [lc278. 第一个错误的版本](https://leetcode.cn/problems/first-bad-version/)

### 题意

有 `n` 个版本 `[1...n]`，错误的版本之后的所有版本都是错的，请实现一个函数找出第一个错误的版本。

你可以通过调用 `bool isBadVersion(version)` 接口来判断版本号 `version` 是否在单元测试中出错。

**示例 1：**

```cpp
输入：n = 5, bad = 4
输出：4
解释：
调用 isBadVersion(3) -> false 
调用 isBadVersion(5) -> true 
调用 isBadVersion(4) -> true
所以，4 是第一个错误的版本。
```

### 代码

```c++
int firstBadVersion(int n) {
    int left = 1, right = n;
    // 版本1、
    while (left <= right) {
        int mid = left + (right - left) / 2;
        bool isBad = isBadVersion(mid);
        if (isBad) right = mid - 1;//右边界往左收缩
        //即使第一个错误的版本号就是mid,后right=mid-1会将结果mid弄出区间，也没关系
        //因为循环条件是left==right,因此left=right时还会进入循环，此时区间只有一个元素，
        //若这个元素isBad=true则这个元素就是结果，否则left=mid+1,不在当前区间的mid+1就是结果
        else left = mid + 1;//左边界往右收缩
    }
    return left;//退出循环时left==right,区间缩为一个点

    // 版本2、
    while (left < right) { //循环直至区间左右端点相同
        //如果取=,由于isBad=true时会right=mid,因此会死循环
        int mid = left + (right - left) / 2;
        bool isBad = isBadVersion(mid);
        if (isBad) right = mid;//右边界往左收缩
        else left = mid + 1;//左边界往右收缩
    }
    return left;//退出循环时left==right,区间缩为一个点
}
```

## [lc441. 排列硬币](https://leetcode.cn/problems/arranging-coins/)

### 题意

你总共有 `n` 枚硬币，并计划将它们按阶梯状排列。对于一个由 `k` 行组成的阶梯，其第 `i` 行必须正好有 `i` 枚硬币。阶梯的最后一行 **可能** 是不完整的。

给你一个数字 `n` ，计算并返回可形成 **完整阶梯行** 的总行数。

```c++
输入：n = 5
输出：2
解释：因为第三行不完整，所以返回 2 。
    
输入：n = 8
输出：3
解释：因为第四行不完整，所以返回 3 。
```

### 代码

```c++
int arrangeCoins(int n) {
    // 前k个完整阶梯所需硬币数量为：k(k+1)/2 <= n

    // 法一、数学
    // k(k+1)/2 <= n 移项后变为(k+1/2)^2<=1/4+2n,解得k<=(sqrt(8n+1)-1)/2,因此可以完整排列的行数为⌊ (sqrt(8n+1)-1)/2 ⌋, 向下取整
    return (int) ((sqrt((long long) 8 * n + 1) - 1) / 2);

    // 法二、二分
    // 因为随着行数的增加所需要的硬币数也是单调递增的
    // 求排mid行用的硬币数不超过n的最大mid解
    int left = 0, right = n;
    while (left <= right) {
        long mid = left + (right - left) / 2;
        long coins = ((mid + 1) * mid) / 2;
        if (coins == n) return mid;
        else if (coins < n) left = (int)mid + 1;
        //如果写成left=mid就会变成死循环，因为这样之后mid就一直都指向left，mid和left都更新不了
        else right = (int)mid - 1;
    } 
    return right;//最后right会<left
}
```



## [:fire: lc34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)

### 题意

有非递减顺序的整数数组 `nums`，和一个目标值 `target`。请你找出给定目标值在数组中的开始位置和结束位置。如果数组中不存在目标值 `target`，返回 `[-1, -1]`。

```c++
示例 1：
输入：nums = [5,7,7,8,8,10], target = 8
输出：[3,4]

示例 2：
输入：nums = [2,2], target = 2
输出：[0,1]
```

==:star: **核心思路：二分查找 **:star:==

### 法一

分开两次找第一个target的位置和最后一个target的位置。

```c++
int binarySearchStart(vector<int>& nums, int target) {
    int left = 0, right = nums.size() - 1;
    while (left < right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] < target) left = mid + 1;
        else right = mid;
    }
    return nums[left] == target ? left : -1;
}
int binarySearchEnd(vector<int>& nums, int target, int left) {
    int right = nums.size() - 1;
    while (left < right) {
        int mid = left + (right - left + 1) / 2;
        if (nums[mid] > target) right = mid - 1;
        else left = mid;
    }
    return nums[left] == target ? left : -1;
}
vector<int> searchRange(vector<int>& nums, int target) {
    if (nums.size() == 0) return {-1,-1};
    int start = binarySearchStart(nums, target);//找第一个target的位置
    if (start == -1) return {-1, -1};
    int end = binarySearchEnd(nums, target, start);//找最后一个target的位置
    return {start, end};
}
```

### 法二

先找>=target的第一个，再找>target的第一个。

```c++
vector<int> searchRange(vector<int>& nums, int target) {
    int len = nums.size(), left = 0, right = len - 1; 
    int start = binary_search(nums, target);//找>=target的第一个
    int end = binary_search(nums, target + 1) - 1;// 找>target第一个元素下标后减1
    if (start <= end) return vector<int>{start, end};
    return vector<int>{-1, -1};
}
int binary_search(vector<int>& nums, int tar) {
    int left = 0, right = nums.size() - 1;
    while (left <= right) {
        int mid = (left + right) / 2;
        if (nums[mid] >= tar) right = mid - 1;
        else left = mid + 1;
    }
    return left;
}
```

## :fire:[69. x 的平方根 ](https://leetcode.cn/problems/sqrtx/)

### 题意

给你一个非负整数 `x` ，计算并返回 `x` 的 **算术平方根** 。

由于返回类型是整数，结果只保留 **整数部分** ，小数部分将被 **舍去** 

**注意：**不允许使用任何内置指数函数和算符，例如 `pow(x, 0.5)` 或者 `x ** 0.5` 。

**示例 1：**

```
输入：x = 4
输出：2
```

**示例 2：**

```
输入：x = 8
输出：2
解释：8 的算术平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。
```

**提示：**

- `0 <= x <= 231 - 1`

### 代码

注意提示说`0 <= x <= 231 - 1`，因此要注意越界的问题。

```c++
int mySqrt(int x) {
    /* 二分 */
    if (x == 0) return 0;
    int left = 1; 
    int right = x / 2; 
    while (left < right) {
        int i = left + (right - left + 1) / 2;
        long long sqare = (long long) i * i;
        if (sqare < x) {
            left = i;
        } else if (sqare == x) {
            return i;
        } else {
            right = i - 1;
        }
    }
    return left;
}
```

## [540. 有序数组中的单一元素](https://leetcode.cn/problems/single-element-in-a-sorted-array/)

### 题意

给你一个仅由整数组成的有序数组，其中每个元素都会出现两次，唯有一个数只会出现一次。

请你找出并返回只出现一次的那个数。

你设计的解决方案必须满足 `O(log n)` 时间复杂度和 `O(1)` 空间复杂度。

**示例 1:**

```
输入: nums = [1,1,2,3,3,4,4,8,8]
输出: 2
```

**示例 2:**

```
输入: nums =  [3,3,7,7,10,11,11]
输出: 10
```

**提示:**

- `1 <= nums.length <= 105`
- `0 <= nums[i] <= 105`

### 思路

> 如果不管题目要求"`O(log n)` 时间复杂度和 `O(1)` 空间复杂度"的话，可以用:fire:[136. 只出现一次的数字](https://leetcode.cn/problems/single-number/)一样的思路做。

==:star: 核心思路：二分 :star:==

该题的二段性为01，即通过mid与前一位（mid为奇数）或后一位（mid为偶数）的比较，能确定单一元素一定出现在哪个区间（1），一定不会出现在其它区间（0）.

### 代码

原始版本

```c++
int singleNonDuplicate(vector<int>& nums) { 
    if (nums.size() == 1) {
        return nums[0];
    }
    int left = 0;
    int right = nums.size() - 1;
    while (left < right) {
        int mid = (left + right) / 2;
        if (mid % 2 == 0) {
            if (nums[mid] != nums[mid + 1]) {
                right = mid;
            } else {
                left = mid + 2;
            }
        } else {
            if (nums[mid] != nums[mid - 1]) {
                right = mid;
            } else {
                left = mid + 1;
            }
        }
    }
    return nums[left];
}
```

我们发现原始版本中代码重合度很高，我们可以统一执行逻辑为`right = mid;`和`left = mid + 1;`，然后再将分支合并。

怎么将`if (nums[mid] == nums[mid + 1])`和`if (nums[mid] == nums[mid - 1])`合并呢？

—— 使用`^`异或！

- 对于偶数mid，其与1异或之后相当于加1，即mid^1=mid+1 (mid为偶)

    > 偶数的最低位为0，与1（0··01）异或之后，其它位不变，最低位变成1

- 对于奇数mid，其与1异或之后相当于减1，即mid^1=mid-1 (mid为奇)

    > 奇数数的最低位为1，与1（0··01）异或之后，其它位不变，最低位变成0

最终版本：

```c++
int singleNonDuplicate(vector<int>& nums) {
    int left = 0, right = nums.size() - 1;
    while (left < right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] == nums[mid ^ 1]) left = mid + 1; 
            else right = mid;  
    } 
    return nums[left];
}
```

## [lc275. H 指数 II](https://leetcode.cn/problems/h-index-ii/)

### 题意

给一个升序整数数组 `citations` ， `citations[i]` 表示研究者的第 `i` 篇论文被引用的次数 。计算并返回该研究者的 h 指数。

[h 指数的定义](https://baike.baidu.com/item/h-index/3991452?fr=aladdin)： 指的是研究者的 （`n` 篇论文中）**至少** 有 `h` 篇论文都被引用了**至少** `h` 次。

提示：`0 <= citations[i] <= 1000`

```c++
输入：citations = [0,1,3,5,6]
输出：3
解释：给定数组表示研究者总共有 5 篇论文，每篇论文相应的被引用了 0, 1, 3, 5, 6 次。
     由于研究者有3篇论文每篇 至少 被引用了 3 次，其余两篇论文每篇被引用 不多于 3 次，所以她的 h 指数是 3 。
```

此题关键在于理解题意！！！

**分析题意：**

注意！！！h 指数是 论文数量，不是引用次数！！！

The h-index is defined as 【the maximum value of h】 such that the given researcher has published at least h papers that have each been cited at least h times.（the true least cited times may > h, so we should return 满足要求的区间长度，而不是至少被引用的次数）

总之就是，我们要返回选取的区间的长度，而我们选取的区间要满足：区间中的数>=区间的长度。

核心是我们要返回选取的区间的长度，而我们选取的区间要满足：区间中的数>=区间的长度。

可以将h指数的定义调整为这样理解：存在一个数量h，使得这h篇论的引用次数均大于等于h。这样的数值称为h指数。

![image-20231207215800290](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202312072158336.png)

### 代码

```c++
int hIndex(vector<int>& citations) {
    int n = citations.size();
    if (citations[n - 1] == 0) return 0;//如果全部文章的引用次数都为 0，则 h 指数为 0
    int left = 0, right = n - 1;
    while (left < right) {
        int mid = left + (right - left) / 2;
        // citations[mid] 表示分割线右边的文章的最少引用的次数
        // 如果 区间中的数(看左边界值就好) < 区间的长度,比如[0,| 1, 3, 5, 6], 说明分割线太靠左了，下一轮应该往右边找
        if (citations[mid] < n - mid) left = mid + 1;
        //否则说明 区间中的数 > 区间的长度,此时的区间长度可能是结果，我们要继续往左找看是否有更长的结果
        else right = mid;
    }
    return n - left;//返回区间长度
}
```

## [lc436. 寻找右区间](https://leetcode.cn/problems/find-right-interval/)

### 题意

:  区间数组 `intervals` 中 intervals[i] = [start ~i~ , end ~i~] ，且**每个 start ~i~ 都不同** 。对于每个区间intervals[i]，我们可以用其索引`i`表示。

 `i` 的 **右侧区间** 可以记作区间 `j` ，并满足 start ~j~ >= end ~i~ ，且 **start ~j~ 最小化** 。注意 `i` 可能等于 `j` 。

返回一个由每个区间 `i` 的 **右侧区间** 对应下标组成的数组。如果某个区间 `i` 不存在对应的 **右侧区间** ，则结果数组的下标 `i` 的值为 `-1` 。

```cpp
示例 1：
输入：intervals = [[3,4],[2,3],[1,2]]
输出：[-1,0,1]
解释：对于 [3,4] ，没有满足条件的“右侧”区间。
          对于 [2,3] ，区间[3,4]具有最小的“右”起点;
          对于 [1,2] ，区间[2,3]具有最小的“右”起点。
示例 2：
输入：intervals = [[1,4],[2,3],[3,4]]
输出：[-1,2,-1]
解释：对于区间 [1,4] 和 [3,4] ，没有满足条件的“右侧”区间。
	  对于 [2,3] ，区间 [3,4] 有最小的“右”起点。
```

总结题意：对于每一个interval[i], 都要往后看，是否存在interval[j]，使得`interval[j][0] `>= `interval[i][1] `(j > i)，若存在，找到`interval[j][0]`值最小的那个j，并返回j,否则返回-1。注意到提示说start不重复，也即`interval[j][0]`不会重复。

### 法一

#### 思路

==:star: **核心思路： 先排序，后二分   **:star:==

**:question:   problems:** 

1. 为什么要排序？为什么想到用二分？
2. 根据什么排序？
3. 选择什么数据结构?

:heavy_check_mark:  **answer:** 

1. 因为对于每一个interval[i]，要找一个start（即`interval[j][0]`）最小的`interval[j]`，满足`interval[j][0]` >= `interval[i][1]`，返回其下标 j。**看到关键字「大于等于」，显然需要使用二分查找算法，而二分查找是要在有序的条件下进行，因此需要排序。**而且不排序的话那不就只能暴力遍历了吗，暴力遍历的时间复杂度是O(n^2)，而排个序只需要O(logn)，算上之后遍历intervals的时间也就O(nlogn)

2. 因为要二分查找 >= `interval[i][1]`的最小的`interval[j][0]`，`interval[i][1]`固定，找`interval[j][0]`，因此`interval[j][0]`就相当于要查找的key

3. 选择用什么数据结构就要想清楚我们要存放哪些东西。由上一问我们能知道，肯定需要左端点start（即`interval[ ][0]`）作为查找的key；另外，题目要求返回的是找到的右侧区间对应的索引，因此还需要存放每个区间`intervals[i]`的索引`i`。

    要存放两个int，就想到了两种数据结构：vector<pair<int, int>> 和 map<int, int> (因为题目中说每个 start ~i~ 都不同，也就是key都不会相同（因此不需要用multimap），而且要是有序的（因此不考虑unordered_map）)。这两种都可以做，其中

    - vector<pair<int, int>需要先遍历intervals将元素全存到vector中，遍历结束再调用sort()排序，sort()的时间复杂度是O(nlogn)，之后遍历intervals求结果数组，因此总的时间复杂度是O(nlogn)；
    - map<int, int>则是在遍历intervals将元素插到map的同时就会进行排序，由于map是用红黑树实现的，插入的时间复杂度是O(logn)，因此插入同时排序的总时间复杂度就是O(nlogn)。
    - 因此这两种的时间复杂度都是O(nlogn)，空间复杂度都是O(n)

#### 代码

##### 实现1

```c++
  vector<int> findRightInterval(vector<vector<int>>& intervals) {
    int n = intervals.size();
    vector<int> res(n, -1);
    vector<pair<int, int>> sortfirst;//pair.first = intervals[i][0] , pair.second = i
    for (int i = 0; i < n; ++i) sortfirst.emplace_back(intervals[i][0], i);
    //或者写成 
    //for (int i = 0; i < n; ++i) sortfirst.push_back(make_pair(intervals[i][0], i));
    sort(sortfirst.begin(), sortfirst.end());
    // [对pair排序] 默认以first升序，当first相同时以second升序
    for (int i = 0; i < n; ++i) { //遍历intervals
        
        //第一种、自己实现查找逻辑：
        int target = intervals[i][1];//在sortfirst中查找第一个大于target的pair.first
        int left = 0, right = n - 1;//left不是初始化为i+1！因为sortfirst已经是排过序(打乱了原来顺序的)
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (sortfirst[mid].first >= target) right = mid;//说明mid之后的pair.first一定不会是大于target中最小的，因此往[left,mid]找
            else left = mid + 1;//说明mid之前的pair.first一定小于target，因此往[mid+1,right]找
        }
        //退出循环的时候left与right重合，判断最后剩下的这个元素是否满足条件，如果不满足，说明原本就不存在满足条件的元素，满足则直接返回答案
        res[i] = sortfirst[left].first >= target ? sortfirst[left].second : -1;
            
        ============================================================
        
        // 第二种、直接调用库函数
        auto it = lower_bound(sortfirst.begin(), sortfirst.end(), intervals[i][1], [](const pair<int, int>& p, int val){return p.first < val;});
        /* 可以用lambada表达式自定义【比较规则】来比较intervals[i][1]和pair.first。
        return p.first < val表示如果如果 p.first<val，那么返回 true，表示迭代器应该后移，继续查找；如果 p.first>=val，那么返回false，表示 p 已经是第一个不小于 val 的元素，终止查找。【也就是说返回true表示还需要继续查找，返回false表示终止查找】
        */
        
        // 或者写成 （pair与pair比较）
        // auto it = lower_bound(sortfirst.begin(), sortfirst.end(), make_pair(intervals[i][1], 0));
        /* 
        lower_bound(begin,end,num): 从数组的begin位置到end-1位置二分查找第一个大于或等于num的元素，返回其下标对应的迭代器。
         为什么和intervals[i][1] make_pair的是0？pair.second不是索引吗？
         第二个元素0，这是一个占位符。在这个比较过程中，实际上我们只关心 pair 中的第一个元素。但是如果将第三个参数换成其他常数，理论上是不会影响结果的，但实际上lower_bound()在寻找符合条件的pair时，会根据第三个参数的不同导致整体比较的结果发生变化。所以就记住这里就是用0作一个占位符就好了 
         */
        if (it != sortfirst.end()) res[i] = it->second;
    }
    return res;
}
```

##### 实现2

```c++
vector<int> findRightInterval(vector<vector<int>>& intervals) {
    int n = intervals.size();
    vector<int> res(n, -1);
    map<int, int> map;
    int index = 0;
    for (auto vec : intervals) map[vec[0]] = index++;//插入同时就会进行排序
    //接下来直接在map中查找
    index = 0;
    for (auto vec : intervals) {
        auto it = map.lower_bound(vec[1]);
        //不能写成auto it = lower_bound(map.begin(), map.end(), vec[1]);
        //因为<algorithm>中的lower_bound()是用于有序序列式容器的，不能用于有序关联式容器，要用只能用map中的lower_bound()成员函数
        if (it != map.end()) res[index] = (*it).second;
        //因为前面已经初始化过res的大小了，因此不能写成res.emplace_back((*it).second);
        ++index;
    }
    return res;
}
```

#### 复杂度分析

在前面的:heavy_check_mark:  **answer:** 中就已经分析了

- 时间复杂度：O(nlogn)  

- 空间复杂度：O(n)

  ​    

### 法二

#### 思路

==:star: **核心思路： 先排序，后双指针   **:star:==

**:question:   problems:** 

1. 为什么查找的时间复杂度是O(n)而不是O(n^2^) ?

:heavy_check_mark:  **answer:** 

1. 因为有序，因此遍历查找的时候就可以跳过之前遍历过的元素直接接着前面的遍历，而不是每次都要从0开始重新遍历。
    如果 j 在每次外部循环迭代中都从0开始，那么就是O(n^2)。但在这个算法中，j 是持续递增的，因此是O(n)。
    通过分析也可以知道，**i 和 j 各自最多遍历数组一次**

**:small_red_triangle_down: steps: **

1.  将start,index和end,index都作为pair，分别存到数组startV和endV中
2.  排序 sort(): O(nlogn)
3.  查找 O(n)

#### 代码

```c++
vector<int> findRightInterval(vector<vector<int>>& intervals) {
    int n = intervals.size();
    vector<int> res(n, -1);
    vector<pair<int, int>> startV(n), endV(n); //pair.first是每个区间的start or end,  pair.second都是对应的下标
    for (int i = 0; i < n; ++i) {
        startV[i] = make_pair(intervals[i][0], i);
        endV[i] = make_pair(intervals[i][1], i);
    }
    //排序，为后面的查找做准备: O(nlogn)
    sort(startV.begin(), startV.end());
    sort(endV.begin(), endV.end());
    //查找: O(n) 
    for (int i = 0, j = 0; i < n && j < n; ++i) {  
        int target = endV[i].first;//根据target进行查找，找 start j >= end i 的 j
        while (j < n && startV[j].first < target) ++j;
        //如果start j < end i, 那么这个j肯定不是答案，跳过，往右边找start更大的，顺序往后找肯定能找到
        if (j < n) res[endV[i].second] = startV[j].second;
        //此时停下来的这个位置肯定就是答案（除非超出数组下标范围了）
    }
    return res;
}
```

#### 复杂度分析

在前面的:heavy_check_mark:  **answer:** 中就已经分析了

- 时间复杂度：O(nlogn)  

- 空间复杂度：O(n)

## :fire:[162. 寻找峰值](https://leetcode.cn/problems/find-peak-element/)

### 题意

峰值元素是指其值**严格大于左右相邻值**的元素。

给你一个整数数组 `nums`，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 **任何一个峰值** 所在位置即可。

设 `nums[-1] = nums[n] = -∞` , 所有 `nums[i] != nums[i + 1]`。你必须实现时间复杂度为 `O(log n)` 的算法.。

**示例 1：**

```cpp
输入：nums = [1,2,3,1]
输出：2
解释：3 是峰值元素，你的函数应该返回其索引 2。
```

**示例 2：**

```cpp
输入：nums = [1,2,1,3,5,6,4]
输出：1 或 5 
解释：你的函数可以返回索引 1，其峰值元素为 2；
     或者返回索引 5， 其峰值元素为 6。
```

### 法一

#### 思路

==:star: **核心思路： 寻找最大值   **:star:==（虽然时间复杂度是O(n) 但是可以学习这种思路）  

最大值两侧的元素一定严格小于最大值本身。因此，最大值所在的位置就是一个可行的峰值位置。

我们遍历一次nums，找到最大值对应的位置即可。

#### 代码

```c++
int findPeakElement(vector<int>& nums) {
        return max_element(nums.begin(), nums.end()) - nums.begin();
}
```

#### 复杂度分析

- 时间复杂度：O(n)  

- 空间复杂度：O(1)

### 法二

#### 思路

==:star: **核心思路： 二分   **:star:==

:key:  **key**：

- 因为题目说`nums[-1] = nums[n] = -∞`，这就代表着 只要数组中存在一个元素比左边相邻元素大，那么沿着它【一定可以找到】一个峰值。

- 联想爬山，如果你往下坡方向走，也许可能遇到新的山峰，但是也可能是一个一直下降的坡，最后到边界. 这个结果是不确定的（即我们无法确定继续走是否还能遇到山顶）。

    但是如果你往上坡方向走，就算最后一直上的边界，由于最边界是负无穷，所以就一定能找到山峰，

    总的一句话，往递增的方向上找，一定能找到峰顶，往递减的方向找可能找到，也可能找不到。

- 意思就是：如果nums[i-1]<nums[i]，那么沿着 i 往右走一定能找到一个峰值。
    
- :star: ==对于如何使用mid缩小查找区间，我们牢记一个**原则：每次更新区间后保证目标在搜索区间[l,r]内**（如果不能保证就舍弃区间）==:star:

**:question:   problems:** 

1. 为什么想到用二分?

:heavy_check_mark:  **answer:** 

1. 想不到用二分的话，主要还是对二分性理解不透彻的问题。==**我们应当从是否具有「二段性」来考虑是否可以进行「二分」**==。

    这里的**「二段性」**是从：【在以mid为分割点的数组上，根据nums[mid] 与 nums[mid±1] 的大小关系，可以确定其中一段满足「必然有解」，另外一段不满足「必然有解」（可能有解，可能无解）】看出的。

:smiley: **收获： ** 

1. 学到了 非有序数组也能用二分！还是对二分性理解不透彻

2. 对" 对于如何使用mid缩小查找区间，我们牢记一个原则：每次更新区间后保证目标在搜索区间[l,r]内（如果不能保证就舍弃区间）"理解得更透彻了

3. "在 [lc33. 搜索旋转排序数组](https://leetcode.cn/problems/search-in-rotated-sorted-array/) 中，我们强调，==二分的本质是「二段性」而非「单调性」==，而经过本题，我们进一步发现「二段性」还能继续细分，==不仅仅只有满足 01 特性（满足/不满足）的「二段性」可以使用二分，满足 1? 特性（一定满足/不一定满足）也可以二分。==" 三叶姐总结的太好了呀！


#### 代码

```c++
int findPeakElement(vector<int>& nums) {
/*
    log n考虑二分
    如果nums[i-1]<nums[i]，那么沿着i往右走一定能找到峰值
*/ 
    int left = 0, right = nums.size() - 1;
    while (left < right) {
        int mid = (left + right + 1) / 2;
        if (nums[mid - 1] <= nums[mid]) {
            left = mid;
        } else {
            right = mid - 1;
        }
    }
    return left;
}
```

#### 复杂度分析

- 时间复杂度：O(logn)  

- 空间复杂度：O(1)

## :crossed_swords: [剑指Offer04. 二维数组中的查找](https://leetcode.cn/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/)

### 题意

在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

示例:

```c++
现有矩阵 matrix 如下：
[ [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]]
给定 target = 5，返回 true。
给定 target = 20，返回 false。
```

### 思路

==:star: **核心思路：二分   **:star:==

**:key:  key：**

- 从左下角或者右下角开始二分查找，因为同一列往上所有元素都<该位置的值，同一行往右所有元素都>该位置的值，相当于以该值为拐点形成L型递增序列。

**:x: careless | ignore :  **

- 和[240. 搜索二维矩阵 II](https://leetcode.cn/problems/search-a-2d-matrix-ii/)一样但是240更简单，不需要考虑数组为空的情况。这题的思路都知道但是细节没注意到（数组为空时根本不存在nums[0]，因此此时nums[0].size()的写法也是不合法的）

### 代码

```c++
bool findTargetIn2DPlants(vector<vector<int>>& nums, int target) {
    int n = nums.size();
    // 注意nums={}时nums.size()=0,此时不存在nums[0],
    // 因此如果直接就接着写m=nums[0].size()就会报错
    if (n == 0) return false;//为空数组
    int m = nums[0].size();
    int i = n - 1, j = 0;
    while (i >= 0 && j < m) {
        if (target == nums[i][j]) return true;
        else if (target < nums[i][j]) i--;//往上走
        else j++;//往右走
    }
    return false;
}
```

可以简化成：

```c++
bool findTargetIn2DPlants(vector<vector<int>>& nums, int target) {
    int i = nums.size() - 1, j = 0;
    while (i >= 0 && j < nums[0].size()) {
        if (target == nums[i][j]) return true;
        else if (target < nums[i][j]) i--;//往上走
        else j++;//往右走
    }
    return false;
}
```

### 复杂度分析

- 时间复杂度：O(n+m)  

- 空间复杂度：O(1)

##  :two:[74. 搜索二维矩阵](https://leetcode.cn/problems/search-a-2d-matrix/)

### 题意

给你一个满足下述两条属性的 `m x n` 整数矩阵：

- 每行中的数从左到右按非严格递增顺序排列。
- 每行的第一个数 > 前一行的最后一个数。

给你一个整数 `target` ，如果 `target` 在矩阵中，返回 `true` ；否则，返回 `false` 。

**示例 1：**

![](https://assets.leetcode.com/uploads/2020/10/05/mat.jpg)

```cpp
输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3
输出：true
```

**示例 2：**

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/mat2.jpg)

```
输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13
输出：false
```

 **提示：**

- `m == matrix.length`
- `n == matrix[i].length`
- `1 <= m, n <= 100`
- `-104 <= matrix[i][j], target <= 104`

### 参考题解

1. [官解](https://leetcode.cn/problems/search-a-2d-matrix/solutions/688117/sou-suo-er-wei-ju-zhen-by-leetcode-solut-vxui/) 

### 法一 (推荐)

==:star: **核心思路：减而治之 **:star:==

矩阵的第二条性质：每行的第一个数 > 前一行的最后一个数，其实就保证了每列的元素从上到下升序排列。因此这一题和:fire:[240. 搜索二维矩阵 II](https://leetcode.cn/problems/search-a-2d-matrix-ii/)其实是一样的，都可以用减而治之的思想来做。

如果选择左下角为起点

```c++
bool searchMatrix(vector<vector<int>>& matrix, int target) {
/*
从左下角（或右上角）开始搜索，利用矩阵中同一列从下往上递减，同一行中从左往右递增的性质进行查找。
*/
    int m = matrix.size();
    int n = matrix[0].size();
    int i = m - 1;
    int j = 0;
    while (i >= 0 && j < n) {
        if (matrix[i][j] == target) {
            return true;
        } else if (matrix[i][j] < target) {
            j++;
        } else {
            i--;
        }
    }
    return false;
}
```

**复杂度分析**

- 时间复杂度：O(m+n) 。这种算法是 **不回头** 的，至多走 M+N 步就能搜索到目标数值，或者判定目标数值在矩阵中不存在；
- 空间复杂度：O(1)

### 法二 (推荐)

==:star: **核心思路： 二分   **:star:==

两次二分查找。先在第一列中进行二分查找，找到最后一个不大于target的行首，然后在该行中二分查找target。

直接调用库函数的写法：

```c++
bool searchMatrix(vector<vector<int>>& matrix, int target) {
    // upper_bound()查找第一个大于target的行，找不到返回begin()
   auto row = upper_bound(matrix.begin(), matrix.end(), target, [](int b, const vector<int>& a){ return a[0] > b;}); 
    // 如果lambada中参数写反会报错，因为比较的方向就会颠倒。
    if (row == matrix.begin()) return false;
    --row;
    return binary_search(row->begin(), row->end(), target);
}
```

自己实现库函数的写法：

```c++
bool searchMatrix(vector<vector<int>>& matrix, int target) {
    int rowIndex = binarySearchFirstRow(matrix, target);
    if (rowIndex < 0) return false;
    return binarySearchColumn(matrix[rowIndex], target);
}
int binarySearchFirstRow(vector<vector<int>>& matrix, int target) {
    // 二分查找第一个不大于target的行首
    int left = 0, right = matrix.size() - 1;
    while (left < right) {
        int mid = left + (right - left + 1) / 2;
        if (matrix[mid][0] <= target) left = mid;
        else right = mid - 1;
    }
    return matrix[left][0] <= target ? left : -1;//返回所在行
}
bool binarySearchColumn(vector<int>& targetRow, int target) {
    // 二分查找targetRow中=target的元素
    int left = 0, right = targetRow.size() - 1;
    while (left < right) {
        int mid = left + (right - left) / 2;
        if (targetRow[mid] < target) left = mid + 1;
        else if (targetRow[mid] > target) right = mid - 1;
        else return true;
    }
    return targetRow[left] == target;
}
```

**复杂度分析**

- 时间复杂度：O(log⁡m+log⁡n)=O(log⁡mn)

- 空间复杂度：O(1)

> 注意！当二维数组中的一维数组size不相等时，法一仍能正确处理，但是法二会失效。

### 法三

一次二分查找。

因为将二维矩阵的行尾和行首相连，按'Z'字形遍历，也具有单调性。因此可以将二维变一维来做二分查找，关键在于<u>**将mid映射为二维下标**</u>。

给mid映射为二维下标`midValue = matrix[mid / n][mid % n];`以求得mid下标对应的值，通过比较该值和target来二分。

```c++
bool searchMatrix(vector<vector<int>>& matrix, int target) {
        int m = matrix.size(), n = matrix[0].size();
        int left = 0, right = m * n - 1; 
        while (left < right) {
            int mid = left + (right - left) / 2;
            int midValue = matrix[mid / n][mid % n]; 
            if (midValue < target) left = mid + 1;
            else if (midValue > target) right = mid - 1;
            else return true;
        }
        return matrix[left / n][left % n] == target;
}
```

**复杂度分析**

- 时间复杂度：O(log⁡m+log⁡n)=O(log⁡mn)

- 空间复杂度：O(1)

## :fire:[240. 搜索二维矩阵 II](https://leetcode.cn/problems/search-a-2d-matrix-ii/)

### 题意

编写一个高效的算法来搜索 `m*n` 矩阵 `matrix` ,目标值 `target` 。该矩阵具有以下特性：

- 每行的元素从左到右升序排列。
- 每列的元素从上到下升序排列。

**示例 1：**

![image-20231213081809847](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202312130818897.png)

```cpp
输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5
输出：true
```

**提示：**

- `m == matrix.length`
- `n == matrix[i].length`
- `1 <= n, m <= 300`
- `-109 <= matrix[i][j] <= 109`
- 每行的所有元素从左到右升序排列
- 每列的所有元素从上到下升序排列
- `-109 <= target <= 109`

### 参考题解

1. [liweiwei大佬](https://leetcode.cn/problems/search-a-2d-matrix-ii/solutions/14389/er-fen-fa-pai-chu-fa-python-dai-ma-java-dai-ma-by-/)

### 思路

> 和一般的二分有不一样的地方在于我们每次排除的范围不是一个规则线性的空间，而是一个区域

==:star: **核心思路：减而治之 **:star:==

从左下角（或右上角）开始搜索，利用矩阵中同一列从下往上递减，同一行中从左往右递增的性质进行查找。

**:question:   problems:** 

1. 为什么要从左下角或者右上角开始?

:heavy_check_mark:  **answer:** 

1. 如果从左上角开始走，发现横着走数值增大，竖着走数值也增大，也就是说目标数值这在两个方向上都有可能存在。

    但如果我们从右上角或者左下角出发找目标元素，那就可以确定一个维度，于是就能减而治之。

### 代码

如果选择左下角为起点

```c++
bool searchMatrix(vector<vector<int>>& matrix, int target) {
    int m = matrix.size();
    int n = matrix[0].size();
    int i = m - 1;
    int j = 0;
    while (i >= 0 && j < n) {
        if (matrix[i][j] == target) {
            return true;
        } else if (matrix[i][j] < target) {
            j++;
        } else {
            i--;
        }
    }
    return false;
}
```

> 说明：这个搜索的过程也可以使用二分查找法加快，时间复杂度优化到 O(log⁡M+longN)=O(log⁡MN)，但是在编码的时候会稍显麻烦。
>

### 复杂度分析

- 时间复杂度：O(m+n) 。这种算法是 **不回头** 的，至多走 M+N 步就能搜索到目标数值，或者判定目标数值在矩阵中不存在；
- 空间复杂度：O(1)

## [378. 有序矩阵中第 K 小的元素](https://leetcode.cn/problems/kth-smallest-element-in-a-sorted-matrix/)

### 题意

给你一个 `n x n` 矩阵 `matrix` ，其中每行和每列元素均按升序排序，且保证 `matrix` 中的所有行和列都按 **非递减顺序** 排列。

找到矩阵中第 `k` 小的元素。你必须找到一个内存复杂度优于 `O(n^2)` 的解决方案。

**示例 1：**

```cpp
输入：matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8
输出：13
解释：矩阵中的元素为 [1,5,9,10,11,12,13,13,15]，第 8 小元素是 13
```

### 参考题解

1. [笨猪爆破组](https://leetcode.cn/problems/kth-smallest-element-in-a-sorted-matrix/solutions/311472/you-xu-ju-zhen-zhong-di-kxiao-de-yuan-su-by-leetco/)
2. [mkdir700](https://leetcode.cn/problems/kth-smallest-element-in-a-sorted-matrix/solutions/326369/ci-ti-er-fen-cha-zhao-guo-cheng-de-dong-tu-yan-shi/) 动图很清晰

### 思路

==:star: **核心思路：值域的二分  + 计数 **:star:==

**:key:  key：**

- 该二维矩阵中，左上角元素是下限leftVal，右下角元素是上限rightVal，就有了一个值域leftVal~rightVal，第 `k` 小的元素在这个值域中。
- 每次根据值域的中间值来分割矩阵（对值域二分），并求出值域中<=中间值的元素个数cnt，和 k 比较，如果比 k 小，说明第k小的数在右半部分，调整值域范围让leftVal=midVal+1，否则说明第k小的数在左半部分，让rightVal=midVal。每次缩小值域范围都要保证第k小的数在leftVal~rightVal之间。

**:question:   problems:** 

1. 为什么对值二分？


:heavy_check_mark:  **answer:** 

1. 二分查找可以根据索引二分，也可以根据数值二分，有序数组中，索引的大小可以反映值的大小，对索引二分就行。
    但这里不是有序的一维数组，索引不能体现值谁大谁小，无法通过二分索引逼近目标值

**:small_red_triangle_down: steps: **

1.   取leftVal和rightVal的中间值来做分割线，分割线midVal的这个值把leftVal~rightVal的数值范围划分成了两部分（分割不一定是平整的，也即分割线不一定是笔直的），对应在矩阵上这两部分就是一个在矩阵左半部分，一个在矩阵右半部分。
2.  从左下角出发，分割矩阵（根据值是否<=midVal，是则划分到左边，否则划分到右边），同时记录分割线左半部分的元素个数。当走完矩阵边界（i=0或j=n-1）时就说明该次分割完毕。
3.  根据分割线左边的元素数cnt与k的大小关系，来决定往哪边缩小查找区间
    - 如果cnt>=k, 则说明第k小的数在左半部分,我们让rightVal=midVal；
    - 否则说明第k小的数在右半部分, 我们让leftVal=midVal+1

:smiley: **收获： ** 

- left, mid, right 不一定就得是索引下标，也可以是值，即二分也可以是对值域的二分。

### 代码

```c++
int kthSmallest(vector<vector<int>>& matrix, int k) {
    int n = matrix.size();
    int leftVal = matrix[0][0], rightVal = matrix[n - 1][n - 1];
    //leftVal是矩阵中最小的元素，rightVal是矩阵中最大的元素,第k小的元素值一定在leftVal~rightVal这个范围
    while (leftVal < rightVal) {
        // 取leftVal和rightVal的中间值来做分割线
        int midVal = leftVal + (rightVal - leftVal) / 2;
        // 根据分割线左边的元素数cnt与k的大小关系，来决定往哪边缩小查找区间
        int cnt = findNotBiggerThanMid(matrix, midVal, k, n);
        //如果cnt>=k,则说明第k小的数在左半部分,我们让rightVal=midVal
        if (cnt >= k) rightVal = midVal;
        //否则说明第k小的数在右半部分,我们让leftVal=midVal+1
        else leftVal = midVal + 1;
    }
    return leftVal;
}
int findNotBiggerThanMid(vector<vector<int>>& matrix, int midVal, int k, int n) {
    // 从左下角开始，以midVal为分割线，一步步走分割值域,直到i走完到第一行或最后一列。走的轨迹就是分割线
    int i = n - 1, j = 0, cnt = 0;
    while (i >= 0 && j < n) {
        if (matrix[i][j] <= midVal) { 
            cnt += i + 1;//当前列有i+1个元素<=mid
            ++j;//继续往右走
        }
        else --i;//往上走
    }
    return cnt;
}
```

### 复杂度分析

- 时间复杂度：O(n * log⁡(rightVal-leftVal))

    二分查找为 O(log⁡(rightVal-leftVal))，其中每次操作（一步步走，以分割值域）时间复杂度为 O(n)，n是矩阵的行数。

- 空间复杂度：O(1)


## [lc668. 乘法表中第k小的数](https://leetcode.cn/problems/kth-smallest-number-in-multiplication-table/)

### 题意

乘法表是 `m x n` 的整数矩阵，其中 `mat[i][j] == i * j`（下标从 **1** 开始）。

请你在 `m x n` 乘法表中，找出并返回第 `k` 小的数字。

**示例 1：**

![image-20231213164709962](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202312131647041.png)

```cpp
输入：m = 3, n = 3, k = 5
输出：3
解释：第 5 小的数字是 3 。
```

### 思路

==:star: **核心思路： 二分 + 计数  **:star:==   同上一题：  [lc378. 有序矩阵中第 K 小的元素](https://leetcode.cn/problems/kth-smallest-element-in-a-sorted-matrix/)

### 代码

```c++
int findKthNumber(int m, int n, int k) {
    int left = 1, right = m * n;
    while (left < right) {
        int mid = left + (right - left) / 2;
        int cnt = getCntNotBiggerThanMid(m, n, mid);
        if (cnt >= k) right = mid;
        else left = mid + 1;
    }
    return left;
}
int getCntNotBiggerThanMid(int m, int n, int mid) {
    //从左下角开始，以mid为分割线分割矩阵
    int i = m, j = 1, cnt = 0;
    while (i >= 1 && j <= n) {
        int num = i * j;
        if (num <= mid) { //比mid小，分在左边
            ++j;//往右走
            cnt += i;//同一列上方所有元素都<mid
        }
        else --i;//往上走
    }
    return cnt;
}
```

### 复杂度分析

- 时间复杂度：O(m * log mn) 
- 空间复杂度：O(1)


## [lc410. 分割数组的最大值](https://leetcode.cn/problems/split-array-largest-sum/)

### 题意

给定一个非负整数数组 `nums` 和一个整数 `k` ，你需要将这个数组分成 `k` 个非空的**连续子数组**。

设计一个算法使得这 `k` 个子数组各自和的最大值最小。

**示例 1：**

```cpp
输入：nums = [7,2,5,10,8], k = 2
输出：18
解释：
一共有四种方法将 nums 分割为 2 个子数组。 
其中最好的方式是将其分为 [7,2,5] 和 [10,8] 。
因为此时这两个子数组各自的和的最大值为18，在所有情况中最小。
```

### 参考题解

1. [liweiwei大佬](https://leetcode.cn/problems/split-array-largest-sum/solutions/242909/er-fen-cha-zhao-by-liweiwei1419-4/) 

### 思路

==:star: **核心思路：「使最大值最小化」-->二分查找   **:star:==

此题难点在于如何将其与二分联系起来。

**:key:  key：**

- 如果某个 数组各自和的最大值 恰好使得分割次数为k，此时不能放弃搜索，而要继续尝试缩小这个【数组各自和的最大值】，使得这个最大值 最小化 ，直到分割次数超过 k ，超过k的最后一个使得分割数为k的 【数组各自和的最大值】就是我们要找的 最小值。


**:question:   problems:** 

1. 怎么想到用二分来做的?

:heavy_check_mark:  **answer:** 

1. 回顾二分的应用：查找一个有范围的整数。而该题我们要查找的数是【子数组各自和的最大值】，这个值一定在maxVal~sum之间（mavVal指数组中元素的最大值，sum为数组元素之和）。

    我们可以分析知道【子数组各自和的最大值】与【分割次数】的关系：

    - 【分割次数】少了 <=>【子数组各自和的最大值】大了

    - 【分割次数】多了 <=>【子数组各自和的最大值】小了

        > 分割次数的多与少，是相对题目给定的 k 而言的

    因此我们可以先让【子数组各自和的最大值】=mid，根据mid计算数组的分割次数cnt，之后根据cnt是多了还是少了（与k比较），动态调整mid的值。

**:small_red_triangle_down: steps: **

1.  求二分上下界（即二分初始范围）
2.  二分
    1.  计算mid
    2.  计算【子数组各自和的最大值】为mid时的分割次数
        - 如果分割次数多了，说明mid小了
        - 如果分割次数少了，说明mid大了


### 代码

```c++
int splitArray(vector<int>& nums, int k) {
    int sum = 0, maxVal = 0;//二分的上下界（「子数组各自的和的最大值」的上下界）
    for (auto val : nums) {
        maxVal = max(maxVal, val);//得到最大元素值，数组和最小不小于这个值
        sum += val;//得到nums元素总和
    }
    int left = maxVal, right = sum;
    while (left < right) {
        int mid = left + (right - left) / 2;
        int splitCnt = split(nums,mid);//计算【子数组各自和的最大值】为mid时的分割次数
        //如果分割次数多了，说明mid小了
        if (splitCnt > k) left = mid + 1;
        //如果分割次数少了，说明mid大了
        else right = mid;
    }
    return left;
}
int split(vector<int>& nums, int maxValOfIntervals) {
    //maxValOfIntervals:子数组各自的和的最大值
    int splitCnt = 1;//分割次数最小为1
    int IntervalSum = 0;
    for (auto num : nums) {
        if (IntervalSum + num > maxValOfIntervals) { //若加上当前元素num后当前子数组的和 超过了maxValOfIntervals, 则当前子数组就不算上num，并且另起下一个分割
            IntervalSum = 0;
            ++splitCnt;                
        }
        IntervalSum += num;
    }
    return splitCnt;
}
```

### 复杂度分析

- 时间复杂度：O(n * log(sum-maxVal))  

    二分的时间复杂度为O(log(sum-maxVal))，其中每次操作（计算【子数组各自和的最大值】为mid时的分割数）需要遍历数组计算，为O(n)

- 空间复杂度：O(1)

