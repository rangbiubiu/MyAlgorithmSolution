## ğŸ’›æ€»ç»“

- è®¾è®¡é“¾è¡¨--æ’åˆ æŸ¥
- è™šæ‹Ÿå¤´ç»“ç‚¹
- åŒæŒ‡é’ˆ
- åè½¬é“¾è¡¨
- ç¯

## :car:[lc707 è®¾è®¡é“¾è¡¨](https://leetcode.cn/problems/design-linked-list/)

```c++
class MyLinkedList {
public:
    struct Listnode { //å®šä¹‰é“¾è¡¨ç»“ç‚¹ç»“æ„ä½“
        int val;
        Listnode* next;
        //ä¸‰ä¸ªæ„é€ å‡½æ•°
        Listnode(): val(0), next(nullptr) {}
        Listnode(int x): val(x), next(nullptr) {}
        Listnode(int x, Listnode* p): val(x), next(p) {}
    };
    int len;//é“¾è¡¨é•¿åº¦
    Listnode* dummyhead;////è™šæ‹Ÿå¤´ç»“ç‚¹
        
    MyLinkedList() {
        len = 0;
        dummyhead = new Listnode(0);//å®ä¾‹åŒ–è™šæ‹Ÿå¤´ç»“ç‚¹
    }
    
    int get(int index) {
        if (index > len - 1 || index < 0)  return -1;//ä¸‹æ ‡æ— æ•ˆ
        //ä¸‹é¢å°±æ˜¯ä¸‹æ ‡æœ‰æ•ˆçš„æƒ…å†µ
        Listnode* p = dummyhead->next;
        //ä»ä¸‹æ ‡ä¸º0çš„dummmyhead->nextåˆ°ä¸‹æ ‡ä¸ºindexçš„èŠ‚ç‚¹éœ€è¦p = p->next indexæ¬¡
        while (index--) p = p->next;//è®¡æ•°ä»indexåˆ°1å…±indexæ¬¡
        return p->val;
    }
    
    void addAtHead(int val) {
        Listnode* head = new Listnode(val);
        head->next = dummyhead->next;//æ–°å¤´ç»“ç‚¹æ¥ç®¡æ—§å¤´ç»“ç‚¹ä»¥åŠå…¶åæ‰€æœ‰
        dummyhead->next = head;
        ++len;
    }
    
    void addAtTail(int val) {
        Listnode* p = dummyhead;//ç”¨äºéå†
        Listnode* end = new Listnode(val);
        while (p->next) p = p->next;
        p->next = end;
        ++len;
    }
    
    void addAtIndex(int index, int val) {
        if (index > len || index < 0) return;//è¶Šç•Œ
        Listnode* ins = new Listnode(val);
        Listnode* p = dummyhead;//ç”¨äºéå†
        while (index--) p = p->next;//æ“ä½œindexæ¬¡, pä»dummyhead(-1)æŒ‡åˆ°ä¸‹æ ‡ä¸ºindex-1çš„èŠ‚ç‚¹
        ins->next = p->next;
        p->next = ins;
        ++len;
    }
    
    void deleteAtIndex(int index) {
        if (index > len - 1 || index < 0)  return;//ä¸‹æ ‡æ— æ•ˆ
        Listnode* p = dummyhead;//éå†
        while (index--) p = p->next;//æ“ä½œindexæ¬¡, pä»dummyhead(-1)æŒ‡åˆ°ä¸‹æ ‡ä¸ºindex-1çš„èŠ‚ç‚¹
        Listnode* tmp = p->next;
        p->next = p->next->next;
        delete tmp;
        tmp = nullptr;//deleteåè®°å¾—ç½®ç©º
        --len;
    }
};
```

## :fire:[lc206 åè½¬é“¾è¡¨](https://leetcode.cn/problems/reverse-linked-list/)   

### é¢˜æ„

ç»™ä½ å•é“¾è¡¨çš„å¤´èŠ‚ç‚¹ `head` , è¯·ä½ åè½¬é“¾è¡¨, å¹¶è¿”å›åè½¬åçš„é“¾è¡¨ã€‚

**ç¤ºä¾‹ 1ï¼š**

![img](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202402081313999.jpeg)

```
è¾“å…¥ï¼šhead = [1,2,3,4,5]
è¾“å‡ºï¼š[5,4,3,2,1]
```

### è¿­ä»£

```c++
ListNode* reverseList(ListNode* head) {
    // tmp = è¦åè½¬çš„ç»“ç‚¹curçš„next; ç„¶ååè½¬cur; ä¹‹åcur = tmp, é‡å¤ä¸Šè¿°æ­¥éª¤
    ListNode* pre = nullptr; 
    ListNode* cur = head;
    while (cur) {
        ListNode* tmp = cur->next;
        cur->next = pre;
        pre = cur;
        cur = tmp;
    }
    return pre;
}
```

å¤æ‚åº¦åˆ†æ

- æ—¶é—´å¤æ‚åº¦ï¼šO(n)  

- ç©ºé—´å¤æ‚åº¦ï¼šO(1)

### é€’å½’

```c++
ListNode* reverse(ListNode* cur, ListNode* pre) {
    // 2.é€’å½’ç»“æŸçš„æ¡ä»¶
    if (cur == nullptr) return pre;
    // 3.å•å±‚é€’å½’çš„é€»è¾‘ï¼š
    // æš‚å­˜è¦åè½¬çš„ç»“ç‚¹çš„nextä¸ºtmpï¼Œç„¶ååè½¬ä¸€ä¸ªç»“ç‚¹ï¼Œåè½¬åè¯¥èŠ‚ç‚¹å˜ä¸ºpreï¼Œtmpå˜ä¸ºcur
    ListNode* tmp = cur->next;
    cur->next = pre;
    
    // pre = cur;
    // cur = tmp;
    // return reverse(cur, pre);
    //ä¸Šé¢ä¸‰æ­¥å¯ä»¥ç›´æ¥åˆä¸ºä¸€æ­¥
    return reverse(tmp, cur);
}
ListNode* reverseList(ListNode* head) {
    return reverse(head, nullptr);
}
```

**å¤æ‚åº¦åˆ†æ**

- æ—¶é—´å¤æ‚åº¦ï¼šO(n)  

- ç©ºé—´å¤æ‚åº¦ï¼šO(n)


## [:fire: 141. ç¯å½¢é“¾è¡¨](https://leetcode.cn/problems/linked-list-cycle/)

### **é¢˜æ„**

ç»™ä½ ä¸€ä¸ªé“¾è¡¨çš„å¤´èŠ‚ç‚¹ `head` , åˆ¤æ–­é“¾è¡¨ä¸­æ˜¯å¦æœ‰ç¯ã€‚å­˜åœ¨è¿”å› `true` ã€‚ å¦åˆ™è¿”å› `false` ã€‚

 æç¤ºï¼šé“¾è¡¨ä¸­èŠ‚ç‚¹çš„æ•°ç›®èŒƒå›´æ˜¯ `[0, 104]`

==:star: **æ ¸å¿ƒæ€è·¯ï¼š åŒæŒ‡é’ˆ  **:star:==

æ³¨æ„ï¼š

1. é“¾è¡¨çš„é¢˜è¦æ³¨æ„å¼€å¤´éƒ½è¦ç‰¹åˆ¤ï¼ï¼ï¼
2. å¾ªç¯æ¡ä»¶

### ä»£ç 

```c++
bool hasCycle(ListNode *head) {
    // é“¾è¡¨çš„é¢˜è¦æ³¨æ„å¼€å¤´éƒ½è¦ç‰¹åˆ¤ï¼ï¼ï¼
    if (!head || !head->next) return false;
    ListNode *slow = head, *fast = head;
    //é”™è¯¯å†™æ³•ï¼šwhile (slow != fast && fast->next && fast) {
    //çœŸçš„æœäº†, ä¸€å¼€å§‹slowå°±==fast, å¾ªç¯æ¡ä»¶æ€ä¹ˆèƒ½æ˜¯slow != fastå•Šï¼ï¼ï¼
    while (fast && fast->next) {
        slow = slow->next;
        fast = fast->next->next;
        if (slow == fast) return true;
    }
    return false;
}
```

### å¤æ‚åº¦åˆ†æ

- æ—¶é—´å¤æ‚åº¦ï¼šO(n)  

- ç©ºé—´å¤æ‚åº¦ï¼šO(1)

## [:fire: 142. ç¯å½¢é“¾è¡¨ II](https://leetcode.cn/problems/linked-list-cycle-ii/)

### **é¢˜æ„**

ç»™å®šä¸€ä¸ªé“¾è¡¨çš„å¤´èŠ‚ç‚¹  `head` , **è¿”å›é“¾è¡¨å¼€å§‹å…¥ç¯çš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹**ã€‚ *å¦‚æœé“¾è¡¨æ— ç¯, åˆ™è¿”å› `null`ã€‚*

### æ³•ä¸€

å“ˆå¸Œ

**ä»£ç **

```c++
 ListNode *detectCycle(ListNode *head) {
    // æ³•ä¸€ã€ç”¨å“ˆå¸Œå­˜æ”¾éå†è¿‡çš„ç»“ç‚¹, å½“éå†åˆ°å“ˆå¸Œä¸­å­˜åœ¨çš„ç»“ç‚¹æ—¶å°±è¯´æ˜æœ‰ç¯
    unordered_set<ListNode*> visited;
    while (head != nullptr) {
        if (visited.count(head)) return head;
        visited.insert(head);
        head = head->next;
    }
    return nullptr;
 }
```

### æ³•äºŒ

==:star: **æ ¸å¿ƒæ€è·¯ï¼š åŒæŒ‡é’ˆ  **:star:==

**:question:   problems:** 

1. æ€æ ·åˆ¤æ–­æ˜¯å¦æˆç¯ï¼Ÿ 
2. æ€æ ·æ‰¾åˆ°å…¥ç¯çš„ç¬¬ä¸€ä¸ªç»“ç‚¹ï¼Ÿ

:heavy_check_mark:  **answer:** 

1. ç”¨slowå’Œfastéå†é“¾è¡¨, fastæ¯æ¬¡æ¯”slowå¤šèµ°ä¸€æ­¥, å¦‚æœéå†è¿‡ç¨‹ä¸­fast==slowè¯´æ˜æœ‰ç¯

2. 

![SmartSelect_20240126_225643_Samsung Notes](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202402091057729.jpeg)

### ä»£ç 

```c++
ListNode *detectCycle(ListNode *head) {
    if (!head || !head->next) return nullptr;
    ListNode *slow = head, *fast = head;
    //é”™è¯¯å†™æ³•ï¼šwhile (slow != fast && fast->next && fast) {
    //çœŸçš„æœäº†, ä¸€å¼€å§‹slowå°±==fast, å¾ªç¯æ¡ä»¶æ€ä¹ˆèƒ½æ˜¯slow != fastå•Šï¼ï¼ï¼
    while (fast && fast->next) {
        slow = slow->next;
        fast = fast->next->next;
        if (slow == fast) { //å¦‚æœæœ‰ç¯, åˆ™æ¥ç€æ‰¾ç¯å…¥å£
            fast = head; //è®©fastä»é“¾å¤´å¼€å§‹, slowä»ç›¸é‡ç‚¹å¼€å§‹
            while (slow != fast) {
                slow = slow->next;
                fast = fast->next;
            }
            return fast;
        }
    }
    return nullptr;
}
```

##  :fire:[146. LRU ç¼“å­˜](https://leetcode.cn/problems/lru-cache/)

### **é¢˜æ„**

è¯·ä½ è®¾è®¡å¹¶å®ç°ä¸€ä¸ªæ»¡è¶³ [LRU (æœ€è¿‘æœ€å°‘ä½¿ç”¨) ç¼“å­˜](https://baike.baidu.com/item/LRU) çº¦æŸçš„æ•°æ®ç»“æ„ã€‚

å®ç° `LRUCache` ç±»ï¼š

- `LRUCache(int capacity)` ä»¥ **æ­£æ•´æ•°** ä½œä¸ºå®¹é‡ `capacity` åˆå§‹åŒ– LRU ç¼“å­˜
- `int get(int key)` å¦‚æœå…³é”®å­— `key` å­˜åœ¨äºç¼“å­˜ä¸­, åˆ™è¿”å›å…³é”®å­—çš„å€¼, å¦åˆ™è¿”å› `-1` ã€‚
- `void put(int key, int value)` å¦‚æœå…³é”®å­— `key` å·²ç»å­˜åœ¨, åˆ™å˜æ›´å…¶æ•°æ®å€¼ `value` ï¼›å¦‚æœä¸å­˜åœ¨, åˆ™å‘ç¼“å­˜ä¸­æ’å…¥è¯¥ç»„ `key-value` ã€‚å¦‚æœæ’å…¥æ“ä½œå¯¼è‡´å…³é”®å­—æ•°é‡è¶…è¿‡ `capacity` , åˆ™åº”è¯¥ **é€å‡º** æœ€ä¹…æœªä½¿ç”¨çš„å…³é”®å­—ã€‚

å‡½æ•° `get` å’Œ `put` å¿…é¡»ä»¥ `O(1)` çš„å¹³å‡æ—¶é—´å¤æ‚åº¦è¿è¡Œã€‚

**ç¤ºä¾‹ï¼š**

```
è¾“å…¥
["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"]
[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]
è¾“å‡º
[null, null, null, 1, null, -1, null, -1, 3, 4]

è§£é‡Š
LRUCache lRUCache = new LRUCache(2);
lRUCache.put(1, 1); // ç¼“å­˜æ˜¯ {1=1}
lRUCache.put(2, 2); // ç¼“å­˜æ˜¯ {1=1, 2=2}
lRUCache.get(1);    // è¿”å› 1
lRUCache.put(3, 3); // è¯¥æ“ä½œä¼šä½¿å¾—å…³é”®å­— 2 ä½œåºŸ, ç¼“å­˜æ˜¯ {1=1, 3=3}
lRUCache.get(2);    // è¿”å› -1 (æœªæ‰¾åˆ°)
lRUCache.put(4, 4); // è¯¥æ“ä½œä¼šä½¿å¾—å…³é”®å­— 1 ä½œåºŸ, ç¼“å­˜æ˜¯ {4=4, 3=3}
lRUCache.get(1);    // è¿”å› -1 (æœªæ‰¾åˆ°)
lRUCache.get(3);    // è¿”å› 3
lRUCache.get(4);    // è¿”å› 4
```

**æç¤ºï¼š**

- `1 <= capacity <= 3000`
- `0 <= key <= 10000`
- `0 <= value <= 105`
- æœ€å¤šè°ƒç”¨ `2 * 105` æ¬¡ `get` å’Œ `put`

### å‚è€ƒé¢˜è§£

1. [ã€å­—èŠ‚ä¸€é¢ã€‘ LRU Cache å®ç°å‰–æ]( https://www.bilibili.com/video/BV1hp4y1x7MH/?share_source=copy_web&vd_source=8086e0fb4ccc0ee9410370076867092c)
1. [å®˜è§£](https://leetcode.cn/problems/lru-cache/solutions/259678/lruhuan-cun-ji-zhi-by-leetcode-solution)

### æ€è·¯

==:star: **æ ¸å¿ƒæ€è·¯ï¼šå“ˆå¸Œè¡¨ + åŒå‘é“¾è¡¨**:star:==

#### 1. ç¡®å®šé€‰ç”¨ä»€ä¹ˆæ•°æ®ç»“æ„

ç”±é¢˜ï¼Œ

- LRUCacheç»´æŠ¤ä¸€ä¸ªcapå®¹é‡ï¼Œå¦‚æœæ·»åŠ å…ƒç´ åsize>capï¼Œå°±éœ€è¦é€å‡ºæœ€ä¹…æœªä½¿ç”¨çš„å…ƒç´ ã€‚
- LRUCacheæœ‰ä¸¤ä¸ªæ—¶é—´å¤æ‚åº¦ä¸ºO(1)çš„æˆå‘˜å‡½æ•°ï¼šget()å’Œput()
    - get()ä¸­çš„é€»è¾‘æ˜¯ï¼š
        - æ ¹æ®keyè·å–valueï¼Œè¿™ä¸ªæ“ä½œè¦æƒ³æ—¶é—´å¤æ‚åº¦ä¸ºO(1)ï¼Œé‚£ä¹ˆå°±éœ€è¦ç”¨åˆ°unordered_map
        - å¦å¤–è¿˜æœ‰ä¸€ä¸ªé‡è¦ä½†å®¹æ˜“é—æ¼çš„ç‚¹ï¼šå¦‚æœkeyå­˜åœ¨äºç¼“å­˜ä¸­ï¼Œé‚£ä¹ˆget(key)ä¹‹åï¼Œkeyå°±å˜ä¸ºäº†æœ€è¿‘ä½¿ç”¨çš„å…³é”®å­—ã€‚
    - put()ä¸­çš„é€»è¾‘æ˜¯ï¼š
        - å¦‚æœkeyå­˜åœ¨ï¼Œæ”¹å˜å…¶valueï¼Œç„¶åå°†keyå˜ä¸ºæœ€è¿‘ä½¿ç”¨çš„ï¼›
        - å¦åˆ™ï¼Œå‘ç¼“å­˜ä¸­æ’å…¥key-valueï¼Œç„¶åå°†keyå˜ä¸ºæœ€è¿‘ä½¿ç”¨çš„ï¼Œå¦‚æœputåLRUCacheçš„size>capï¼Œé‚£ä¹ˆå°±éœ€è¦å°†æœ€ä¹…æœªä½¿ç”¨çš„å…³é”®å­—é€å‡ºã€‚
    - ä»è¿™ä¸¤ä¸ªå‡½æ•°çš„é€»è¾‘æˆ‘ä»¬å°±å¯ä»¥çŸ¥é“ç¼“å­˜åº”è¯¥é€‰ç”¨ä»€ä¹ˆç»“æ„äº†ï¼š
        - é™¤äº†è¦èƒ½å¿«é€Ÿæ ¹æ®é”®è·å–valueä¹‹å¤–ï¼Œç¼“å­˜é€‰ç”¨çš„ç»“æ„è¦èƒ½å¤Ÿä½“ç°å…³é”®å­—æ˜¯æœ€è¿‘ä½¿ç”¨è¿˜æ˜¯æœ€ä¹…æœªä½¿ç”¨ï¼Œå› ä¸ºæˆ‘ä»¬éœ€è¦åœ¨getä»¥åŠputåï¼Œå°†æ“ä½œçš„å…³é”®å­—å˜ä¸ºæœ€è¿‘ä½¿ç”¨çš„ï¼Œä»¥åŠå¦‚æœputåLRUCacheçš„size>capï¼Œé‚£å°±éœ€è¦å°†æœ€ä¹…æœªä½¿ç”¨çš„å…³é”®å­—é€å‡ºã€‚
        - å› æ­¤ï¼Œå…³é”®å­—è¿˜éœ€è¦æŒ‰åºç»„ç»‡ï¼Œè¿™ä¸ªé¡ºåºå°±æ˜¯ä»ï¼šæœ€è¿‘ä½¿ç”¨->æœ€ä¹…æœªä½¿ç”¨ã€‚
        - è€ƒè™‘åˆ°æ’å…¥åˆ é™¤æ‰€éœ€çš„æ—¶é—´å¤æ‚åº¦ï¼Œæˆ‘ä»¬é€‰ç”¨é“¾è¡¨è€Œä¸æ˜¯æ•°ç»„ã€‚
        - é‚£ç”¨å•å‘é“¾è¡¨è¿˜æ˜¯åŒå‘å¾ªç¯é“¾è¡¨ï¼Ÿ
        - åŒå‘å¾ªç¯é“¾è¡¨ï¼å› ä¸ºæˆ‘ä»¬ä¸ä»…éœ€è¦æ“ä½œæœ€è¿‘ä½¿ç”¨çš„å…³é”®å­—ï¼Œè¿˜éœ€è¦æ“ä½œæœ€ä¹…æœªä½¿ç”¨çš„å…³é”®å­—ã€‚å¦‚æœæ˜¯å•å‘çš„ï¼Œé‚£ä¹ˆæˆ‘ä»¬åªèƒ½æ“ä½œæœ€è¿‘ä½¿ç”¨çš„å…³é”®å­—ï¼Œæœ€ä¹…æœªä½¿ç”¨çš„å…³é”®å­—éœ€è¦éå†åˆ°é“¾è¡¨ç»“å°¾æ‰èƒ½è·å–åˆ°ã€‚è€Œå¦‚æœæ˜¯åŒå‘å¾ªç¯çš„ï¼Œæœ€ä¹…æœªä½¿ç”¨çš„å…³é”®å­—å°±èƒ½ç›´æ¥æ ¹æ®å°¾ç»“ç‚¹å¾—åˆ°ï¼Œè¿™ä¸ªæ—¶é—´å°±æ˜¯O(1)çš„ã€‚
        - ç»“åˆå‰é¢è¯´çš„unordered_mapï¼Œæˆ‘ä»¬å°±èƒ½ç¡®å®šLRUCacheé€‰ç”¨çš„ç»“æ„æ˜¯unordered_map+åŒå‘å¾ªç¯é“¾è¡¨ï¼Œè¿™æ ·LRUCacheæŸ¥æ‰¾æ’å…¥åˆ é™¤çš„æ—¶é—´å¤æ‚åº¦éƒ½æ˜¯O(1)ã€‚
        - è¿™ä¸¤ä¸ªç»“æ„æ€ä¹ˆè”ç³»èµ·æ¥å‘¢ï¼Ÿunordered_mapçš„keyå°±æ˜¯å…³é”®å­—keyï¼Œvalueæ˜¯keyå¯¹åº”çš„å­˜åœ¨äºåŒå‘å¾ªç¯é“¾è¡¨ä¸­çš„ç»“ç‚¹ã€‚åŒå‘å¾ªç¯é“¾è¡¨æ¯ä¸ªç»“ç‚¹å­˜æ”¾äº†å…³é”®å­—keyå’Œå®ƒçš„valueã€‚

![image-20240211084944957](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202402110849032.png)

#### 2. getå’Œputçš„å…·ä½“å®ç°

ç¡®å®šäº†LRUCacheé€‰ç”¨çš„ç»“æ„ï¼Œæˆ‘ä»¬å†é‡æ–°æ¢³ç†ä¸€ä¸‹get()å’Œput()çš„é€»è¾‘ã€‚

- get()ä¸­çš„é€»è¾‘æ˜¯ï¼š
    - æ ¹æ®keyä»unordered_mapä¸­è·å–keyå¯¹åº”åœ¨é“¾è¡¨ä¸­çš„ç»“ç‚¹ï¼Œå¦‚æœkeyå­˜åœ¨äºmapä¸­ï¼Œæ ¹æ®ç»“ç‚¹è·å–valueï¼Œä¹‹åï¼Œå°†keyå˜ä¸ºæœ€è¿‘ä½¿ç”¨çš„å…³é”®å­—ï¼ˆå°†åŸæ¥keyå¯¹åº”åœ¨é“¾è¡¨ä¸­çš„ç»“ç‚¹åˆ é™¤ï¼Œå†é‡æ–°newä¸€ä¸ªç»“ç‚¹å¤´æ’åˆ°é“¾è¡¨ï¼Œæ³¨æ„éœ€è¦åŒæ­¥åœ¨mapä¸­åˆ é™¤æ·»åŠ ï¼‰ã€‚
        - ä¸ºå•¥â€œå°†keyå˜ä¸ºæœ€è¿‘ä½¿ç”¨çš„å…³é”®å­—â€ï¼Œéœ€è¦åŒæ­¥æŠŠkeyä»mapä¸­åˆ é™¤å†æ·»åŠ ï¼Ÿä¸æ˜¯å¤šæ­¤ä¸€ä¸¾å—ï¼Ÿåªæ“ä½œé“¾è¡¨ä¸å°±å¯ä»¥äº†å—ï¼Ÿ
        - ä¸å¯ä»¥ï¼å› ä¸ºå¦‚æœåªæŠŠkeyå¯¹åº”åœ¨é“¾è¡¨ä¸­çš„ç»“ç‚¹åˆ é™¤ï¼Œé‚£ä¹ˆæ­¤æ—¶map[key]æŒ‡å‘å“ªå‘¢ï¼Ÿï¼Ÿå› æ­¤ï¼Œåœ¨ç»“ç‚¹ä»é“¾è¡¨ä¸­åˆ é™¤çš„åŒæ—¶ï¼Œä¹Ÿè¦æŠŠmapä¸­çš„key-valueåˆ é™¤ã€‚å¤´æ’çš„æ—¶å€™ï¼Œä¹Ÿè¦å°†key-valueæ·»åŠ åˆ°mapä¸­ã€‚
- put()ä¸­çš„é€»è¾‘æ˜¯ï¼š
    - åˆ¤æ–­keyæ˜¯å¦å­˜åœ¨äºunordered_mapï¼š
        - å¦‚æœkeyå­˜åœ¨ï¼Œå°†å…¶å¯¹åº”ç»“ç‚¹ä»é“¾è¡¨ä¸­åˆ é™¤ï¼Œ**åŒæ—¶è¦åœ¨unordered_mapåˆ é™¤é”®å€¼å¯¹**ï¼Œç„¶åç”¨keyå’Œæ–°çš„valueé‡æ–°newä¸€ä¸ªç»“ç‚¹å¤´æ’åˆ°é“¾è¡¨ï¼Œ**åŒæ—¶è¦åœ¨unordered_mapæ·»åŠ é”®å€¼å¯¹**ã€‚
        - å¦åˆ™ï¼Œkeyä¸å­˜åœ¨ï¼Œå°†key-valueå¤´æ’åˆ°é“¾è¡¨ä¸­ï¼ŒåŒæ—¶è¦åœ¨unordered_mapæ·»åŠ é”®å€¼å¯¹ï¼Œå¦‚æœputåLRUCacheçš„size>capï¼Œé‚£ä¹ˆå°±éœ€è¦å°†æœ€ä¹…æœªä½¿ç”¨çš„å…³é”®å­—é€å‡ºï¼ŒåŒæ—¶è¦åœ¨unordered_mapåˆ é™¤é”®å€¼å¯¹ã€‚

### ä»£ç 

```c++
struct Node { //é“¾è¡¨ç»“ç‚¹
    int key, value;
    Node *prev, *next;
    Node(): key(-1), value(-1), prev(nullptr), next(nullptr) {}
    Node(int x, int y) : key(x), value(y), prev(nullptr), next(nullptr) {}
};
struct DoubleLinkedList { //åŒå‘å¾ªç¯é“¾è¡¨ 
    Node *head, *tail; 
    // head: recently used æœ€è¿‘ä½¿ç”¨
    // tail: LRU (least recently used) æœ€è¿‘æœ€ä¹…æœªä½¿ç”¨

    DoubleLinkedList() : head(new Node()), tail(new Node()){
        head->next = tail;
        tail->prev = head;
    }
    // å¤´æ’ 
    void insertHead(Node* newNode) {
        // å…ˆå°†newNodeçš„ä¸¤ä¸ªæŒ‡é’ˆæ¥åœ¨headå’Œhead->nextä¹‹é—´
        newNode->prev = head;
        newNode->next = head->next;
        // ç„¶åå†å°†headçš„nextä»¥åŠhead->nextçš„prevæ¥ä¸ŠnewNode
        head->next->prev = newNode;
        head->next = newNode;
    }
    // åˆ é™¤é“¾è¡¨ä¸­çš„ç»“ç‚¹node
    int deleteNode(Node* node) {
        // è¿”å›intæ˜¯å°¾åˆ å‡½æ•°éœ€è¦è¿”å›int
        int _key = node->key;
        node->next->prev = node->prev;
        node->prev->next = node->next;
        delete node;
        node = nullptr;
        return _key;
    }
    // å°¾åˆ 
    int deleteTail() {
        // éœ€è¦è¿”å›intæ˜¯å› ä¸ºå°¾åˆ æ‰çš„ç»“ç‚¹ä¹Ÿéœ€è¦åœ¨å“ˆå¸Œmapä¸­åˆ æ‰
        // å¦‚æœé“¾è¡¨ä¸­å°±åªæœ‰headå’Œtailä¸¤ä¸ªå“¨å…µç»“ç‚¹ï¼Œç›´æ¥è¿”å›
        if (tail->prev == head) return -1;
        return deleteNode(tail->prev);
    }
};
class LRUCache {  //ç»“åˆäº†å“ˆå¸Œmapå’ŒåŒå‘å¾ªç¯é“¾è¡¨
private:
    DoubleLinkedList cache; //ä»é“¾å¤´åˆ°é“¾å°¾æ˜¯ æœ€è¿‘è¢«ä½¿ç”¨çš„èŠ‚ç‚¹-->æœ€ä¹…æ²¡è¢«ä½¿ç”¨çš„èŠ‚ç‚¹
    unordered_map<int, Node*> umap;
    int cap;
public:
    LRUCache(int capacity) : cap(capacity) {}
    
    int get(int key) {
        if (umap.count(key) == 0) {
           return -1;
        } 
        Node* node = new Node(key, umap[key]->value);
        // ä»é“¾è¡¨ä¸­åˆ é™¤åŸæ¥keyå¯¹åº”çš„ç»“ç‚¹ï¼Œç„¶åå°†å…¶å¤´æ’åˆ°é“¾è¡¨
        // æ³¨æ„ï¼mapä¸­ä¹Ÿè¦åŒæ­¥åˆ é™¤æ’å…¥
        cache.deleteNode(umap[key]);
        umap.erase(key);
        // ä¸Šé¢è¿™ä¸¤å¥ä¸èƒ½è°ƒæ¢ä½ç½®ï¼Œä¸ºä»€ä¹ˆï¼Ÿ
        // å› ä¸ºå¦‚æœå…ˆè°ƒç”¨umap.erase(key)ï¼Œé‚£å°±ä¼šå¯¼è‡´keyè¢«åˆ é™¤ï¼Œumap[key]å°±ä¸èƒ½ç”¨äº†
        cache.insertHead(node);
        umap[key] = node;
        
        return node->value;
    }
    
    void put(int key, int value) {
        if (umap.count(key)) {
            cache.deleteNode(umap[key]);
            umap.erase(key);
        } 
        Node* node = new Node(key, value);
        cache.insertHead(node);
        umap[key] = node;
        if (umap.size() > cap) { 
            int _key = cache.deleteTail();
            umap.erase(_key);
        }
    }
};

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache* obj = new LRUCache(capacity);
 * int param_1 = obj->get(key);
 * obj->put(key,value);
 */
```

### å¤æ‚åº¦åˆ†æ

- æ—¶é—´å¤æ‚åº¦ï¼šO(1) ï¼Œå¯¹äº put å’Œ get éƒ½æ˜¯ O(1)ã€‚ 
- ç©ºé—´å¤æ‚åº¦ï¼šO(capacity)ï¼Œå› ä¸ºå“ˆå¸Œè¡¨å’ŒåŒå‘é“¾è¡¨æœ€å¤šå­˜å‚¨ capacity+1ä¸ªå…ƒç´ 

## [:fire: 21. åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨](https://leetcode.cn/problems/merge-two-sorted-lists/)

### **é¢˜æ„**

å°†ä¸¤ä¸ªå‡åºé“¾è¡¨åˆå¹¶ä¸ºä¸€ä¸ªæ–°çš„ **å‡åº** é“¾è¡¨å¹¶è¿”å›ã€‚æ–°é“¾è¡¨æ˜¯é€šè¿‡æ‹¼æ¥ç»™å®šçš„ä¸¤ä¸ªé“¾è¡¨çš„æ‰€æœ‰èŠ‚ç‚¹ç»„æˆçš„ã€‚ 

**æç¤ºï¼š**

- ä¸¤ä¸ªé“¾è¡¨çš„èŠ‚ç‚¹æ•°ç›®èŒƒå›´æ˜¯ `[0, 50]`
- `-100 <= Node.val <= 100`
- `l1` å’Œ `l2` å‡æŒ‰ **éé€’å‡é¡ºåº** æ’åˆ—

### å‚è€ƒé¢˜è§£

1. é€’å½’
    1. [è…çƒ‚çš„æ©˜å­](https://leetcode.cn/problems/merge-two-sorted-lists/solutions/103891/yi-kan-jiu-hui-yi-xie-jiu-fei-xiang-jie-di-gui-by-)
    1. [è¯„è®º](https://leetcode.cn/problems/merge-two-sorted-lists/solutions/103891/yi-kan-jiu-hui-yi-xie-jiu-fei-xiang-jie-di-gui-by-/comments/1228656) ==é€’å½’æ€è·¯ï¼ä¼˜ç§€ï¼==

1. è¿­ä»£ï¼š[å®˜è§£](https://leetcode.cn/problems/merge-two-sorted-lists/solutions/226408/he-bing-liang-ge-you-xu-lian-biao-by-leetcode-solu)

### é€’å½’

```c++
ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
    // é€’å½’å‡ºå£
    if (!list1 || !list2) return list1 ? list1 : list2;
    // å•å±‚é€’å½’è¦åšå•¥äº‹ï¼Ÿè¦merge L1,L2
    // å¦‚æœL1ç¬¬ä¸€ä¸ªå…ƒç´ å°äºL2, åˆ™è¿™ä¸ªå¤§é¡¹ç›®è¦äº¤ç»™L1è´Ÿè´£
    if (list1->val <= list2->val) {
        // L1å…ˆæ¥è¿‡ä¸‹çº§å‘˜å·¥å¹²å®Œçš„æ´»: mergeTwoLists(list1->next, list2)
        // ç„¶åæŠŠè‡ªå·±å¹²çš„æ´»é™„ä¸Šå»: list1->next = ()
        list1->next = mergeTwoLists(list1->next, list2);
        // æœ€åå°†ä»»åŠ¡ç»“æœæäº¤ç»™ä¸Šçº§
        return list1;
    }
    // å¦åˆ™, è¿™ä¸ªå¤§é¡¹ç›®äº¤ç»™L2è´Ÿè´£
    list2->next = mergeTwoLists(list1, list2->next);
    return list2;
}
```

**å¤æ‚åº¦åˆ†æ**

- æ—¶é—´å¤æ‚åº¦ï¼šO(n + m)  

- ç©ºé—´å¤æ‚åº¦ï¼šO(n + m)

### è¿­ä»£

![image-20240221200322546](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202402212003767.png)

```c++
ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
    if (!list1 || !list2) return list1 ? list1 : list2;
    
    // å…ˆæ ¹æ®ä¸¤é“¾è¡¨çš„å¤´ç»“ç‚¹ç¡®å®šåˆå¹¶åçš„å¤´ç»“ç‚¹
    // ListNode* head = nullptr;
    // ListNode* cur = nullptr;
    // if (list1->val <= list2->val) {
    //     head = list1;
    //     cur = list1;
    //     list1 = list1->next;
    // } else {
    //     head = list2;
    //     cur = list2;
    //     list2 = list2->next;
    // }

    // ä¹Ÿå¯ä»¥ç›´æ¥æŠŠheadå½“ä½œè™šæ‹Ÿå¤´èŠ‚ç‚¹, å°±çœçš„ä¸Šé¢å†™è¿™ä¹ˆå¤šå•ç‹¬ç¡®å®šheadäº†
    ListNode* head = new ListNode();
    ListNode* cur = head;

    while (list1 && list2) {
        // å¾ªç¯ç»“æŸçš„æ¡ä»¶æ˜¯å…¶ä¸­ä¸€ä¸ªé“¾è¡¨å¤„ç†å®Œæ‰€æœ‰èŠ‚ç‚¹
        if (list1->val <= list2->val) {
            cur->next = list1;
            list1 = list1->next;
        } else {
            cur->next = list2;
            list2 = list2->next;
        }
        cur = cur->next;
    }
    // å¦‚æœæ˜¯L1å…¨åˆå¹¶å®Œäº†, åˆ™å°†L2åé¢æ‰€æœ‰èŠ‚ç‚¹ç›´æ¥åŠ åˆ°å°¾éƒ¨; å¦åˆ™, å°†L1åé¢æ‰€æœ‰èŠ‚ç‚¹ç›´æ¥åŠ åˆ°å°¾éƒ¨
    cur->next = list1 == nullptr ? list2 : list1;
    
    ListNode* ans = head->next;
    delete head;
    head = nullptr; 
    return ans;
}
```

**å¤æ‚åº¦åˆ†æ**

- æ—¶é—´å¤æ‚åº¦ï¼šO(n + m)  

- ç©ºé—´å¤æ‚åº¦ï¼šO(1)

### Follow Upï¼šåˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨å¹¶å»é‡

å¾…è¡¥å……ã€‚ã€‚ã€‚





## [:fire:160. ç›¸äº¤é“¾è¡¨](https://leetcode.cn/problems/intersection-of-two-linked-lists/)

### **é¢˜æ„**

ç»™ä½ ä¸¤ä¸ªå•é“¾è¡¨çš„å¤´èŠ‚ç‚¹ `headA` å’Œ `headB` ï¼Œè¯·ä½ æ‰¾å‡ºå¹¶è¿”å›ä¸¤ä¸ªå•é“¾è¡¨ç›¸äº¤çš„èµ·å§‹èŠ‚ç‚¹ã€‚å¦‚æœä¸¤ä¸ªé“¾è¡¨ä¸å­˜åœ¨ç›¸äº¤èŠ‚ç‚¹ï¼Œè¿”å› `null` ã€‚

**æ³¨æ„**ï¼Œå‡½æ•°è¿”å›ç»“æœåï¼Œé“¾è¡¨å¿…é¡» **ä¿æŒå…¶åŸå§‹ç»“æ„** ã€‚

**ç¤ºä¾‹ 1ï¼š**

[![img](https://assets.leetcode.com/uploads/2021/03/05/160_example_1_1.png)](https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png)

```
è¾“å…¥ï¼šintersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3
è¾“å‡ºï¼šIntersected at '8'
è§£é‡Šï¼šç›¸äº¤èŠ‚ç‚¹çš„å€¼ä¸º 8 ï¼ˆæ³¨æ„ï¼Œå¦‚æœä¸¤ä¸ªé“¾è¡¨ç›¸äº¤åˆ™ä¸èƒ½ä¸º 0ï¼‰ã€‚
ä»å„è‡ªçš„è¡¨å¤´å¼€å§‹ç®—èµ·ï¼Œé“¾è¡¨ A ä¸º [4,1,8,4,5]ï¼Œé“¾è¡¨ B ä¸º [5,6,1,8,4,5]ã€‚
åœ¨ A ä¸­ï¼Œç›¸äº¤èŠ‚ç‚¹å‰æœ‰ 2 ä¸ªèŠ‚ç‚¹ï¼›åœ¨ B ä¸­ï¼Œç›¸äº¤èŠ‚ç‚¹å‰æœ‰ 3 ä¸ªèŠ‚ç‚¹ã€‚
â€” è¯·æ³¨æ„ç›¸äº¤èŠ‚ç‚¹çš„å€¼ä¸ä¸º 1ï¼Œå› ä¸ºåœ¨é“¾è¡¨ A å’Œé“¾è¡¨ B ä¹‹ä¸­å€¼ä¸º 1 çš„èŠ‚ç‚¹ (A ä¸­ç¬¬äºŒä¸ªèŠ‚ç‚¹å’Œ B ä¸­ç¬¬ä¸‰ä¸ªèŠ‚ç‚¹) æ˜¯ä¸åŒçš„èŠ‚ç‚¹ã€‚æ¢å¥è¯è¯´ï¼Œå®ƒä»¬åœ¨å†…å­˜ä¸­æŒ‡å‘ä¸¤ä¸ªä¸åŒçš„ä½ç½®ï¼Œè€Œé“¾è¡¨ A å’Œé“¾è¡¨ B ä¸­å€¼ä¸º 8 çš„èŠ‚ç‚¹ (A ä¸­ç¬¬ä¸‰ä¸ªèŠ‚ç‚¹ï¼ŒB ä¸­ç¬¬å››ä¸ªèŠ‚ç‚¹) åœ¨å†…å­˜ä¸­æŒ‡å‘ç›¸åŒçš„ä½ç½®ã€‚
```

**æç¤ºï¼š**

- `listA` ä¸­èŠ‚ç‚¹æ•°ç›®ä¸º `m`
- `listB` ä¸­èŠ‚ç‚¹æ•°ç›®ä¸º `n`
- `1 <= m, n <= 3 * 104`
- `1 <= Node.val <= 105`
- `0 <= skipA <= m`
- `0 <= skipB <= n`
- å¦‚æœ `listA` å’Œ `listB` æ²¡æœ‰äº¤ç‚¹ï¼Œ`intersectVal` ä¸º `0`
- å¦‚æœ `listA` å’Œ `listB` æœ‰äº¤ç‚¹ï¼Œ`intersectVal == listA[skipA] == listB[skipB]`

**è¿›é˜¶ï¼š**ä½ èƒ½å¦è®¾è®¡ä¸€ä¸ªæ—¶é—´å¤æ‚åº¦ `O(m + n)` ã€ä»…ç”¨ `O(1)` å†…å­˜çš„è§£å†³æ–¹æ¡ˆï¼Ÿ

### æ€è·¯

==:star: **æ ¸å¿ƒæ€è·¯ï¼šåŒæŒ‡é’ˆ + æ•°å­¦   **:star:==

![image-20240226223915806](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202402262239913.png)

**ä»£ç **

```c++
ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
    ListNode* head = new ListNode();
    ListNode* cur = head;
    ListNode* pA = headA;
    ListNode* pB = headB;
    while (pA != pB) {
        pA = (pA ? pA->next : headB);
        pB = (pB ? pB->next : headA);
    }
    cur->next = (pA ? pA : pB);

    ListNode* ans = head->next;
    delete head;
    head = nullptr;

    return ans;
}
```

**å¤æ‚åº¦åˆ†æ**

- æ—¶é—´å¤æ‚åº¦ï¼šO(n + m)  

- ç©ºé—´å¤æ‚åº¦ï¼šO(1)

## [:fire:23. åˆå¹¶ K ä¸ªå‡åºé“¾è¡¨](https://leetcode.cn/problems/merge-k-sorted-lists/)

### **é¢˜æ„**

ç»™ä½ ä¸€ä¸ªé“¾è¡¨æ•°ç»„ï¼Œæ¯ä¸ªé“¾è¡¨éƒ½å·²ç»æŒ‰å‡åºæ’åˆ—ã€‚

è¯·ä½ å°†æ‰€æœ‰é“¾è¡¨åˆå¹¶åˆ°ä¸€ä¸ªå‡åºé“¾è¡¨ä¸­ï¼Œè¿”å›åˆå¹¶åçš„é“¾è¡¨ã€‚

**ç¤ºä¾‹ 1ï¼š**

```
è¾“å…¥ï¼šlists = [[1,4,5],[1,3,4],[2,6]]
è¾“å‡ºï¼š[1,1,2,3,4,4,5,6]
è§£é‡Šï¼šé“¾è¡¨æ•°ç»„å¦‚ä¸‹ï¼š
[
  1->4->5,
  1->3->4,
  2->6
]
å°†å®ƒä»¬åˆå¹¶åˆ°ä¸€ä¸ªæœ‰åºé“¾è¡¨ä¸­å¾—åˆ°ã€‚
1->1->2->3->4->4->5->6
```

**ç¤ºä¾‹ 2ï¼š**

```
è¾“å…¥ï¼šlists = []
è¾“å‡ºï¼š[]
```

**ç¤ºä¾‹ 3ï¼š**

```
è¾“å…¥ï¼šlists = [[]]
è¾“å‡ºï¼š[]
```

**æç¤ºï¼š**

- `k == lists.length`
- `0 <= k <= 10^4`
- `0 <= lists[i].length <= 500`
- `-10^4 <= lists[i][j] <= 10^4`
- `lists[i]` æŒ‰ **å‡åº** æ’åˆ—
- `lists[i].length` çš„æ€»å’Œä¸è¶…è¿‡ `10^4`

### å‚è€ƒé¢˜è§£

1. [å®˜è§£](https://leetcode.cn/problems/merge-k-sorted-lists/solutions/219756/he-bing-kge-pai-xu-lian-biao-by-leetcode-solutio-2)

### æ³•ä¸€

æš´åŠ›ï¼šé¡ºåºåˆå¹¶ã€‚

å°†æ¯æ¡é“¾è¡¨å–å‡ºæ¥ä¸ansåˆå¹¶ï¼ˆåˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨ï¼‰ï¼Œå°†åˆå¹¶ç»“æœè¿”ç»™ansï¼Œä¸æ–­æ›´æ–°ansï¼Œæœ€ç»ˆanså°±æ˜¯æ‰€æœ‰é“¾è¡¨åˆå¹¶åçš„ç»“æœã€‚

```c++
ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
    if (!list1 || !list2) return list1 ? list1 : list2;
    ListNode* head = new ListNode();
    ListNode* cur = head;

    while (list1 && list2) { 
        if (list1->val <= list2->val) {
            cur->next = list1;
            list1 = list1->next;
        } else {
            cur->next = list2;
            list2 = list2->next;
        }
        cur = cur->next;
    } 
    cur->next = list1 ? list1 : list2;
    
    ListNode* ans = head->next;
    delete head;
    head = nullptr; 
    return ans;
}
ListNode* mergeKLists(vector<ListNode*>& lists) {
    ListNode* ans = nullptr;
    for (auto list : lists) {
        ans = mergeTwoLists(ans, list);
    }
    return ans;
}
```

#### å¤æ‚åº¦åˆ†æ

å‡è®¾æ¯ä¸ªé“¾è¡¨çš„æœ€é•¿é•¿åº¦æ˜¯ n.

- æ—¶é—´å¤æ‚åº¦ï¼šO(k^2^n)  

    ![image-20240226230825439](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202402262308498.png)

- ç©ºé—´å¤æ‚åº¦ï¼šO(1)

### æ³•äºŒ

==:star: **æ ¸å¿ƒæ€è·¯ï¼š åˆ†æ²»åˆå¹¶  **:star:==

**:question:   problems:** 

1. ä¸ºä»€ä¹ˆmidä¸‹å–æ•´ä¸èƒ½ç”¨ä¸Šå–æ•´çš„åˆ†æ²»å†™æ³•? å³ä¸ºä»€ä¹ˆmidä¸‹å–æ•´æ—¶ä¸èƒ½å†™æˆ `ListNode* L1 = merge(lists, left, mid); ListNode* L2 = merge(lists, mid + 1, right);` ?

:heavy_check_mark:  **answer:** 

1. å¦‚æœmidä¸‹å–æ•´æ—¶åˆ†æ²»é€»è¾‘å†™æˆ `ListNode* L1 = merge(lists, left, mid); ListNode* L2 = merge(lists, mid + 1, right);`å¦‚ä¸‹ï¼š

![image-20240227124231265](C:\Users\Oscar\AppData\Roaming\Typora\typora-user-images\image-20240227124231265.png)

#### ä»£ç 

```c++
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        if (!list1 || !list2) return list1 ? list1 : list2;
        ListNode* head = new ListNode();
        ListNode* cur = head;

        while (list1 && list2) { 
            if (list1->val <= list2->val) {
                cur->next = list1;
                list1 = list1->next;
            } else {
                cur->next = list2;
                list2 = list2->next;
            }
            cur = cur->next;
        } 
        cur->next = list1 ? list1 : list2;
        
        ListNode* ans = head->next;
        delete head;
        head = nullptr; 
        return ans;
    }
    ListNode* merge(vector<ListNode*>& lists, int left, int right) {
        // 1.é€’å½’å‚æ•°ä»¥åŠè¿”å›å€¼: éœ€è¦ä¸¤ä¸ªintè¡¨ç¤ºåˆ†æ²»åŒºé—´çš„ä¸¤ç«¯ç‚¹
        // 2.é€’å½’ç»“æŸçš„æ¡ä»¶: åˆ†æ²»åŒºé—´é•¿åº¦ä¸º1æ—¶,å³åªæœ‰ä¸€ä¸ªé“¾è¡¨æ—¶
        if (left == right) return lists[left];
        else if (left > right) return nullptr;
        // 3.å•å±‚é€’å½’åšä»€ä¹ˆäº‹? å…ˆåˆ†æ²»(ä¸€åˆ†ä¸ºäºŒ),å†åˆå¹¶
        // å…ˆåˆ†æ²»
        int mid = left + (right - left) / 2; 		//midä¸‹å–æ•´
        ListNode* L1 = merge(lists, left, mid);
        ListNode* L2 = merge(lists, mid + 1, right); 
        
        // int mid = left + (right - left + 1) / 2; // midä¸Šå–æ•´
        // ListNode* L1 = merge(lists, left, mid - 1);
        // ListNode* L2 = merge(lists, mid, right);
        
        // å†åˆå¹¶
        return mergeTwoLists(L1, L2);
    }
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        if (lists.size() == 0) return nullptr; 
        return merge(lists, 0, lists.size() - 1);
    }
};
```

#### å¤æ‚åº¦åˆ†æ

å‡è®¾æ¯ä¸ªé“¾è¡¨çš„æœ€é•¿é•¿åº¦æ˜¯ n

- æ—¶é—´å¤æ‚åº¦ï¼š*O*(knlogk) 

    é€šè¿‡é€’å½’åˆ†æ²»çš„æ–¹å¼å°†kä¸ªé“¾è¡¨ä¸¤ä¸¤åˆå¹¶ï¼Œæ¯æ¬¡åˆå¹¶çš„æ—¶é—´å¤æ‚åº¦æ˜¯O(kn)ï¼Œè€Œæ€»å…±éœ€è¦åˆå¹¶logkæ¬¡ï¼Œå› æ­¤æ€»çš„æ—¶é—´å¤æ‚åº¦æ˜¯*O*(knlogk) ã€‚

    ![image-20240227150029742](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202402271500841.png)

- ç©ºé—´å¤æ‚åº¦ï¼šO(logk)

### æ³•ä¸‰

==:star: **æ ¸å¿ƒæ€è·¯ï¼šå°æ ¹å †ï¼ˆä¼˜å…ˆçº§é˜Ÿåˆ—å®ç°ï¼‰  **:star:==

**:key:  keyï¼š**

- ç»´æŠ¤ä¸€ä¸ªå¤§å°ä¸º k ï¼ˆ=é“¾è¡¨æ•°é‡ï¼‰çš„å°æ ¹å †ï¼ˆç”¨ä¼˜å…ˆçº§é˜Ÿåˆ—å®ç°ï¼‰ï¼Œå †ä¸­ç»´æŠ¤æ¯ä¸ªé“¾è¡¨ä¸­æœ€å‰é¢çš„é‚£ä¸ªæœªè¢«åˆå¹¶çš„å…ƒç´ ï¼Œæ¯æ¬¡é€‰å–å †é¡¶å…ƒç´ å°¾æ’åˆ° å·²åˆå¹¶çš„é“¾è¡¨ã€‚
- æ‰‹å†™å †ä¹Ÿè¦æŒæ¡ï¼å‚è€ƒã€æ’åºã€‘é‚£ä¸€ç« èŠ‚çš„topKã€‚

#### ä»£ç 

##### ä¼˜å…ˆçº§é˜Ÿåˆ—å®ç°å°æ ¹å †

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class compare {
public: //ä¸è¦å¿˜äº†classé»˜è®¤æ˜¯private, æ‰€ä»¥è¦å†™public
    bool operator() (ListNode* a, ListNode* b) {
        return a->val > b->val;
    }
};
class Solution {
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        priority_queue<ListNode*, vector<ListNode*>, compare> pri_que; 
        // åˆå§‹åŒ–å°æ ¹å †ä¸ºkä¸ªé“¾è¡¨çš„é¦–ç»“ç‚¹
        for (auto firstNode : lists) {
            // æ³¨æ„åˆ¤ç©ºï¼ï¼ï¼
            if (firstNode) pri_que.push(firstNode);
        }
        ListNode* dummyHead = new ListNode();
        ListNode* cur = dummyHead;
        // å¼€å§‹è¾¹popè¾¹åˆå¹¶è¾¹push
        while (!pri_que.empty()) {
            auto node = pri_que.top(); pri_que.pop();
            cur->next = node; 
            cur = cur->next;
            // å°†è¯¥èŠ‚ç‚¹æ‰€åœ¨çš„é“¾è¡¨çš„ä¸‹ä¸€èŠ‚ç‚¹è¿›å †ã€‚æ³¨æ„åˆ¤ç©ºï¼ï¼ï¼
            if (node->next) pri_que.push(node->next);
        }
        ListNode* ans = dummyHead->next;
        delete dummyHead;
        dummyHead = nullptr;
        return ans;
    }
};
```

##### æ‰‹å†™å°æ ¹å †

```cpp
class Solution {
public:
    void buildMinHeap(vector<ListNode*>& minHeap) {
        for (int i = minHeap.size() / 2 - 1; i >= 0; --i) {
            adjustMinHeap(minHeap, i, minHeap.size());
        }
    }
    void adjustMinHeap(vector<ListNode*>& minHeap, int start, int end) {
        int parent = start;
        int Lnode = 2 * start + 1;
        int Rnode = 2 * start + 2;
        if (Lnode < end && minHeap[Lnode]->val < minHeap[parent]->val) {
            parent = Lnode;
        } 
        if (Rnode < end && minHeap[Rnode]->val < minHeap[parent]->val) {
            parent = Rnode;
        } 
        // äº¤æ¢å®Œä¹‹åçˆ¶èŠ‚ç‚¹å°±æ˜¯ä¸‰è€…ä¸­æœ€å°çš„
        // åŸçˆ¶èŠ‚ç‚¹è¢«æ¢åˆ°å“ªæ£µå­æ ‘ï¼Œå“ªä¸ªå­æ ‘å°±è¦å†è°ƒæ•´
        if (parent != start) {
            swap(minHeap[start], minHeap[parent]);
            adjustMinHeap(minHeap, parent, end);
        }
    }
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        vector<ListNode*> minHeap; 
        // 1.å»ºå°æ ¹å †
        for (auto firstNode : lists) {
            if (firstNode) minHeap.emplace_back(firstNode);
        }
        buildMinHeap(minHeap);
        ListNode* dummyHead = new ListNode();
        ListNode* cur = dummyHead;
        // 2.è¾¹popè¾¹åˆå¹¶ è¾¹pushè¾¹è°ƒæ•´å †
        while (minHeap.size() > 0) {
            auto node = minHeap[0];
            cur->next = node;
            cur = cur->next;
            if (node->next) {
                minHeap.emplace_back(node->next); 
            }
            // å°†ç”¨äº†çš„å †é¡¶minHeap[0]æ¢åˆ°å †å°¾ä»¥ä¾¿pop_back
            swap(minHeap[0], minHeap.back());
            minHeap.pop_back();
            // é‡æ–°è°ƒæ•´å †
            adjustMinHeap(minHeap, 0, minHeap.size());
        }
        ListNode* ans = dummyHead->next;
        delete dummyHead;
        dummyHead = nullptr;
        return ans;
    }
};
```

#### å¤æ‚åº¦åˆ†æ

- æ—¶é—´å¤æ‚åº¦ï¼šO(knlogn)  ã€‚å¾€å †ä¸­æ’å…¥å’Œåˆ é™¤å…ƒç´ çš„æ—¶é—´å¤æ‚åº¦éƒ½æ˜¯O(log k)ï¼Œæ€»å…±æœ‰ kn ä¸ªå…ƒç´ ä¼šè¢«æ’å…¥å’Œåˆ é™¤å„ä¸€æ¬¡ï¼Œå› æ­¤æ€»çš„æ—¶é—´å¤æ‚åº¦å°±æ˜¯O(knlogn)ã€‚

- ç©ºé—´å¤æ‚åº¦ï¼šO(k)

## [:fire: 19 åˆ é™¤é“¾è¡¨çš„å€’æ•°ç¬¬ N ä¸ªç»“ç‚¹](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/) 

### **é¢˜æ„**

ç»™ä½ ä¸€ä¸ªé“¾è¡¨, åˆ é™¤é“¾è¡¨çš„å€’æ•°ç¬¬ `n` ä¸ªç»“ç‚¹, å¹¶ä¸”è¿”å›é“¾è¡¨çš„å¤´ç»“ç‚¹ã€‚

### æ€è·¯

==:star: **æ ¸å¿ƒæ€è·¯ï¼šå¿«æ…¢åŒæŒ‡é’ˆ   **:star:==

**:small_red_triangle_down:  steps: **

1.  å…ˆè¦æ‰¾åˆ°å€’æ•°ç¬¬Nä¸ªç»“ç‚¹çš„å‰ä¸€ä¸ªç»“ç‚¹preï¼šè®©ä¸¤ä¸ªæŒ‡é’ˆç›¸éš”Nä»å·¦å¾€å³éå†,å½“å¿«æŒ‡é’ˆåˆ°é“¾è¡¨æœ«å°¾ç»“ç‚¹æ—¶æ…¢æŒ‡é’ˆå°±æŒ‡å‘å€’æ•°ç¬¬N+1ä¸ªç»“ç‚¹äº†
2.  ç„¶åè®©pre->next=pre->next->nextå°±åˆ é™¤äº†å€’æ•°ç¬¬Nä¸ªç»“ç‚¹

**:x: careless | ignore :**

- while ((n + 1)--)ä¼šé€ æˆæ— é™å¾ªç¯ã€‚å› ä¸º++ã€--éƒ½åªèƒ½ç”¨äºå˜é‡, è€Œä¸èƒ½ç”¨äºå¸¸é‡æˆ–è¡¨è¾¾å¼ã€‚è€Œ(n+1)å¹¶ä¸æ˜¯ä¸€ä¸ªå˜é‡, è€Œæ˜¯ä¸€ä¸ªç¡®å®šå€¼, æ‰€ä»¥(n+1)--éæ³•ã€‚

### ä»£ç 

```   c++
ListNode* removeNthFromEnd(ListNode* head, int n) {
    if (head == nullptr && head->next == nullptr) return nullptr;
    ListNode *dummyhead = new ListNode(0, head), *slow = dummyhead, *fast = dummyhead;
    // 1. å…ˆæ‰¾åˆ°å€’æ•°ç¬¬N+1ä¸ªç»“ç‚¹
    //å€’æ•°ç¬¬2ä¸ªç»“ç‚¹å’Œå€’æ•°ç¬¬1ä¸ªç»“ç‚¹ç›¸éš”1ä¸ªnext, å€’æ•°å€’æ•°ç¬¬n+1ä¸ªç»“ç‚¹å’Œå€’æ•°ç¬¬1ä¸ªç»“ç‚¹å°±ç›¸éš”nä¸ªnext
    while (n--) fast = fast->next;
    while (fast->next) { //é€€å‡ºå¾ªç¯æ—¶fastæŒ‡å‘æœ«å°¾éç©ºç»“ç‚¹, å³å€’æ•°ç¬¬ä¸€ä¸ªç»“ç‚¹, slowæŒ‡å‘å€’æ•°ç¬¬n+1ä¸ªç»“ç‚¹
        slow = slow->next;
        fast = fast->next;
    }
    // 2. ç„¶ååˆ é™¤å€’æ•°ç¬¬Nä¸ªç»“ç‚¹
    slow->next = slow->next->next;
    
    return dummyhead->next;
    // è‹¥è¦é‡Šæ”¾dummyheadå†…å­˜, åˆ™åº”å†™æˆ
    // head = dummyhead->next;
    // delete dummyhead;
    // dummyhead = nullptr;
    // return head;
}
```

## :fire:[2. ä¸¤æ•°ç›¸åŠ ](https://leetcode.cn/problems/add-two-numbers/)

### é¢˜æ„

ç»™ä½ ä¸¤ä¸ª **éç©º** çš„é“¾è¡¨ï¼Œè¡¨ç¤ºä¸¤ä¸ªéè´Ÿçš„æ•´æ•°ã€‚å®ƒä»¬æ¯ä½æ•°å­—éƒ½æ˜¯æŒ‰ç…§ **é€†åº** çš„æ–¹å¼å­˜å‚¨çš„ï¼Œå¹¶ä¸”æ¯ä¸ªèŠ‚ç‚¹åªèƒ½å­˜å‚¨ **ä¸€ä½** æ•°å­—ã€‚

è¯·ä½ å°†ä¸¤ä¸ªæ•°ç›¸åŠ ï¼Œå¹¶ä»¥ç›¸åŒå½¢å¼è¿”å›ä¸€ä¸ªè¡¨ç¤ºå’Œçš„é“¾è¡¨ã€‚

ä½ å¯ä»¥å‡è®¾é™¤äº†æ•°å­— 0 ä¹‹å¤–ï¼Œè¿™ä¸¤ä¸ªæ•°éƒ½ä¸ä¼šä»¥ 0 å¼€å¤´ã€‚

**ç¤ºä¾‹ 1ï¼š**

![img](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202403020030331.jpeg)

```
è¾“å…¥ï¼šl1 = [2,4,3], l2 = [5,6,4]
è¾“å‡ºï¼š[7,0,8]
è§£é‡Šï¼š342 + 465 = 807.
```

**ç¤ºä¾‹ 2ï¼š**

```
è¾“å…¥ï¼šl1 = [0], l2 = [0]
è¾“å‡ºï¼š[0]
```

**ç¤ºä¾‹ 3ï¼š**

```
è¾“å…¥ï¼šl1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
è¾“å‡ºï¼š[8,9,9,9,0,0,0,1]
```

**æç¤ºï¼š**

- æ¯ä¸ªé“¾è¡¨ä¸­çš„èŠ‚ç‚¹æ•°åœ¨èŒƒå›´ `[1, 100]` å†…
- `0 <= Node.val <= 9`
- é¢˜ç›®æ•°æ®ä¿è¯åˆ—è¡¨è¡¨ç¤ºçš„æ•°å­—ä¸å«å‰å¯¼é›¶

### æ€è·¯ 

**:key:  keyï¼š**

- é€ä½è¿›è¡Œç›¸åŠ å¹¶å¤„ç†è¿›ä½ã€‚æ­¥éª¤å¦‚ä¸‹ï¼š

    1. åˆå§‹åŒ–ä¸€ä¸ªè™šæ‹Ÿå¤´èŠ‚ç‚¹ `dummy` å’Œä¸€ä¸ªæŒ‡é’ˆ `cur`ï¼Œç”¨äºæ„å»ºç›¸åŠ åçš„é“¾è¡¨ã€‚åŒæ—¶ï¼Œåˆå§‹åŒ–ä¸€ä¸ªå˜é‡ `carry` ç”¨äºå­˜å‚¨è¿›ä½ã€‚

    2. å¾ªç¯ç›´åˆ°ä¸¤æ¡é“¾è¡¨éƒ½éå†å®Œæ¯•ï¼š

        - è®¡ç®—ä¸¤ä¸ªèŠ‚ç‚¹å€¼ä¹‹å’Œä»¥åŠè¿›ä½å€¼(å¦‚æœæŸæ¡é“¾è¡¨å·²ç»éå†å®Œï¼Œå¯ä»¥è®¤ä¸ºå…¶å€¼ä¸º 0)ï¼Œæ›´æ–°è¿›ä½å€¼ `carry`ã€‚

        - åˆ›å»ºä¸€ä¸ªæ–°çš„èŠ‚ç‚¹ï¼Œå…¶å€¼ = èŠ‚ç‚¹å€¼ä¹‹å’Œ % 10ï¼Œå°†æ–°èŠ‚ç‚¹åŠ å…¥ç›¸åŠ åçš„é“¾è¡¨ï¼Œå¹¶æ›´æ–°æŒ‡é’ˆ `cur`ã€‚ 

        - æ›´æ–°ä¸¤ä¸ªé“¾è¡¨çš„å½“å‰èŠ‚ç‚¹ä¸ºå…¶nextç»“ç‚¹ã€‚


    3. å½“ä¸¤ä¸ªé“¾è¡¨éƒ½éå†å®Œåï¼Œæ£€æŸ¥è¿›ä½å€¼ `carry` æ˜¯å¦å¤§äº 0ï¼Œå¦‚æœå¤§äº 0ï¼Œè¯´æ˜è¿˜æœ‰ä¸€ä¸ªè¿›ä½éœ€è¦å¤„ç†ï¼Œåˆ›å»ºä¸€ä¸ªå€¼ä¸º `carry` çš„èŠ‚ç‚¹å¹¶åŠ å…¥ç›¸åŠ åçš„é“¾è¡¨ã€‚
    
    4. è¿”å›è™šæ‹Ÿå¤´èŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ï¼Œå³ä¸ºç›¸åŠ åçš„é“¾è¡¨å¤´èŠ‚ç‚¹ã€‚

**æ¨¡æ‹Ÿï¼š**

![image-20240416083716213](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202404160837331.png)

### ä»£ç 

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        // å¾€å³éå†é“¾è¡¨ï¼Œæ•°å­—æ˜¯ä»ä½ä½å¾€é«˜ä½ï¼Œå’Œæ­£å¸¸çš„ç›¸åï¼Œé‚£ä¹ˆè¿›ä½ä¹Ÿæ˜¯è¿›ç»™å³è¾¹
        ListNode* dummyHead = new ListNode();
        ListNode* cur = dummyHead;
        int value = 0;
        int carry = 0;
        int sum = 0;
        while (l1 || l2) {
            if (!l1 || !l2) {
                sum = carry + (!l1 ? l2->val : l1->val);
            } else {
                sum = l1->val + l2->val + carry;
            }
            carry = sum / 10;
            cur->next = new ListNode(sum % 10);
            cur = cur->next;
            if (l1) l1 = l1->next;
            if (l2) l2 = l2->next;
        }
        if (carry > 0) {
            cur->next = new ListNode(carry);
        }
        ListNode* ans = dummyHead->next;
        delete dummyHead;
        dummyHead = nullptr;
        return ans;
    }
};
```

### å¤æ‚åº¦åˆ†æ

- æ—¶é—´å¤æ‚åº¦ï¼šO(max(n, m))  

- ç©ºé—´å¤æ‚åº¦ï¼šO(1)ã€‚è¿”å›å€¼ä¸è®¡å…¥ç©ºé—´å¤æ‚åº¦ã€‚

## :fire:[234. å›æ–‡é“¾è¡¨](https://leetcode.cn/problems/palindrome-linked-list/)

### é¢˜æ„

ç»™ä½ ä¸€ä¸ªå•é“¾è¡¨çš„å¤´èŠ‚ç‚¹ `head` ï¼Œè¯·ä½ åˆ¤æ–­è¯¥é“¾è¡¨æ˜¯å¦ä¸ºå›æ–‡é“¾è¡¨ã€‚å¦‚æœæ˜¯ï¼Œè¿”å› `true` ï¼›å¦åˆ™ï¼Œè¿”å› `false` ã€‚

**ç¤ºä¾‹ 1ï¼š**

![img](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202403091934808.jpeg)

```
è¾“å…¥ï¼šhead = [1,2,2,1]
è¾“å‡ºï¼štrue
```

**ç¤ºä¾‹ 2ï¼š**

![img](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202403091934648.jpeg)

```
è¾“å…¥ï¼šhead = [1,2]
è¾“å‡ºï¼šfalse
```

**æç¤ºï¼š**

- é“¾è¡¨ä¸­èŠ‚ç‚¹æ•°ç›®åœ¨èŒƒå›´`[1, 105]` å†…
- `0 <= Node.val <= 9`

**è¿›é˜¶ï¼š**ä½ èƒ½å¦ç”¨ `O(n)` æ—¶é—´å¤æ‚åº¦å’Œ `O(1)` ç©ºé—´å¤æ‚åº¦è§£å†³æ­¤é¢˜ï¼Ÿ

### å‚è€ƒé¢˜è§£

1. [å®˜è§£](https://leetcode.cn/problems/palindrome-linked-list/solutions/457059/hui-wen-lian-biao-by-leetcode-solution)

### æ€è·¯

==:star: **æ ¸å¿ƒæ€è·¯ï¼šåè½¬é“¾è¡¨ + å¿«æ…¢æŒ‡é’ˆ  **:star:==

**:key:  keyï¼š**

- ![SmartSelect_20240310_100226_Samsung Notes](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202403101003735.jpg)

**:question:   problems:** 

1. ä¸ºä»€ä¹ˆã€1.æ‰¾åˆ°å‰åŠéƒ¨åˆ†é“¾è¡¨çš„å°¾èŠ‚ç‚¹ã€‘ä¸­å¾ªç¯æ¡ä»¶æ˜¯`while (fast->next && fast->next->next)`è€Œä¸æ˜¯`while (fast && fast->next)`? å¯ä»¥æ˜¯`while (fast && fast->next)`å—ï¼Ÿ

:heavy_check_mark:  **answer:** 

1. ä¸å¯ä»¥ï¼ˆä¼šå¾ˆéº»çƒ¦ï¼‰ã€‚å› ä¸ºè¦åæŠ“ååŠéƒ¨åˆ†é“¾è¡¨ï¼Œä¸ä»…è¦æ‰¾åˆ°å¼€å§‹åè½¬çš„ç»“ç‚¹ï¼Œè¿˜è¦æ‰¾åˆ°èµ·å§‹åè½¬ç»“ç‚¹çš„å‰ä¸€ä¸ªç»“ç‚¹ï¼ˆå³å‰åŠéƒ¨åˆ†é“¾è¡¨çš„å°¾èŠ‚ç‚¹ï¼‰ã€‚

    - å¦‚æœç”¨while (fast && fast->next) ï¼Œé‚£ä¹ˆå½“èŠ‚ç‚¹æ•°ä¸ºå¶æ•°ï¼Œé€€å‡ºå¾ªç¯æ—¶!fastï¼Œslowåˆšå¥½æŒ‡å‘å¼€å§‹åè½¬çš„ç»“ç‚¹ã€‚ä¹Ÿå°±æ˜¯è¯´æ­¤æ—¶ä¼šè·å–ä¸åˆ°èµ·å§‹åè½¬ç»“ç‚¹çš„å‰ä¸€ä¸ªç»“ç‚¹

        ```cpp
         1 2 3 4 5    éœ€è¦ s æŒ‡å‘ 3
        sf   f   f
           s s
        
         1 2 3 4     éœ€è¦ s æŒ‡å‘ 2
        sf   f   f
           s s
        ```

    - å› æ­¤è¦å°†æ¡ä»¶æ”¹æˆ`while (fast->next && fast->next->next)`ï¼Œè¿™æ ·ä¸ç®¡èŠ‚ç‚¹æ•°ä¸ºå¥‡æ•°è¿˜æ˜¯ä¸ºå¶æ•°ï¼Œé€€å‡ºå¾ªç¯æ—¶slowéƒ½æŒ‡å‘èµ·å§‹åè½¬ç»“ç‚¹çš„å‰ä¸€ä¸ªç»“ç‚¹ã€‚
    
        ```cpp
         1 2 3 4 5 	 éœ€è¦ s æŒ‡å‘ 3
        sf   f   f
           s s
        
         1 2 3 4     éœ€è¦ s æŒ‡å‘ 2
        sf   f   
           s 
        ```
    
        

**:small_red_triangle_down:  steps: **

1. æ‰¾åˆ°å‰åŠéƒ¨åˆ†é“¾è¡¨çš„å°¾èŠ‚ç‚¹:  ç”¨å¿«æ…¢åŒæŒ‡é’ˆ(æ­¥æ•°æ˜¯ä¸¤å€å…³ç³»)ï¼Œå¿«æŒ‡é’ˆèµ°åˆ°æœ«å°¾æ—¶ï¼Œæ…¢æŒ‡é’ˆå°±æŒ‡å‘äº†ä¸­é—´
2. åè½¬é“¾è¡¨ååŠéƒ¨åˆ†
3. åŒå‘åŒæŒ‡é’ˆåˆ¤æ–­æ˜¯å¦å›æ–‡
4. è¿˜åŸé“¾è¡¨ï¼ˆä¸æ˜¯å¿…é¡»çš„ï¼Œä½†æœ€å¥½å°†é“¾è¡¨æ¢å¤åŸæ ·ï¼Œå› ä¸ºä½¿ç”¨è¯¥å‡½æ•°çš„äººé€šå¸¸ä¸å¸Œæœ›é“¾è¡¨ç»“æ„è¢«æ›´æ”¹ï¼‰

### ä»£ç 

æœ€åä¸è¿˜åŸé“¾è¡¨çš„ä»£ç 

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverse(ListNode* cur) {
        ListNode* pre = nullptr;
        while (cur) {
            ListNode* tmp = cur->next;
            cur->next = pre;
            pre = cur;
            cur = tmp;
        }
        return pre;
    }
    bool isPalindrome(ListNode* head) {
        // å¿«æ…¢åŒæŒ‡é’ˆ, fastçš„é€Ÿåº¦æ˜¯slowçš„ä¸¤å€, å½“fastéå†åˆ°é“¾è¡¨æœ«å°¾æ—¶, slowæŒ‡å‘é“¾è¡¨ä¸­é—´
        ListNode *slow = head; 
        ListNode *fast = head; 
        // 1. å…ˆæ‰¾åˆ°ä¸­é—´
        while (fast->next && fast->next->next) {
            // å¾ªç¯æ¡ä»¶æ˜¯ç»†èŠ‚ï¼ï¼ï¼
            slow = slow->next;
            fast = fast->next->next;
        }
        // 2. å¼€å§‹åè½¬ååŠéƒ¨åˆ†é“¾è¡¨
        slow->next = reverse(slow->next);
        // 2. å¼€å§‹åˆ¤æ–­å›æ–‡
        fast = slow->next;
        slow = head;
        while (fast) {
            if (slow->val != fast->val) {
                return false;
            }
            slow = slow->next;
            fast = fast->next;
        }
        return true;
    }
};
```

æœ€åè¿˜åŸé“¾è¡¨çš„ä»£ç 

```c++
class Solution {
public:
    ListNode* reverseList(ListNode* cur) {
        ListNode* pre = nullptr;
        while (cur) {
            ListNode* tmp = cur->next;
            cur->next = pre;
            pre = cur;
            cur = tmp;
        }
        return pre;
    }
    bool isPalindrome(ListNode* head) {
        if (head == nullptr) return true;
        // 1.æ‰¾åˆ°å‰åŠéƒ¨åˆ†é“¾è¡¨çš„å°¾èŠ‚ç‚¹
        ListNode* slow = head;
        ListNode* fast = head;
        while (fast->next && fast->next->next) {
            // å¾ªç¯æ¡ä»¶æ˜¯ç»†èŠ‚ï¼ï¼ï¼
            slow = slow->next;
            fast = fast->next->next;
        }
        // ä¸¤ç§æƒ…å†µé€€å‡ºå¾ªç¯æ—¶slowéƒ½æŒ‡å‘å¼€å§‹åè½¬çš„ç»“ç‚¹çš„å‰ä¸€ä¸ªç»“ç‚¹
        ListNode* pre = slow;       //å¼€å§‹åè½¬çš„ç»“ç‚¹çš„å‰ä¸€ä¸ªç»“ç‚¹
        ListNode* cur = slow->next; //å¼€å§‹åè½¬çš„ç»“ç‚¹
        // 2.åè½¬é“¾è¡¨ååŠéƒ¨åˆ†ï¼Œå¹¶æ¥åœ¨é“¾è¡¨å‰åŠéƒ¨åˆ†çš„æœ«å°¾
        pre->next = reverseList(cur);
        // 3.åŒå‘åŒæŒ‡é’ˆåˆ¤æ–­æ˜¯å¦å›æ–‡
        slow = head;
        fast = pre->next;
        while (fast) {
            if (slow->val != fast->val) {
                return false;
            }
            slow = slow->next;
            fast = fast->next;
        } 
        // 4.è¿˜åŸé“¾è¡¨
        pre->next = reverseList(pre->next);
        return true;
    }
};
```

**å¤æ‚åº¦åˆ†æ**

- æ—¶é—´å¤æ‚åº¦ï¼šO(n)  

- ç©ºé—´å¤æ‚åº¦ï¼šO(1)

### è¿­ä»£

```c++

```

**å¤æ‚åº¦åˆ†æ**

- æ—¶é—´å¤æ‚åº¦ï¼šO()  

- ç©ºé—´å¤æ‚åº¦ï¼šO()

## [lc24 ä¸¤ä¸¤äº¤æ¢é“¾è¡¨ä¸­çš„èŠ‚ç‚¹](https://leetcode.cn/problems/swap-nodes-in-pairs/) 

```c++
ListNode* swapPairs(ListNode* head) {
    ListNode *dummyhead = new ListNode(0,head), *tmp = nullptr, *pre = dummyhead;
    while (head && head->next) { //äº¤æ¢headå’Œhead->next
        // äº¤æ¢æ“ä½œ
        tmp = head->next;//tmp->2
        head->next = head->next->next;//1->3
        tmp->next = head;//2->  1->3
        pre->next = tmp;//dummyhead->  2->1->3
        // æ›´æ–°æŒ‡é’ˆ
        pre = head;
        head = head->next;
    } 
    return dummyhead->next;
}
```



## [82. åˆ é™¤æ’åºé“¾è¡¨ä¸­çš„é‡å¤å…ƒç´  II](https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/)

### **é¢˜æ„**

ç»™å®šä¸€ä¸ªå·²æ’åºçš„é“¾è¡¨çš„å¤´ `head` ,  *åˆ é™¤åŸå§‹é“¾è¡¨ä¸­æ‰€æœ‰é‡å¤æ•°å­—çš„èŠ‚ç‚¹, åªç•™ä¸‹ä¸åŒçš„æ•°å­—* ã€‚è¿”å› *å·²æ’åºçš„é“¾è¡¨* ã€‚

**ç¤ºä¾‹ 1ï¼š**

![img](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202401221037613.jpeg)

```
è¾“å…¥ï¼šhead = [1,2,3,3,4,4,5]
è¾“å‡ºï¼š[1,2,5]
```

**ç¤ºä¾‹ 2ï¼š**

![img](https://assets.leetcode.com/uploads/2021/01/04/linkedlist2.jpg)

```
è¾“å…¥ï¼šhead = [1,1,1,2,3]
è¾“å‡ºï¼š[2,3]
```

**æç¤ºï¼š**

- é“¾è¡¨ä¸­èŠ‚ç‚¹æ•°ç›®åœ¨èŒƒå›´ `[0, 300]` å†…
- `-100 <= Node.val <= 100`
- é¢˜ç›®æ•°æ®ä¿è¯é“¾è¡¨å·²ç»æŒ‰å‡åº **æ’åˆ—**

### æ€è·¯

==:star: **æ ¸å¿ƒæ€è·¯ï¼š åŒæŒ‡é’ˆ  **:star:==

![image-20240115160934861](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202401151609014.png)

### ä»£ç 

##### æ— æ³¨é‡Šçš„ç‰ˆæœ¬

```c++
ListNode* deleteDuplicates(ListNode* head) {
    if (!head || !head->next) return head;
    ListNode *dummyhead = new ListNode(0,head);
    ListNode *pre = dummyhead, *p = head; 
    while (p) { 
        while (p->next && p->val == p->next->val) p = p->next; 
        if (pre->next == p) pre = p;
        else pre->next = p->next;
        p = p->next;
    }
    return dummyhead->next;
}
```

##### å¸¦æ³¨é‡Šçš„ç‰ˆæœ¬

```c++
ListNode* deleteDuplicates(ListNode* head) {
    if (!head || !head->next) return head;
    ListNode *dummyhead = new ListNode(0,head);
    ListNode *pre = dummyhead, *p = head;
    //è¦åˆ æ‰pä»¥åŠæ‰€æœ‰ä¸ä¹‹å€¼ç›¸åŒçš„èŠ‚ç‚¹,å› æ­¤è¦ç”¨preæŒ‡å‘è¿™äº›å€¼ç›¸åŒçš„ç»“ç‚¹çš„å‰ä¸€ä¸ªç»“ç‚¹ï¼ˆä¹Ÿå³æ–°é“¾è¡¨çš„æœ«å°¾ç»“ç‚¹ï¼‰
    while (p) {
        // pè´Ÿè´£å¾€åéå†æ‰¾å€¼ç›¸åŒçš„ç»“ç‚¹ã€‚å¦‚æœpæ²¡æœ‰å€¼ç›¸åŒçš„ç»“ç‚¹, åˆ™pçš„æŒ‡å‘ä¸ä¼šå˜, å¦åˆ™, pä¼šæŒ‡å‘å€¼ç›¸åŒç»“ç‚¹ä¸­çš„æœ€åä¸€ä¸ªç»“ç‚¹
        while (p->next && p->val == p->next->val) p = p->next;
        // é€€å‡ºå¾ªç¯æ—¶på€¼!=p->nextå€¼

        // æ›´æ–°æ–°é“¾è¡¨çš„æœ«å°¾ pre
        if (pre->next == p) pre = p;//pæ²¡æœ‰å€¼ç›¸åŒçš„ç»“ç‚¹
        else pre->next = p->next;//på­˜åœ¨å€¼ç›¸åŒçš„ç»“ç‚¹, å…¨åˆ æ‰
        p = p->next;
    }
    return dummyhead->next;
}
```

### å¤æ‚åº¦åˆ†æ

- æ—¶é—´å¤æ‚åº¦ï¼šO(n)  

- ç©ºé—´å¤æ‚åº¦ï¼šO(1)

